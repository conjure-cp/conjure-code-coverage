<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DeriveGeneric, DeriveDataTypeable #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>module Conjure.Language.Type
<span class="lineno">    4 </span>    ( Type(..)
<span class="lineno">    5 </span>    , IntTag(..), reTag
<span class="lineno">    6 </span>    , TypeCheckerMode(..)
<span class="lineno">    7 </span>    , typeUnify
<span class="lineno">    8 </span>    , typesUnify
<span class="lineno">    9 </span>    , mostDefined
<span class="lineno">   10 </span>    , homoType
<span class="lineno">   11 </span>    , matrixNumDims
<span class="lineno">   12 </span>    , innerTypeOf
<span class="lineno">   13 </span>    , isPrimitiveType
<span class="lineno">   14 </span>    , typeCanIndexMatrix
<span class="lineno">   15 </span>    , morphing
<span class="lineno">   16 </span>    , containsTypeFunctorially
<span class="lineno">   17 </span>    , containsProductType
<span class="lineno">   18 </span>    , containsType
<span class="lineno">   19 </span>    ) where
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>-- conjure
<span class="lineno">   22 </span>import Conjure.Prelude
<span class="lineno">   23 </span>import Conjure.Bug
<span class="lineno">   24 </span>import Conjure.Language.Name
<span class="lineno">   25 </span>import Conjure.Language.Pretty
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>data Type
<span class="lineno">   29 </span>    = TypeAny
<span class="lineno">   30 </span>    | TypeBool
<span class="lineno">   31 </span>    | TypeInt IntTag
<span class="lineno">   32 </span>    | TypeEnum Name
<span class="lineno">   33 </span>    | TypeUnnamed Name
<span class="lineno">   34 </span>    | TypeTuple [Type]
<span class="lineno">   35 </span>    | TypeRecord [(Name, Type)]
<span class="lineno">   36 </span>    | TypeVariant [(Name, Type)]
<span class="lineno">   37 </span>    | TypeList Type
<span class="lineno">   38 </span>    | TypeMatrix Type Type
<span class="lineno">   39 </span>    | TypeSet Type
<span class="lineno">   40 </span>    | TypeMSet Type
<span class="lineno">   41 </span>    | TypeFunction Type Type
<span class="lineno">   42 </span>    | TypeSequence Type
<span class="lineno">   43 </span>    | TypeRelation [Type]
<span class="lineno">   44 </span>    | TypePartition Type
<span class="lineno">   45 </span>    deriving (<span class="decl"><span class="istickedoff">Eq</span></span>, <span class="decl"><span class="nottickedoff">Ord</span></span>, <span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, Typeable, Generic)
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>instance Serialize Type
<span class="lineno">   48 </span>instance Hashable  Type
<span class="lineno">   49 </span>instance ToJSON    Type where <span class="decl"><span class="istickedoff">toJSON = genericToJSON jsonOptions</span></span>
<span class="lineno">   50 </span>instance FromJSON  Type where <span class="decl"><span class="istickedoff">parseJSON = genericParseJSON jsonOptions</span></span>
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>instance Pretty Type where
<span class="lineno">   53 </span>    <span class="decl"><span class="istickedoff">pretty TypeAny = &quot;?&quot;</span>
<span class="lineno">   54 </span><span class="spaces">    </span><span class="istickedoff">pretty TypeBool = &quot;bool&quot;</span>
<span class="lineno">   55 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeInt (TagEnum n)) = pretty n</span>
<span class="lineno">   56 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeInt (TagUnnamed n)) = <span class="nottickedoff">pretty n</span></span>
<span class="lineno">   57 </span><span class="spaces">    </span><span class="istickedoff">pretty TypeInt{} = &quot;int&quot;</span>
<span class="lineno">   58 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeEnum nm ) = <span class="nottickedoff">pretty nm</span></span>
<span class="lineno">   59 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeUnnamed nm) = <span class="nottickedoff">pretty nm</span></span>
<span class="lineno">   60 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeTuple xs) = (if length xs &lt;= 1 then &quot;tuple&quot; else prEmpty)</span>
<span class="lineno">   61 </span><span class="spaces">                         </span><span class="istickedoff">&lt;&gt; prettyList prParens &quot;,&quot; xs</span>
<span class="lineno">   62 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeRecord xs) = &quot;record&quot; &lt;+&gt; prettyList prBraces &quot;,&quot;</span>
<span class="lineno">   63 </span><span class="spaces">        </span><span class="istickedoff">[ pretty nm &lt;+&gt; &quot;:&quot; &lt;+&gt; pretty ty | (nm, ty) &lt;- xs ]</span>
<span class="lineno">   64 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeVariant xs) = <span class="nottickedoff">&quot;variant&quot; &lt;+&gt; prettyList prBraces &quot;,&quot;</span></span>
<span class="lineno">   65 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ pretty nm &lt;+&gt; &quot;:&quot; &lt;+&gt; pretty ty | (nm, ty) &lt;- xs ]</span></span>
<span class="lineno">   66 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeList x) = prBrackets (pretty x)</span>
<span class="lineno">   67 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeMatrix index innerNested)</span>
<span class="lineno">   68 </span><span class="spaces">        </span><span class="istickedoff">= &quot;matrix indexed by&quot; &lt;+&gt; prettyList prBrackets &quot;,&quot; indices</span>
<span class="lineno">   69 </span><span class="spaces">                              </span><span class="istickedoff">&lt;+&gt; &quot;of&quot; &lt;+&gt; pretty inner</span>
<span class="lineno">   70 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">   71 </span><span class="spaces">            </span><span class="istickedoff">(indices,inner) = first (index:) $ collect innerNested</span>
<span class="lineno">   72 </span><span class="spaces">            </span><span class="istickedoff">collect (TypeMatrix i j) = first (i:) $ collect j</span>
<span class="lineno">   73 </span><span class="spaces">            </span><span class="istickedoff">collect x = ([],x)</span>
<span class="lineno">   74 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeSet x) = &quot;set of&quot; &lt;+&gt; pretty x</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeMSet x) = &quot;mset of&quot; &lt;+&gt; pretty x</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeFunction fr to) = &quot;function&quot; &lt;+&gt; pretty fr &lt;+&gt; &quot;--&gt;&quot; &lt;+&gt; pretty to</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeSequence x) = &quot;sequence of&quot; &lt;+&gt; pretty x</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypePartition x) = &quot;partition from&quot; &lt;+&gt; pretty x</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff">pretty (TypeRelation xs) = &quot;relation of&quot; &lt;+&gt; prettyList prParens &quot; *&quot; xs</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>data IntTag = TagInt                    -- was an integer in the input
<span class="lineno">   83 </span>            | TagEnum Text              -- was an enum in the input
<span class="lineno">   84 </span>            | TagUnnamed Text           -- was an unnamed in the input
<span class="lineno">   85 </span>    deriving (<span class="decl"><span class="istickedoff">Eq</span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff">Show</span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, Typeable, Generic)
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>instance Serialize IntTag
<span class="lineno">   88 </span>instance Hashable  IntTag
<span class="lineno">   89 </span>instance ToJSON    IntTag where <span class="decl"><span class="istickedoff">toJSON = genericToJSON jsonOptions</span></span>
<span class="lineno">   90 </span>instance FromJSON  IntTag where <span class="decl"><span class="istickedoff">parseJSON = genericParseJSON jsonOptions</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>reTag :: Data a =&gt; IntTag -&gt; a -&gt; a
<span class="lineno">   93 </span><span class="decl"><span class="istickedoff">reTag t = transformBi (const t)</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- This parameter will decide the mode of the type checker.
<span class="lineno">   97 </span>-- There are two modes: StronglyTyped and RelaxedIntegerTags.
<span class="lineno">   98 </span>-- StronglyTyped is used for user input.
<span class="lineno">   99 </span>-- RelaxedIntegerTags is for internal use only and it ignores the integer tags during type checking.
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>data TypeCheckerMode = StronglyTyped | RelaxedIntegerTags
<span class="lineno">  102 </span>    deriving (<span class="decl"><span class="istickedoff">Eq</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, Typeable, Generic)
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>instance Serialize TypeCheckerMode
<span class="lineno">  105 </span>instance Hashable  TypeCheckerMode
<span class="lineno">  106 </span>instance ToJSON    TypeCheckerMode where <span class="decl"><span class="nottickedoff">toJSON = genericToJSON jsonOptions</span></span>
<span class="lineno">  107 </span>instance FromJSON  TypeCheckerMode where <span class="decl"><span class="nottickedoff">parseJSON = genericParseJSON jsonOptions</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>instance Pretty TypeCheckerMode where
<span class="lineno">  110 </span>    <span class="decl"><span class="nottickedoff">pretty = pretty . show</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>-- | Check whether two types unify or not.
<span class="lineno">  114 </span>typeUnify :: (?typeCheckerMode :: TypeCheckerMode) =&gt; Type -&gt; Type -&gt; Bool
<span class="lineno">  115 </span><span class="decl"><span class="istickedoff">typeUnify TypeAny _ = True</span>
<span class="lineno">  116 </span><span class="spaces"></span><span class="istickedoff">typeUnify _ TypeAny = True</span>
<span class="lineno">  117 </span><span class="spaces"></span><span class="istickedoff">typeUnify TypeBool TypeBool = True</span>
<span class="lineno">  118 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeInt t1) (TypeInt t2) = case ?typeCheckerMode of</span>
<span class="lineno">  119 </span><span class="spaces">                                         </span><span class="istickedoff">StronglyTyped -&gt; t1 == t2</span>
<span class="lineno">  120 </span><span class="spaces">                                         </span><span class="istickedoff">RelaxedIntegerTags -&gt; True</span>
<span class="lineno">  121 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeEnum a) (TypeEnum b) = <span class="nottickedoff">a == b</span></span>
<span class="lineno">  122 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeUnnamed a) (TypeUnnamed b) = <span class="nottickedoff">a == b</span></span>
<span class="lineno">  123 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeTuple [TypeAny]) TypeTuple{} = True</span>
<span class="lineno">  124 </span><span class="spaces"></span><span class="istickedoff">typeUnify TypeTuple{} (TypeTuple [TypeAny]) = True</span>
<span class="lineno">  125 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeTuple as) (TypeTuple bs) = (length as == length bs) &amp;&amp; and (zipWith typeUnify as bs)</span>
<span class="lineno">  126 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeRecord as) (TypeRecord bs)</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length as /= length bs</span> = <span class="nottickedoff">False</span></span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = and [ case lookup n bs of</span>
<span class="lineno">  129 </span><span class="spaces">                             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  130 </span><span class="spaces">                             </span><span class="istickedoff">Just b -&gt; typeUnify a b</span>
<span class="lineno">  131 </span><span class="spaces">                      </span><span class="istickedoff">| (n,a) &lt;- as</span>
<span class="lineno">  132 </span><span class="spaces">                      </span><span class="istickedoff">]</span>
<span class="lineno">  133 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeVariant as) (TypeVariant bs)</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlyfalse">length as /= length bs</span> = <span class="nottickedoff">False</span></span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = and [ case lookup n bs of</span>
<span class="lineno">  136 </span><span class="spaces">                             </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  137 </span><span class="spaces">                             </span><span class="istickedoff">Just b -&gt; typeUnify a b</span>
<span class="lineno">  138 </span><span class="spaces">                      </span><span class="istickedoff">| (n,a) &lt;- as</span>
<span class="lineno">  139 </span><span class="spaces">                      </span><span class="istickedoff">]</span>
<span class="lineno">  140 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeList a) (TypeList b) = typeUnify a b</span>
<span class="lineno">  141 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeList a) (TypeMatrix _ b) = typeUnify a b</span>
<span class="lineno">  142 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeList a) (TypeSequence b) = <span class="nottickedoff">typeUnify a b</span></span>
<span class="lineno">  143 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeMatrix a1 a2) (TypeMatrix b1 b2) = and (zipWith typeUnify [a1,a2] [b1,b2])</span>
<span class="lineno">  144 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeMatrix _ a) (TypeList b) = typeUnify a b</span>
<span class="lineno">  145 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeMatrix _ a) (TypeSequence b) = <span class="nottickedoff">typeUnify a b</span></span>
<span class="lineno">  146 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeSequence a) (TypeSequence b) = typeUnify a b</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeSequence a) (TypeList b) = <span class="nottickedoff">typeUnify a b</span></span>
<span class="lineno">  148 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeSequence a) (TypeMatrix _ b) = <span class="nottickedoff">typeUnify a b</span></span>
<span class="lineno">  149 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeSet a) (TypeSet b) = typeUnify a b</span>
<span class="lineno">  150 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeMSet a) (TypeMSet b) = typeUnify a b</span>
<span class="lineno">  151 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeFunction a1 a2) (TypeFunction b1 b2) = and (zipWith typeUnify [a1,a2] [b1,b2])</span>
<span class="lineno">  152 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeRelation [TypeAny]) TypeRelation{} = True                -- hack to make sameToSameToBool work</span>
<span class="lineno">  153 </span><span class="spaces"></span><span class="istickedoff">typeUnify TypeRelation{} (TypeRelation [TypeAny]) = True</span>
<span class="lineno">  154 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypeRelation as) (TypeRelation bs) = (length as == length bs) &amp;&amp; and (zipWith typeUnify as bs)</span>
<span class="lineno">  155 </span><span class="spaces"></span><span class="istickedoff">typeUnify (TypePartition a) (TypePartition b) = typeUnify a b</span>
<span class="lineno">  156 </span><span class="spaces"></span><span class="istickedoff">typeUnify _ _ = False</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- | Check whether a given list of types unify with each other or not.
<span class="lineno">  159 </span>typesUnify :: (?typeCheckerMode :: TypeCheckerMode) =&gt; [Type] -&gt; Bool
<span class="lineno">  160 </span><span class="decl"><span class="istickedoff">typesUnify ts = and [ typeUnify i j | i &lt;- ts, j &lt;- ts ]</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>-- | Given a list of types, return &quot;the most defined&quot; one in this list.
<span class="lineno">  163 </span>--   This is to get rid of TypeAny's if there are any.
<span class="lineno">  164 </span>--   Precondition: `typesUnify`
<span class="lineno">  165 </span>mostDefined :: (?typeCheckerMode :: TypeCheckerMode) =&gt; [Type] -&gt; Type
<span class="lineno">  166 </span><span class="decl"><span class="istickedoff">mostDefined = foldr f TypeAny</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  168 </span><span class="spaces">        </span><span class="istickedoff">f :: Type -&gt; Type -&gt; Type</span>
<span class="lineno">  169 </span><span class="spaces">        </span><span class="istickedoff">f TypeAny x = x</span>
<span class="lineno">  170 </span><span class="spaces">        </span><span class="istickedoff">f x TypeAny = x</span>
<span class="lineno">  171 </span><span class="spaces">        </span><span class="istickedoff">f _ x@TypeBool{} = x</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">f _ x@TypeInt{} = x</span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="istickedoff">f _ x@TypeEnum{} = <span class="nottickedoff">x</span></span>
<span class="lineno">  174 </span><span class="spaces">        </span><span class="istickedoff">f _ x@TypeUnnamed{} = <span class="nottickedoff">x</span></span>
<span class="lineno">  175 </span><span class="spaces">        </span><span class="istickedoff">f (TypeTuple [TypeAny]) x = <span class="nottickedoff">x</span></span>
<span class="lineno">  176 </span><span class="spaces">        </span><span class="istickedoff">f x (TypeTuple [TypeAny]) = <span class="nottickedoff">x</span></span>
<span class="lineno">  177 </span><span class="spaces">        </span><span class="istickedoff">f (TypeTuple as) (TypeTuple bs) | <span class="tickonlytrue">length as == length bs</span> = TypeTuple (zipWith f as bs)</span>
<span class="lineno">  178 </span><span class="spaces">        </span><span class="istickedoff">f (TypeRecord as) (TypeRecord bs)</span>
<span class="lineno">  179 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">sort (map fst as) == sort (map fst bs)</span> =</span>
<span class="lineno">  180 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeRecord [ case lookup n bs of</span></span>
<span class="lineno">  181 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; bug &quot;mostDefined.TypeRecord&quot;</span></span>
<span class="lineno">  182 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Just b  -&gt; (n, f a b)</span></span>
<span class="lineno">  183 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">| (n,a) &lt;- as</span></span>
<span class="lineno">  184 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  185 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">typeUnify (TypeRecord as) (TypeRecord bs)</span> = <span class="nottickedoff">TypeAny</span></span>
<span class="lineno">  186 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">TypeAny</span></span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="istickedoff">f (TypeVariant as) (TypeVariant bs)</span>
<span class="lineno">  188 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">sort (map fst as) == sort (map fst bs)</span> =</span>
<span class="lineno">  189 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeVariant [ case lookup n bs of</span></span>
<span class="lineno">  190 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; bug &quot;mostDefined.TypeVariant&quot;</span></span>
<span class="lineno">  191 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Just b  -&gt; (n, f a b)</span></span>
<span class="lineno">  192 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">| (n,a) &lt;- as</span></span>
<span class="lineno">  193 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  194 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">typeUnify (TypeVariant as) (TypeVariant bs)</span> = <span class="nottickedoff">TypeAny</span></span>
<span class="lineno">  195 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">TypeAny</span></span>
<span class="lineno">  196 </span><span class="spaces">        </span><span class="istickedoff">f (TypeList a) (TypeList b) = TypeList (f a b)</span>
<span class="lineno">  197 </span><span class="spaces">        </span><span class="istickedoff">f (TypeMatrix a1 a2) (TypeMatrix b1 b2) = TypeMatrix (f a1 b1) (f a2 b2)</span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">f (TypeList a) (TypeMatrix _ b) = TypeList (f a b)</span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="istickedoff">f (TypeMatrix _ a) (TypeList b) = TypeList (f a b)</span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="istickedoff">f (TypeSet a) (TypeSet b) = TypeSet (f a b)</span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="istickedoff">f (TypeMSet a) (TypeMSet b) = TypeMSet (f a b)</span>
<span class="lineno">  202 </span><span class="spaces">        </span><span class="istickedoff">f (TypeFunction a1 a2) (TypeFunction b1 b2) = TypeFunction (f a1 b1) (f a2 b2)</span>
<span class="lineno">  203 </span><span class="spaces">        </span><span class="istickedoff">f (TypeSequence a) (TypeSequence b) = <span class="nottickedoff">TypeSequence (f a b)</span></span>
<span class="lineno">  204 </span><span class="spaces">        </span><span class="istickedoff">f (TypeRelation [TypeAny]) x = x</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="istickedoff">f x (TypeRelation [TypeAny]) = <span class="nottickedoff">x</span></span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff">f (TypeRelation as) (TypeRelation bs) | <span class="tickonlytrue">length as == length bs</span> = TypeRelation (zipWith f as bs)</span>
<span class="lineno">  207 </span><span class="spaces">        </span><span class="istickedoff">f (TypePartition a) (TypePartition b) = TypePartition (f a b)</span>
<span class="lineno">  208 </span><span class="spaces">        </span><span class="istickedoff">f _ _ = <span class="nottickedoff">TypeAny</span></span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>matrixNumDims :: Type -&gt; Int
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">matrixNumDims (TypeMatrix _ t) = <span class="nottickedoff">1 + matrixNumDims t</span></span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff">matrixNumDims (TypeList     t) = 1 + matrixNumDims t</span>
<span class="lineno">  213 </span><span class="spaces"></span><span class="istickedoff">matrixNumDims _ = 0</span></span>
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>homoType ::
<span class="lineno">  216 </span>    MonadFail m =&gt;
<span class="lineno">  217 </span>    (?typeCheckerMode :: TypeCheckerMode) =&gt;
<span class="lineno">  218 </span>    Doc -&gt; [Type] -&gt; m Type
<span class="lineno">  219 </span><span class="decl"><span class="istickedoff">homoType msg [] = <span class="nottickedoff">fail $ &quot;empty collection, what's the type?&quot; &lt;++&gt; (&quot;When working on:&quot; &lt;+&gt; msg)</span></span>
<span class="lineno">  220 </span><span class="spaces"></span><span class="istickedoff">homoType msg xs =</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">if typesUnify xs</span>
<span class="lineno">  222 </span><span class="spaces">        </span><span class="istickedoff">then return (mostDefined xs)</span>
<span class="lineno">  223 </span><span class="spaces">        </span><span class="istickedoff">else fail $ vcat [ &quot;Not uniformly typed:&quot; &lt;+&gt; msg</span>
<span class="lineno">  224 </span><span class="spaces">                         </span><span class="istickedoff">, &quot;Involved types are:&quot; &lt;+&gt; vcat (map pretty xs)</span>
<span class="lineno">  225 </span><span class="spaces">                         </span><span class="istickedoff">]</span></span>
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>innerTypeOf :: MonadFail m =&gt; Type -&gt; m Type
<span class="lineno">  228 </span><span class="decl"><span class="istickedoff">innerTypeOf (TypeList t) = return t</span>
<span class="lineno">  229 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeMatrix _ t) = return t</span>
<span class="lineno">  230 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeSet t) = return t</span>
<span class="lineno">  231 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeMSet t) = return t</span>
<span class="lineno">  232 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeFunction a b) = return (TypeTuple [a,b])</span>
<span class="lineno">  233 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeSequence t) = return (TypeTuple [TypeInt TagInt,t])</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypeRelation ts) = return (TypeTuple ts)</span>
<span class="lineno">  235 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf (TypePartition t) = <span class="nottickedoff">return (TypeSet t)</span></span>
<span class="lineno">  236 </span><span class="spaces"></span><span class="istickedoff">innerTypeOf t = <span class="nottickedoff">fail (&quot;innerTypeOf:&quot; &lt;+&gt; pretty (show t))</span></span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>isPrimitiveType :: Type -&gt; Bool
<span class="lineno">  239 </span><span class="decl"><span class="nottickedoff">isPrimitiveType TypeBool{} = True</span>
<span class="lineno">  240 </span><span class="spaces"></span><span class="nottickedoff">isPrimitiveType TypeInt{} = True</span>
<span class="lineno">  241 </span><span class="spaces"></span><span class="nottickedoff">isPrimitiveType (TypeMatrix index inner) = and [isPrimitiveType index, isPrimitiveType inner]</span>
<span class="lineno">  242 </span><span class="spaces"></span><span class="nottickedoff">isPrimitiveType (TypeList inner) = isPrimitiveType inner</span>
<span class="lineno">  243 </span><span class="spaces"></span><span class="nottickedoff">isPrimitiveType _ = False</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>typeCanIndexMatrix :: Type -&gt; Bool
<span class="lineno">  246 </span><span class="decl"><span class="nottickedoff">typeCanIndexMatrix TypeBool{} = True</span>
<span class="lineno">  247 </span><span class="spaces"></span><span class="nottickedoff">typeCanIndexMatrix TypeInt {} = True</span>
<span class="lineno">  248 </span><span class="spaces"></span><span class="nottickedoff">typeCanIndexMatrix TypeEnum{} = True</span>
<span class="lineno">  249 </span><span class="spaces"></span><span class="nottickedoff">typeCanIndexMatrix _          = False</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- ||| Traversals that tell us if a type (of a certain form) is contained in a Type
<span class="lineno">  252 </span>-- This allows us to abort transform early if we can see it will have no effect
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>typeComplex :: Type -&gt; Bool
<span class="lineno">  255 </span><span class="decl"><span class="nottickedoff">typeComplex TypeSequence{}  = True</span>
<span class="lineno">  256 </span><span class="spaces"></span><span class="nottickedoff">typeComplex TypePartition{} = True</span>
<span class="lineno">  257 </span><span class="spaces"></span><span class="nottickedoff">typeComplex TypeList{}      = True</span>
<span class="lineno">  258 </span><span class="spaces"></span><span class="nottickedoff">typeComplex TypeMatrix{}    = True</span>
<span class="lineno">  259 </span><span class="spaces"></span><span class="nottickedoff">typeComplex _ = False</span></span>
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>containsTypeFunctorially :: (?typeCheckerMode :: TypeCheckerMode) =&gt; Type -&gt; Type -&gt; Bool 
<span class="lineno">  262 </span><span class="decl"><span class="nottickedoff">containsTypeFunctorially container containee =</span>
<span class="lineno">  263 </span><span class="spaces">  </span><span class="nottickedoff">if typesUnify [container, containee] || typeComplex containee</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="nottickedoff">then False </span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="nottickedoff">else case innerTypeOf container of</span>
<span class="lineno">  266 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; False</span>
<span class="lineno">  267 </span><span class="spaces">           </span><span class="nottickedoff">Just so -&gt; unifiesOrContains so containee</span></span> 
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>containsProductType :: (?typeCheckerMode :: TypeCheckerMode) =&gt; Type -&gt; Type -&gt; Bool
<span class="lineno">  271 </span><span class="decl"><span class="nottickedoff">containsProductType ot@(TypeTuple ts) t =</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="nottickedoff">(not $ typesUnify [ot, t]) &amp;&amp; (any id ((\x -&gt; unifiesOrContains x t) &lt;$&gt; ts))</span>
<span class="lineno">  273 </span><span class="spaces"></span><span class="nottickedoff">containsProductType ot@(TypeRecord ts) t =</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="nottickedoff">(not $ typesUnify [ot, t]) &amp;&amp; (any id ((\x -&gt; unifiesOrContains (snd x) t) &lt;$&gt; ts))</span>
<span class="lineno">  275 </span><span class="spaces"></span><span class="nottickedoff">containsProductType _ _ = False</span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>-- Is the type
<span class="lineno">  279 </span>containsType :: (?typeCheckerMode :: TypeCheckerMode) =&gt; Type -&gt; Type -&gt; Bool
<span class="lineno">  280 </span><span class="decl"><span class="nottickedoff">containsType container containee = containee `elem` universeBi container</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>unifiesOrContains :: (?typeCheckerMode :: TypeCheckerMode) =&gt; Type -&gt; Type -&gt; Bool
<span class="lineno">  284 </span><span class="decl"><span class="nottickedoff">unifiesOrContains container containee =</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="nottickedoff">typesUnify [container, containee] || containsType container containee</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>-- as in &quot;this homomorphism is morphing&quot;
<span class="lineno">  289 </span>morphing :: (?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  290 </span>         =&gt; (MonadFail m)
<span class="lineno">  291 </span>         =&gt; Type -&gt; m Type
<span class="lineno">  292 </span><span class="decl"><span class="nottickedoff">morphing (TypeFunction a _) = return a</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="nottickedoff">morphing (TypeSequence a)   = return a </span>
<span class="lineno">  294 </span><span class="spaces"></span><span class="nottickedoff">morphing t = fail (&quot;morphing:&quot; &lt;+&gt; pretty (show t))</span></span>
<span class="lineno">  295 </span>

</pre>
</body>
</html>
