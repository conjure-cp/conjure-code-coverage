<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    2 </span>{-# LANGUAGE InstanceSigs #-}
<span class="lineno">    3 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    4 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    5 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    6 </span>{-# LANGUAGE DeriveDataTypeable #-}
<span class="lineno">    7 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    9 </span>{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
<span class="lineno">   10 </span>{-# HLINT ignore &quot;Use camelCase&quot; #-}
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>module Conjure.Language.Lexer
<span class="lineno">   13 </span>    ( Lexeme(..)
<span class="lineno">   14 </span>    , LexemePos(..)
<span class="lineno">   15 </span>    , textToLexeme,
<span class="lineno">   16 </span>    ETok(..),
<span class="lineno">   17 </span>    Offsets(..),
<span class="lineno">   18 </span>    Reformable(..),
<span class="lineno">   19 </span>    prettySplitComments,
<span class="lineno">   20 </span>    eLex,
<span class="lineno">   21 </span>    reformList,
<span class="lineno">   22 </span>    tokenSourcePos,
<span class="lineno">   23 </span>    sourcePosAfter,
<span class="lineno">   24 </span>    totalLength,
<span class="lineno">   25 </span>    trueLength,
<span class="lineno">   26 </span>    trueStart,
<span class="lineno">   27 </span>    tokenOffset,
<span class="lineno">   28 </span>    tokenStartOffset,
<span class="lineno">   29 </span>    sourcePos0,
<span class="lineno">   30 </span>    nullBefore,
<span class="lineno">   31 </span>    LexerError(..),
<span class="lineno">   32 </span>    runLexer,
<span class="lineno">   33 </span>    ETokenStream(..)
<span class="lineno">   34 </span>    , lexemeText
<span class="lineno">   35 </span>    ) where
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>import Conjure.Language.Lexemes
<span class="lineno">   38 </span>import Conjure.Prelude hiding (many, some,Text)
<span class="lineno">   39 </span>import Data.Char (isAlpha, isAlphaNum)
<span class="lineno">   40 </span>import Data.Void
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import qualified Data.Text as T
<span class="lineno">   43 </span>import qualified Data.Text.Lazy as L
<span class="lineno">   44 </span>import Text.Megaparsec hiding (State)
<span class="lineno">   45 </span>import Text.Megaparsec.Char
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>import Data.List (splitAt)
<span class="lineno">   48 </span>import qualified Data.List.NonEmpty as NE
<span class="lineno">   49 </span>import qualified Text.Megaparsec as L
<span class="lineno">   50 </span>import Prelude (read)
<span class="lineno">   51 </span>import qualified Prettyprinter as Pr
<span class="lineno">   52 </span>import Conjure.Prelude hiding (some,many)
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>import Text.Megaparsec.Stream ()
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>data LexemePos = LexemePos
<span class="lineno">   59 </span>                    Lexeme          -- the lexeme
<span class="lineno">   60 </span>                    SourcePos       -- source position, the beginning of this lexeme
<span class="lineno">   61 </span>                    SourcePos       -- source position, just after this lexeme, including whitespace after the lexeme
<span class="lineno">   62 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>sourcePos0 :: SourcePos
<span class="lineno">   65 </span><span class="decl"><span class="istickedoff">sourcePos0 = SourcePos &quot;&quot; (mkPos  1) (mkPos 1)</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>class Reformable a where
<span class="lineno">   68 </span>    reform :: a -&gt; L.Text
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>instance Reformable ETok where
<span class="lineno">   71 </span>    <span class="decl"><span class="istickedoff">reform e | totalLength e == 0 = &quot;&quot;</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="istickedoff">reform (ETok{capture=cap,trivia=triv}) = L.append  (L.concat $ map showTrivia triv) (L.fromStrict cap)</span>
<span class="lineno">   73 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">   74 </span><span class="spaces">            </span><span class="istickedoff">showTrivia :: Trivia -&gt; L.Text</span>
<span class="lineno">   75 </span><span class="spaces">            </span><span class="istickedoff">showTrivia x = case x of</span>
<span class="lineno">   76 </span><span class="spaces">              </span><span class="istickedoff">WhiteSpace txt    -&gt; L.fromStrict txt</span>
<span class="lineno">   77 </span><span class="spaces">              </span><span class="istickedoff">LineComment txt   -&gt; L.fromStrict txt</span>
<span class="lineno">   78 </span><span class="spaces">              </span><span class="istickedoff">BlockComment txt  -&gt; L.fromStrict txt</span></span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>reformList :: (Traversable t ,Reformable a) =&gt; t a -&gt; L.Text
<span class="lineno">   81 </span><span class="decl"><span class="istickedoff">reformList =  L.concat  . map reform . toList</span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>emojis :: [Char]
<span class="lineno">   84 </span><span class="decl"><span class="istickedoff">emojis =</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="istickedoff">concat</span>
<span class="lineno">   86 </span><span class="spaces">        </span><span class="istickedoff">[ ['\x1f600' .. '\x1F64F']</span>
<span class="lineno">   87 </span><span class="spaces">        </span><span class="istickedoff">, ['\x1f300' .. '\x1f5ff']</span>
<span class="lineno">   88 </span><span class="spaces">        </span><span class="istickedoff">, ['\x1f680' .. '\x1f999']</span>
<span class="lineno">   89 </span><span class="spaces">        </span><span class="istickedoff">, ['\x1f1e0' .. '\x1f1ff']</span>
<span class="lineno">   90 </span><span class="spaces">        </span><span class="istickedoff">]</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>isIdentifierFirstLetter :: Char -&gt; Bool
<span class="lineno">   93 </span><span class="decl"><span class="istickedoff">isIdentifierFirstLetter ch = isAlpha ch || ch `elem` (&quot;_&quot; :: String) || ch `elem` emojis</span></span>
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>isIdentifierLetter :: Char -&gt; Bool
<span class="lineno">   96 </span><span class="decl"><span class="istickedoff">isIdentifierLetter ch = isAlphaNum ch || ch `elem` (&quot;_'&quot; :: String) || ch `elem` emojis</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>data Offsets = Offsets {
<span class="lineno">   99 </span>        <span class="istickedoff"><span class="decl"><span class="istickedoff">oStart</span></span></span>::Int, -- the starting offset of the token (including whitespace)
<span class="lineno">  100 </span>        <span class="istickedoff"><span class="decl"><span class="istickedoff">oTotalLength</span></span></span>::Int, -- (the total length of the the token)
<span class="lineno">  101 </span>        <span class="istickedoff"><span class="decl"><span class="istickedoff">oTokenLength</span></span></span>::Int, -- (the length of the token excluding trivia)
<span class="lineno">  102 </span>        <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oTrueStart</span></span></span> :: SourcePos, -- start pos of the token
<span class="lineno">  103 </span>        <span class="istickedoff"><span class="decl"><span class="istickedoff">oSourcePos</span></span></span>::SourcePos, -- start pos of the lexeme
<span class="lineno">  104 </span>        <span class="istickedoff"><span class="decl"><span class="istickedoff">oEndPos</span></span></span>::SourcePos}
<span class="lineno">  105 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span> , <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  106 </span>type Lexer = Parsec Void Text
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- type Lexer = Parsec Void Text ETokenStream
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>data Trivia = WhiteSpace Text | LineComment Text | BlockComment Text
<span class="lineno">  111 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span> , <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>data ETok = ETok
<span class="lineno">  114 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">offsets</span></span></span> :: Offsets
<span class="lineno">  115 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">trivia</span></span></span> :: [Trivia]
<span class="lineno">  116 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">lexeme</span></span></span> :: Lexeme
<span class="lineno">  117 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">capture</span></span></span> :: Text
<span class="lineno">  118 </span>    }
<span class="lineno">  119 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span> , <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>instance <span class="decl"><span class="nottickedoff">Pr.Pretty ETok</span></span> where
<span class="lineno">  122 </span>    <span class="decl"><span class="nottickedoff">pretty = Pr.unAnnotate . uncurry (Pr.&lt;&gt;) .  prettySplitComments</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>prettySplitComments :: ETok -&gt; (Pr.Doc ann, Pr.Doc ann)
<span class="lineno">  125 </span><span class="decl"><span class="nottickedoff">prettySplitComments (ETok _ tr _ capture) = (Pr.hcat [Pr.pretty t Pr.&lt;&gt; Pr.hardline | LineComment t &lt;- tr],Pr.pretty capture)</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>totalLength :: ETok -&gt; Int
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">totalLength = oTotalLength . offsets</span></span>
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>trueLength :: ETok -&gt; Int
<span class="lineno">  132 </span><span class="decl"><span class="istickedoff">trueLength = oTokenLength . offsets</span></span>
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- tokenStart :: ETok -&gt; Int
<span class="lineno">  135 </span>-- tokenStart (ETok{offsets = (Offsets _  s _ _ _)}) = s
<span class="lineno">  136 </span>tokenOffset :: ETok -&gt; Int
<span class="lineno">  137 </span><span class="decl"><span class="nottickedoff">tokenOffset = oStart . offsets</span></span>
<span class="lineno">  138 </span>tokenStartOffset :: ETok -&gt; Int
<span class="lineno">  139 </span><span class="decl"><span class="istickedoff">tokenStartOffset t = oStart o + (oTotalLength o - oTokenLength o)</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="istickedoff">where o = offsets t</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>trueStart :: ETok -&gt; SourcePos
<span class="lineno">  143 </span><span class="decl"><span class="nottickedoff">trueStart = oTrueStart . offsets</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>tokenSourcePos :: ETok -&gt; SourcePos
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">tokenSourcePos = oSourcePos . offsets</span></span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>sourcePosAfter :: ETok -&gt; SourcePos
<span class="lineno">  149 </span><span class="decl"><span class="istickedoff">sourcePosAfter = oEndPos . offsets</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>makeToken :: Offsets -&gt; [Trivia] -&gt; Lexeme -&gt; Text -&gt; ETok
<span class="lineno">  152 </span><span class="decl"><span class="istickedoff">makeToken = ETok</span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>--make an empty token that precedes the given token with the given lexeme
<span class="lineno">  155 </span>nullBefore :: Lexeme -&gt; ETok -&gt; ETok
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">nullBefore lex tok = ETok offs <span class="nottickedoff">[]</span> lex <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  158 </span><span class="spaces">        </span><span class="istickedoff">sp = tokenSourcePos tok</span>
<span class="lineno">  159 </span><span class="spaces">        </span><span class="istickedoff">offs =  Offsets (tokenStartOffset tok) 0 0 <span class="nottickedoff">sp</span> sp <span class="nottickedoff">sp</span></span></span>
<span class="lineno">  160 </span>newtype LexerError = LexerError String
<span class="lineno">  161 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>runLexer :: Text -&gt; Maybe FilePath -&gt; Either LexerError ETokenStream
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">runLexer txt fp = case runParser eLex (fromMaybe <span class="nottickedoff">&quot;Lexer&quot;</span> fp) txt of</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">Left peb -&gt; <span class="nottickedoff">Left $ LexerError $ errorBundlePretty peb</span></span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">Right ets -&gt; Right $ ETokenStream <span class="nottickedoff">txt</span> ets</span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>eLex :: Lexer [ETok]
<span class="lineno">  170 </span><span class="decl"><span class="istickedoff">eLex =</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">main &lt;- many $ try aToken</span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="istickedoff">end &lt;- pEOF</span>
<span class="lineno">  174 </span><span class="spaces">        </span><span class="istickedoff">return $ main ++ [end]</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>aToken :: Lexer ETok
<span class="lineno">  177 </span><span class="decl"><span class="istickedoff">aToken = do</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="istickedoff">start &lt;- getOffset</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">startPos &lt;- getSourcePos</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">whitespace &lt;- pTrivia</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">tokenOffset_ &lt;- getOffset</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">tokenStart &lt;- getSourcePos</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="istickedoff">(tok,cap) &lt;- aLexeme</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="istickedoff">tokenEnd &lt;- getOffset</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">endPos &lt;- getSourcePos</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">return $ makeToken (Offsets start (tokenEnd - start) (tokenEnd - tokenOffset_) <span class="nottickedoff">startPos</span> tokenStart endPos) whitespace tok cap</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>pEOF :: Lexer ETok
<span class="lineno">  189 </span><span class="decl"><span class="istickedoff">pEOF = do</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff">start &lt;- getOffset</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="istickedoff">startPos &lt;- getSourcePos</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">whitespace &lt;- pTrivia</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">wse &lt;- getOffset</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">tokenStart &lt;- getSourcePos</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">eof</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">tokenEnd &lt;- getOffset</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">endPos &lt;- getSourcePos</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">return $ makeToken (Offsets start (tokenEnd - start) (tokenEnd - wse) <span class="nottickedoff">startPos</span> tokenStart <span class="nottickedoff">endPos</span>) whitespace L_EOF &quot;&quot;</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>aLexeme :: Lexer (Lexeme,Text)
<span class="lineno">  202 </span><span class="decl"><span class="istickedoff">aLexeme = aLexemeStrict &lt;|&gt; pFallback</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>aLexemeStrict :: Lexer (Lexeme,Text)
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">aLexemeStrict =</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">try</span>
<span class="lineno">  207 </span><span class="spaces">        </span><span class="istickedoff">pNumber</span>
<span class="lineno">  208 </span><span class="spaces">        </span><span class="istickedoff">&lt;|&gt; try  (choice (map pLexeme lexemes) &lt;?&gt; &quot;Lexeme&quot;)</span>
<span class="lineno">  209 </span><span class="spaces">        </span><span class="istickedoff">&lt;|&gt; try pIdentifier</span>
<span class="lineno">  210 </span><span class="spaces">        </span><span class="istickedoff">&lt;|&gt; try pQuotedIdentifier</span>
<span class="lineno">  211 </span><span class="spaces">        </span><span class="istickedoff">&lt;|&gt; try pMetaVar</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>pNumber :: Lexer (Lexeme,Text)
<span class="lineno">  215 </span><span class="decl"><span class="istickedoff">pNumber = do</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">v &lt;- takeWhile1P <span class="nottickedoff">Nothing</span> (`elem` ['1','2','3','4','5','6','7','8','9','0'])</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">let n = read $ T.unpack v</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">return (LIntLiteral n,v)</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">&lt;?&gt; &quot;Numeric Literal&quot;</span></span>
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>pMetaVar :: Lexer (Lexeme,Text)
<span class="lineno">  222 </span><span class="decl"><span class="istickedoff">pMetaVar = do</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">amp &lt;- chunk &quot;&amp;&quot;</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">(_,cap) &lt;- pIdentifier</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">return (LMetaVar <span class="nottickedoff">cap</span>,amp `T.append` cap)</span></span>
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>pIdentifier :: Lexer (Lexeme,Text)
<span class="lineno">  228 </span><span class="decl"><span class="istickedoff">pIdentifier = do</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">firstLetter &lt;- takeWhile1P <span class="nottickedoff">Nothing</span> isIdentifierFirstLetter</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">rest &lt;- takeWhileP <span class="nottickedoff">Nothing</span> isIdentifierLetter</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">let ident = T.append firstLetter rest</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">-- traceM $ T.unpack . T.pack $ map chr $ map ord $ T.unpack ident</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="istickedoff">return ( LIdentifier ident, ident)</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">&lt;?&gt; &quot;Identifier&quot;</span></span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>pQuotedIdentifier :: Lexer (Lexeme,Text)
<span class="lineno">  237 </span><span class="decl"><span class="istickedoff">pQuotedIdentifier = do</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">l &lt;- quoted</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">return (LIdentifier l,l)</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>pFallback :: Lexer (Lexeme,Text)
<span class="lineno">  242 </span><span class="decl"><span class="istickedoff">pFallback = do</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- T.pack &lt;$&gt; someTill anySingle (lookAhead $ try somethingValid)</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">return (LUnexpected  <span class="nottickedoff">q</span>,q)</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff">somethingValid :: Lexer ()</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">somethingValid = void pTrivia &lt;|&gt; <span class="nottickedoff">void aLexemeStrict</span> &lt;|&gt; <span class="nottickedoff">eof</span></span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>pLexeme :: (Text, Lexeme) -&gt; Lexer (Lexeme,Text)
<span class="lineno">  250 </span><span class="decl"><span class="istickedoff">pLexeme (s, l) = do</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">tok &lt;- string s</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">notFollowedBy $ if isIdentifierLetter $ T.last tok then nonIden else empty</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">return (l,tok)</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">&lt;?&gt; &quot;Lexeme :&quot; ++ <span class="nottickedoff">show l</span></span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  256 </span><span class="spaces">        </span><span class="istickedoff">nonIden = takeWhile1P <span class="nottickedoff">Nothing</span> isIdentifierLetter</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>pTrivia :: Lexer [Trivia]
<span class="lineno">  259 </span><span class="decl"><span class="istickedoff">pTrivia = many (whiteSpace &lt;|&gt; lineComment &lt;|&gt; blockComment)</span></span>
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>whiteSpace :: Lexer Trivia
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">whiteSpace = do</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">s &lt;- some spaceChar</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">return $ WhiteSpace $ T.pack s</span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>quoted :: Lexer Text
<span class="lineno">  267 </span><span class="decl"><span class="istickedoff">quoted = do</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">open &lt;- char '\&quot;'</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">(body,end) &lt;- manyTill_ anySingle $ char '\&quot;'</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff">return $ T.pack  $ open:body++[end]</span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>lineEnd :: Lexer [Char]
<span class="lineno">  273 </span><span class="decl"><span class="istickedoff">lineEnd = <span class="nottickedoff">T.unpack</span> &lt;$&gt; eol &lt;|&gt; ( eof &gt;&gt; return [])</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>lineComment :: Lexer Trivia
<span class="lineno">  276 </span><span class="decl"><span class="istickedoff">lineComment = do</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- try (chunk &quot;$&quot;)</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">(text,end) &lt;- manyTill_ anySingle lineEnd</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">return $ LineComment $ T.pack ('$' : text++end)</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>blockComment :: Lexer Trivia
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">blockComment = do</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- try (chunk &quot;/*&quot;)</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">text &lt;- manyTill L.anySingle (lookAhead (void(chunk &quot;*/&quot;) &lt;|&gt;eof))</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">cl &lt;- optional $ chunk &quot;*/&quot;</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">let cl' = fromMaybe &quot;&quot; cl</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">return $ BlockComment $ T.concat [&quot;/*&quot;,T.pack text ,cl' ]</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>data ETokenStream = ETokenStream
<span class="lineno">  291 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">streamSourceText</span></span></span> :: Text
<span class="lineno">  292 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">streamTokens</span></span></span> :: [ETok]
<span class="lineno">  293 </span>    }
<span class="lineno">  294 </span>instance Stream ETokenStream where
<span class="lineno">  295 </span>    type Token ETokenStream = ETok
<span class="lineno">  296 </span>    type Tokens ETokenStream = [ETok]
<span class="lineno">  297 </span>    <span class="decl"><span class="nottickedoff">tokenToChunk _ x = [x]</span></span>
<span class="lineno">  298 </span>    <span class="decl"><span class="nottickedoff">tokensToChunk _ xs = xs</span></span>
<span class="lineno">  299 </span>    <span class="decl"><span class="nottickedoff">chunkToTokens _ = id</span></span>
<span class="lineno">  300 </span>    <span class="decl"><span class="nottickedoff">chunkLength _ = length</span></span>
<span class="lineno">  301 </span>    <span class="decl"><span class="nottickedoff">chunkEmpty _ [] = True</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="nottickedoff">chunkEmpty _ _ = False</span></span>
<span class="lineno">  303 </span>    take1_ :: ETokenStream -&gt; Maybe (Token ETokenStream, ETokenStream)
<span class="lineno">  304 </span>    <span class="decl"><span class="istickedoff">take1_ (ETokenStream _ (x : xs)) = Just (x, buildStream xs)</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">take1_ (ETokenStream _ []) = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  306 </span>    takeN_ :: Int -&gt; ETokenStream -&gt; Maybe (Tokens ETokenStream, ETokenStream)
<span class="lineno">  307 </span>    <span class="decl"><span class="nottickedoff">takeN_ n xs | n &lt;= 0 = Just ([], xs)</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="nottickedoff">takeN_ _ (ETokenStream _ []) = Nothing</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="nottickedoff">takeN_ n (ETokenStream _ xs) = Just (take n xs, buildStream $ drop n xs)</span></span>
<span class="lineno">  310 </span>    takeWhile_ :: (Token ETokenStream -&gt; Bool) -&gt; ETokenStream -&gt; (Tokens ETokenStream, ETokenStream)
<span class="lineno">  311 </span>    <span class="decl"><span class="nottickedoff">takeWhile_ p (ETokenStream _ xs) =</span>
<span class="lineno">  312 </span><span class="spaces">        </span><span class="nottickedoff">(a, buildStream b)</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="nottickedoff">(a, b) = span p xs</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>-- (takeWhile p xs,ETokenStream $ dropWhile p xs)
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>buildStream :: [ETok] -&gt; ETokenStream
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">buildStream xs = case NE.nonEmpty xs of</span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">ETokenStream &quot;&quot; xs</span></span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">Just _ -&gt; ETokenStream <span class="nottickedoff">(T.pack &quot;showTokens pxy s&quot;)</span> xs</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>instance VisualStream ETokenStream where
<span class="lineno">  324 </span>    <span class="decl"><span class="nottickedoff">showTokens _ =  L.unpack . reformList</span></span>
<span class="lineno">  325 </span>    <span class="decl"><span class="nottickedoff">tokensLength _ = sum . fmap trueLength</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- https://markkarpov.com/tutorial/megaparsec.html#working-with-custom-input-streams
<span class="lineno">  328 </span>instance <span class="decl"><span class="nottickedoff">TraversableStream ETokenStream</span></span> where
<span class="lineno">  329 </span>    <span class="decl"><span class="nottickedoff">reachOffset o PosState{..} =</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="nottickedoff">( Just (prefix ++ restOfLine)</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="nottickedoff">, PosState</span>
<span class="lineno">  332 </span><span class="spaces">            </span><span class="nottickedoff">{ pstateInput = buildStream post</span>
<span class="lineno">  333 </span><span class="spaces">            </span><span class="nottickedoff">, pstateOffset = max pstateOffset o</span>
<span class="lineno">  334 </span><span class="spaces">            </span><span class="nottickedoff">, pstateSourcePos = newSourcePos</span>
<span class="lineno">  335 </span><span class="spaces">            </span><span class="nottickedoff">, pstateTabWidth = pstateTabWidth</span>
<span class="lineno">  336 </span><span class="spaces">            </span><span class="nottickedoff">, pstateLinePrefix = prefix</span>
<span class="lineno">  337 </span><span class="spaces">            </span><span class="nottickedoff">}</span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="nottickedoff">)</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="nottickedoff">where</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="nottickedoff">prefix =</span>
<span class="lineno">  341 </span><span class="spaces">            </span><span class="nottickedoff">if sameLine</span>
<span class="lineno">  342 </span><span class="spaces">                </span><span class="nottickedoff">then pstateLinePrefix ++ preLine</span>
<span class="lineno">  343 </span><span class="spaces">                </span><span class="nottickedoff">else preLine</span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="nottickedoff">sameLine = sourceLine newSourcePos == sourceLine pstateSourcePos</span>
<span class="lineno">  345 </span><span class="spaces">        </span><span class="nottickedoff">newSourcePos =</span>
<span class="lineno">  346 </span><span class="spaces">            </span><span class="nottickedoff">case post of</span>
<span class="lineno">  347 </span><span class="spaces">                </span><span class="nottickedoff">[] -&gt; pstateSourcePos</span>
<span class="lineno">  348 </span><span class="spaces">                </span><span class="nottickedoff">(x : _) -&gt; tokenSourcePos x</span>
<span class="lineno">  349 </span><span class="spaces">        </span><span class="nottickedoff">(pre, post) :: ([ETok], [ETok]) = splitAt (o - pstateOffset) (streamTokens pstateInput)</span>
<span class="lineno">  350 </span><span class="spaces">        </span><span class="nottickedoff">(preStr, postStr) = (maybe &quot;&quot; (showTokens pxy) (NE.nonEmpty pre), maybe &quot;&quot; (showTokens pxy) (NE.nonEmpty post))</span>
<span class="lineno">  351 </span><span class="spaces">        </span><span class="nottickedoff">preLine = reverse . takeWhile (/= '\n') . reverse $ preStr</span>
<span class="lineno">  352 </span><span class="spaces">        </span><span class="nottickedoff">restOfLine = takeWhile (/= '\n') postStr</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>pxy :: Proxy ETokenStream
<span class="lineno">  355 </span><span class="decl"><span class="nottickedoff">pxy = Proxy</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>-- instance Show ETok where
<span class="lineno">  360 </span>--     show (ETok _ _ _ q) = show q
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>-- instance TraversableStream ETokenStream where
<span class="lineno">  365 </span>--     reachOffset i s = (Nothing, s)
<span class="lineno">  366 </span>--     reachOffsetNoLine i s = s 

</pre>
</body>
</html>
