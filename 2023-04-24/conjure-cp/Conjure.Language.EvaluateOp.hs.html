<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Conjure.Language.EvaluateOp ( EvaluateOp(..) ) where
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>import Conjure.Prelude
<span class="lineno">    4 </span>import Conjure.Bug
<span class="lineno">    5 </span>import Conjure.Language
<span class="lineno">    6 </span>import Conjure.Process.Enumerate ( EnumerateDomain )
<span class="lineno">    7 </span>import Conjure.Compute.DomainOf ( domainOf )
<span class="lineno">    8 </span>import Conjure.Language.DomainSizeOf ( domainSizeOf )
<span class="lineno">    9 </span>import Conjure.Process.AttributeAsConstraints ( mkAttributeToConstraint )
<span class="lineno">   10 </span>import {-# SOURCE #-} Conjure.Language.Instantiate ( instantiateExpression )    
<span class="lineno">   11 </span>import {-# SOURCE #-} Conjure.Process.ValidateConstantForDomain ( validateConstantForDomain )
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>-- | Assume: the input is already normalised.
<span class="lineno">   15 </span>--   Make sure the output is normalised.
<span class="lineno">   16 </span>class EvaluateOp op where
<span class="lineno">   17 </span>    evaluateOp :: 
<span class="lineno">   18 </span>        MonadFailDoc m =&gt;
<span class="lineno">   19 </span>        NameGen m =&gt;
<span class="lineno">   20 </span>        EnumerateDomain m =&gt;
<span class="lineno">   21 </span>        (?typeCheckerMode :: TypeCheckerMode) =&gt;
<span class="lineno">   22 </span>        op Constant -&gt; m Constant
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>instance EvaluateOp OpActive where
<span class="lineno">   25 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpActive (viewConstantVariant -&gt; Just (_, n1, _)) n2) = return $ fromBool $ n1 == n2</span>
<span class="lineno">   26 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpActive}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>instance EvaluateOp OpAllDiff where
<span class="lineno">   29 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAllDiff (viewConstantMatrix -&gt; Just (_, vals))) =</span>
<span class="lineno">   30 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ length vals == length (sortNub vals)</span>
<span class="lineno">   31 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpAllDiff}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>instance EvaluateOp OpAllDiffExcept where
<span class="lineno">   34 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAllDiffExcept (viewConstantMatrix -&gt; Just (_, vals)) i@(viewConstantInt -&gt; Just n)) = do</span>
<span class="lineno">   35 </span><span class="spaces">        </span><span class="istickedoff">TypeInt t &lt;- typeOf i</span>
<span class="lineno">   36 </span><span class="spaces">        </span><span class="istickedoff">let vals' = filter (ConstantInt <span class="nottickedoff">t</span> n/=) vals</span>
<span class="lineno">   37 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ length vals' == length (sortNub vals')</span>
<span class="lineno">   38 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpAllDiffExcept}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>instance EvaluateOp OpAnd where
<span class="lineno">   41 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAnd x) = ConstantBool . and &lt;$&gt; boolsOut x</span></span>
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>instance EvaluateOp OpApart where
<span class="lineno">   44 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpApart _ ConstantUndefined{}) = return (fromBool False)</span>
<span class="lineno">   45 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpApart (viewConstantSet -&gt; Just ys) (viewConstantPartition -&gt; Just xss)) =</span>
<span class="lineno">   46 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ and</span>
<span class="lineno">   47 </span><span class="spaces">                    </span><span class="istickedoff">[ -- the items in `ys` do not appear together in the partition</span>
<span class="lineno">   48 </span><span class="spaces">                      </span><span class="istickedoff">not $ or [ and [ y `elem` xs | y &lt;- ys ]</span>
<span class="lineno">   49 </span><span class="spaces">                               </span><span class="istickedoff">| xs &lt;- xss</span>
<span class="lineno">   50 </span><span class="spaces">                               </span><span class="istickedoff">]</span>
<span class="lineno">   51 </span><span class="spaces">                      </span><span class="istickedoff">-- the items in `ys` appear somewhere in the partition</span>
<span class="lineno">   52 </span><span class="spaces">                    </span><span class="istickedoff">, and [ y `elem` concat xss | y &lt;- ys ]</span>
<span class="lineno">   53 </span><span class="spaces">                    </span><span class="istickedoff">]</span>
<span class="lineno">   54 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpApart}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>instance EvaluateOp OpAttributeAsConstraint where
<span class="lineno">   57 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAttributeAsConstraint x attrName attrVal) = do</span>
<span class="lineno">   58 </span><span class="spaces">        </span><span class="istickedoff">dom &lt;- domainOf x</span>
<span class="lineno">   59 </span><span class="spaces">        </span><span class="istickedoff">constraint &lt;- mkAttributeToConstraint dom attrName (fmap Constant attrVal) (Constant x)</span>
<span class="lineno">   60 </span><span class="spaces">        </span><span class="istickedoff">evaluated &lt;- instantiateExpression <span class="nottickedoff">[]</span> constraint</span>
<span class="lineno">   61 </span><span class="spaces">        </span><span class="istickedoff">return evaluated</span></span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>instance EvaluateOp OpCatchUndef where
<span class="lineno">   64 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpCatchUndef ConstantUndefined{} d) = <span class="nottickedoff">return d</span></span>
<span class="lineno">   65 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpCatchUndef x _) = return x</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>instance EvaluateOp OpDefined where
<span class="lineno">   68 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | any isUndef (childrenBi p) = do</span>
<span class="lineno">   69 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- typeOf p</span>
<span class="lineno">   70 </span><span class="spaces">        </span><span class="istickedoff">return $ mkUndef ty $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpDefined (viewConstantFunction -&gt; Just xs)) =</span>
<span class="lineno">   72 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub $ map fst xs</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = na $ &quot;evaluateOp{OpDefined}:&quot; &lt;++&gt; <span class="nottickedoff">pretty (show op)</span></span></span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>instance EvaluateOp OpDiv where
<span class="lineno">   76 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | any isUndef (childrenBi p) =</span>
<span class="lineno">   77 </span><span class="spaces">        </span><span class="istickedoff">return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpDiv x y)</span>
<span class="lineno">   79 </span><span class="spaces">        </span><span class="istickedoff">| y /= 0    = ConstantInt TagInt &lt;$&gt; (div &lt;$&gt; intOut <span class="nottickedoff">&quot;div x&quot;</span> x &lt;*&gt; intOut <span class="nottickedoff">&quot;div y&quot;</span> y)</span>
<span class="lineno">   80 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return $ mkUndef (TypeInt TagInt) $ <span class="nottickedoff">&quot;division by zero:&quot; &lt;+&gt; pretty p</span></span></span>
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>instance EvaluateOp OpDontCare where
<span class="lineno">   83 </span>    <span class="decl"><span class="istickedoff">evaluateOp op = na $ &quot;evaluateOp{OpDontcare}:&quot; &lt;++&gt; <span class="nottickedoff">pretty (show op)</span></span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>instance EvaluateOp OpDotLeq where
<span class="lineno">   86 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpDotLeq x y) = return $ ConstantBool $ x &lt;= y</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>instance EvaluateOp OpDotLt where
<span class="lineno">   89 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpDotLt x y) = return $ ConstantBool $ x &lt; y</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>instance EvaluateOp OpEq where
<span class="lineno">   92 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpEq ConstantUndefined{} _) = return $ fromBool False</span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpEq _ ConstantUndefined{}) = return $ fromBool False</span>
<span class="lineno">   94 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpEq (TypedConstant x _) y) = evaluateOp (OpEq x y)</span>
<span class="lineno">   95 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpEq x (TypedConstant y _)) = evaluateOp (OpEq x y)</span>
<span class="lineno">   96 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpEq x y) = return $ ConstantBool $ x == y</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>instance EvaluateOp OpFactorial where
<span class="lineno">   99 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  100 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  101 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpFactorial x) = ConstantInt TagInt . product . enumFromTo 1 &lt;$&gt; intOut <span class="nottickedoff">&quot;factorial&quot;</span> x</span></span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>instance EvaluateOp OpFlatten where
<span class="lineno">  104 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpFlatten Nothing m) = do</span>
<span class="lineno">  105 </span><span class="spaces">        </span><span class="istickedoff">let flat (viewConstantMatrix -&gt; Just (_, xs)) = concatMap flat xs</span>
<span class="lineno">  106 </span><span class="spaces">            </span><span class="istickedoff">flat c = [c]</span>
<span class="lineno">  107 </span><span class="spaces">        </span><span class="istickedoff">let flattened = flat m</span>
<span class="lineno">  108 </span><span class="spaces">        </span><span class="istickedoff">return (ConstantAbstract $ AbsLitMatrix</span>
<span class="lineno">  109 </span><span class="spaces">                    </span><span class="istickedoff">(DomainInt TagInt [RangeBounded 1 (fromInt (genericLength flattened))])</span>
<span class="lineno">  110 </span><span class="spaces">                    </span><span class="istickedoff">flattened)</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpFlatten (Just n) m) = do</span>
<span class="lineno">  112 </span><span class="spaces">        </span><span class="istickedoff">let flat lvl c | lvl &lt; 0 = return [c]</span>
<span class="lineno">  113 </span><span class="spaces">            </span><span class="istickedoff">flat lvl (viewConstantMatrix -&gt; Just (_, xs)) = concatMapM (flat (lvl-1)) xs</span>
<span class="lineno">  114 </span><span class="spaces">            </span><span class="istickedoff">flat _ _ = <span class="nottickedoff">failDoc $ &quot;Cannot flatten&quot; &lt;+&gt; pretty n &lt;+&gt; &quot;levels.&quot;</span></span>
<span class="lineno">  115 </span><span class="spaces">        </span><span class="istickedoff">flattened &lt;- flat n m</span>
<span class="lineno">  116 </span><span class="spaces">        </span><span class="istickedoff">return (ConstantAbstract $ AbsLitMatrix</span>
<span class="lineno">  117 </span><span class="spaces">                    </span><span class="istickedoff">(DomainInt TagInt [RangeBounded 1 (fromInt (genericLength flattened))])</span>
<span class="lineno">  118 </span><span class="spaces">                    </span><span class="istickedoff">flattened)</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>instance EvaluateOp OpFreq where
<span class="lineno">  121 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpFreq (viewConstantMSet -&gt; Just cs) c) = return $ (ConstantInt TagInt) $ sum [ <span class="nottickedoff">1</span> | i &lt;- cs, <span class="tickonlyfalse">c == i</span> ]</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpFreq (viewConstantMatrix -&gt; Just (_, cs)) c) = return $ (ConstantInt <span class="nottickedoff">TagInt</span>) $ sum [ 1 | i &lt;- cs, c == i ]</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpFreq}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>instance EvaluateOp OpGeq where
<span class="lineno">  126 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpGeq x y) = return $ ConstantBool $ x &gt;= y</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>instance EvaluateOp OpGt where
<span class="lineno">  129 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpGt x y) = return $ ConstantBool $ x &gt; y</span></span>
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>instance EvaluateOp OpHist where
<span class="lineno">  132 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpHist (viewConstantMSet -&gt; Just cs)) = <span class="nottickedoff">return $ ConstantAbstract $ AbsLitMatrix</span></span>
<span class="lineno">  133 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(DomainInt TagInt [RangeBounded 1 (fromInt $ genericLength $ histogram cs)])</span></span>
<span class="lineno">  134 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ ConstantAbstract $ AbsLitTuple [e, ConstantInt TagInt n] | (e, n) &lt;- histogram cs ]</span></span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpHist (viewConstantMatrix -&gt; Just (_, cs))) = return $ ConstantAbstract $ AbsLitMatrix</span>
<span class="lineno">  136 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(DomainInt TagInt [RangeBounded 1 (fromInt $ genericLength $ histogram cs)])</span></span>
<span class="lineno">  137 </span><span class="spaces">        </span><span class="istickedoff">[ ConstantAbstract $ AbsLitTuple [e, ConstantInt <span class="nottickedoff">TagInt</span> n] | (e, n) &lt;- histogram cs ]</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpHist}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>instance EvaluateOp OpIff where
<span class="lineno">  141 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpIff (ConstantBool x) (ConstantBool y)) = return $ ConstantBool $ x == y</span>
<span class="lineno">  142 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp _ = <span class="nottickedoff">na &quot;evaluateOp{OpIff}&quot;</span></span></span>
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>instance EvaluateOp OpImage where
<span class="lineno">  145 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpImage f@(viewConstantFunction -&gt; Just xs) a) =</span>
<span class="lineno">  146 </span><span class="spaces">        </span><span class="istickedoff">case [ y | (x,y) &lt;- xs, a == x ] of</span>
<span class="lineno">  147 </span><span class="spaces">            </span><span class="istickedoff">[y] -&gt; return y</span>
<span class="lineno">  148 </span><span class="spaces">            </span><span class="istickedoff">[]  -&gt; do</span>
<span class="lineno">  149 </span><span class="spaces">                </span><span class="istickedoff">TypeFunction _ tyTo &lt;- typeOf f</span>
<span class="lineno">  150 </span><span class="spaces">                </span><span class="istickedoff">return $ mkUndef tyTo $ <span class="nottickedoff">vcat</span></span>
<span class="lineno">  151 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Function is not defined at this point:&quot; &lt;+&gt; pretty a</span></span>
<span class="lineno">  152 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Function value:&quot; &lt;+&gt; pretty f</span></span>
<span class="lineno">  153 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  154 </span><span class="spaces">            </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  155 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeFunction _ tyTo &lt;- typeOf f</span></span>
<span class="lineno">  156 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyTo $ vcat</span></span>
<span class="lineno">  157 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Function is multiply defined at this point:&quot; &lt;+&gt; pretty a</span></span>
<span class="lineno">  158 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Function value:&quot; &lt;+&gt; pretty f</span></span>
<span class="lineno">  159 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpImage f@(viewConstantSequence -&gt; Just xs) a) =</span>
<span class="lineno">  161 </span><span class="spaces">        </span><span class="istickedoff">case [ y | (x,y) &lt;- zip allNats xs, a == fromInt x ] of</span>
<span class="lineno">  162 </span><span class="spaces">            </span><span class="istickedoff">[y] -&gt; return y</span>
<span class="lineno">  163 </span><span class="spaces">            </span><span class="istickedoff">[]  -&gt; do</span>
<span class="lineno">  164 </span><span class="spaces">                </span><span class="istickedoff">TypeSequence tyTo &lt;- typeOf f</span>
<span class="lineno">  165 </span><span class="spaces">                </span><span class="istickedoff">return $ mkUndef tyTo $ <span class="nottickedoff">vcat</span></span>
<span class="lineno">  166 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Sequence is not defined at this point:&quot; &lt;+&gt; pretty a</span></span>
<span class="lineno">  167 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Sequence value:&quot; &lt;+&gt; pretty f</span></span>
<span class="lineno">  168 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  169 </span><span class="spaces">            </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  170 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeSequence tyTo &lt;- typeOf f</span></span>
<span class="lineno">  171 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyTo $ vcat</span></span>
<span class="lineno">  172 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Sequence is multiply defined at this point:&quot; &lt;+&gt; pretty a</span></span>
<span class="lineno">  173 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Sequence value:&quot; &lt;+&gt; pretty f</span></span>
<span class="lineno">  174 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpImage}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>instance EvaluateOp OpImageSet where
<span class="lineno">  178 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpImageSet f@(viewConstantFunction -&gt; Just xs) a) = do</span>
<span class="lineno">  179 </span><span class="spaces">        </span><span class="nottickedoff">TypeFunction _ tyTo &lt;- typeOf f</span>
<span class="lineno">  180 </span><span class="spaces">        </span><span class="nottickedoff">case [ y | (x,y) &lt;- xs, a == x ] of</span>
<span class="lineno">  181 </span><span class="spaces">            </span><span class="nottickedoff">[y] -&gt; return $ ConstantAbstract $ AbsLitSet [y]</span>
<span class="lineno">  182 </span><span class="spaces">            </span><span class="nottickedoff">_   -&gt; return $ TypedConstant (ConstantAbstract $ AbsLitSet []) (TypeSet tyTo)</span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpImageSet f@(viewConstantSequence -&gt; Just xs) a) = do</span>
<span class="lineno">  184 </span><span class="spaces">        </span><span class="nottickedoff">TypeSequence tyTo &lt;- typeOf f</span>
<span class="lineno">  185 </span><span class="spaces">        </span><span class="nottickedoff">case [ y | (x,y) &lt;- zip allNats xs, a == fromInt x ] of</span>
<span class="lineno">  186 </span><span class="spaces">            </span><span class="nottickedoff">[y] -&gt; return $ ConstantAbstract $ AbsLitSet [y]</span>
<span class="lineno">  187 </span><span class="spaces">            </span><span class="nottickedoff">_   -&gt; return $ TypedConstant (ConstantAbstract $ AbsLitSet []) (TypeSet tyTo)</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpImageSet}:&quot; &lt;++&gt; pretty (show op)</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>instance EvaluateOp OpImply where
<span class="lineno">  191 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpImply x y) = ConstantBool &lt;$&gt; ((&lt;=) &lt;$&gt; boolOut x &lt;*&gt; boolOut y)</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>instance EvaluateOp OpIn where
<span class="lineno">  194 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpIn c (viewConstantSet      -&gt; Just cs)) = return $ ConstantBool $ elem c cs</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpIn c (viewConstantMSet     -&gt; Just cs)) = return $ ConstantBool $ elem c cs</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpIn c (viewConstantFunction -&gt; Just cs)) =</span>
<span class="lineno">  197 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantBool $ elem c $ map (\ (i,j) -&gt; ConstantAbstract $ AbsLitTuple [i,j] ) cs</span></span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpIn c (viewConstantRelation -&gt; Just cs)) =</span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantBool $ elem c $ map (ConstantAbstract . AbsLitTuple) cs</span></span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpIn}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>instance EvaluateOp OpIndexing where
<span class="lineno">  203 </span>    <span class="decl"><span class="istickedoff">evaluateOp p@(OpIndexing m i) | isUndef i = do</span>
<span class="lineno">  204 </span><span class="spaces">        </span><span class="istickedoff">ty   &lt;- typeOf m</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="istickedoff">tyTo &lt;- case ty of TypeMatrix _ tyTo -&gt; return tyTo</span>
<span class="lineno">  206 </span><span class="spaces">                           </span><span class="istickedoff">TypeList tyTo     -&gt; <span class="nottickedoff">return tyTo</span></span>
<span class="lineno">  207 </span><span class="spaces">                           </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failDoc &quot;evaluateOp{OpIndexing}&quot;</span></span>
<span class="lineno">  208 </span><span class="spaces">        </span><span class="istickedoff">return $ mkUndef tyTo $ <span class="nottickedoff">&quot;Has undefined children (index):&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpIndexing m@(viewConstantMatrix -&gt; Just (DomainInt _ index, vals)) (ConstantInt _ x)) = do</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">ty   &lt;- typeOf m</span>
<span class="lineno">  211 </span><span class="spaces">            </span><span class="istickedoff">tyTo &lt;- case ty of TypeMatrix _ tyTo -&gt; return tyTo</span>
<span class="lineno">  212 </span><span class="spaces">                               </span><span class="istickedoff">TypeList tyTo     -&gt; <span class="nottickedoff">return tyTo</span></span>
<span class="lineno">  213 </span><span class="spaces">                               </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug &quot;evaluateOp{OpIndexing}&quot;</span></span>
<span class="lineno">  214 </span><span class="spaces">            </span><span class="istickedoff">indexVals &lt;- valuesInIntDomain index</span>
<span class="lineno">  215 </span><span class="spaces">            </span><span class="istickedoff">case [ v | (i, v) &lt;- zip indexVals vals, i == x ] of</span>
<span class="lineno">  216 </span><span class="spaces">                </span><span class="istickedoff">[v] -&gt; return v</span>
<span class="lineno">  217 </span><span class="spaces">                </span><span class="istickedoff">[]  -&gt; return $ mkUndef tyTo $ <span class="nottickedoff">vcat</span></span>
<span class="lineno">  218 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Matrix is not defined at this point:&quot; &lt;+&gt; pretty x</span></span>
<span class="lineno">  219 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">, &quot;Matrix value:&quot; &lt;+&gt; pretty m</span></span>
<span class="lineno">  220 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  221 </span><span class="spaces">                </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">return $ mkUndef tyTo $ vcat</span></span>
<span class="lineno">  222 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Matrix is multiply defined at this point:&quot; &lt;+&gt; pretty x</span></span>
<span class="lineno">  223 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">, &quot;Matrix value:&quot; &lt;+&gt; pretty m</span></span>
<span class="lineno">  224 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpIndexing (viewConstantTuple -&gt; Just vals) (ConstantInt _ x)) =</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">return (at vals (fromInteger (x-1)))</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp rec@(OpIndexing (viewConstantRecord -&gt; Just vals) (ConstantField name _)) =</span>
<span class="lineno">  228 </span><span class="spaces">        </span><span class="istickedoff">case lookup name vals of</span>
<span class="lineno">  229 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">failDoc $ vcat</span></span>
<span class="lineno">  230 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record doesn't have a member with this name:&quot; &lt;+&gt; pretty name</span></span>
<span class="lineno">  231 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Record:&quot; &lt;+&gt; pretty rec</span></span>
<span class="lineno">  232 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  233 </span><span class="spaces">            </span><span class="istickedoff">Just val -&gt; return val</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp var@(OpIndexing (viewConstantVariant -&gt; Just (_, name', x)) (ConstantField name ty)) =</span>
<span class="lineno">  235 </span><span class="spaces">        </span><span class="istickedoff">if name == name'</span>
<span class="lineno">  236 </span><span class="spaces">            </span><span class="istickedoff">then return x</span>
<span class="lineno">  237 </span><span class="spaces">            </span><span class="istickedoff">else return $ mkUndef ty $ <span class="nottickedoff">vcat</span></span>
<span class="lineno">  238 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Variant isn't set to a member with this name:&quot; &lt;+&gt; pretty name</span></span>
<span class="lineno">  239 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Variant:&quot; &lt;+&gt; pretty var</span></span>
<span class="lineno">  240 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = na $ &quot;evaluateOp{OpIndexing}:&quot; &lt;++&gt; <span class="nottickedoff">pretty (show op)</span></span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>instance EvaluateOp OpIntersect where
<span class="lineno">  244 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | any isUndef (childrenBi p) = do</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- typeOf p</span>
<span class="lineno">  246 </span><span class="spaces">        </span><span class="istickedoff">return $ mkUndef ty $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpIntersect (viewConstantSet -&gt; Just as) (viewConstantSet -&gt; Just bs)) = do</span>
<span class="lineno">  248 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- typeOf p</span>
<span class="lineno">  249 </span><span class="spaces">        </span><span class="istickedoff">let outs = sortNub [ i | i &lt;- as, i `elem` bs]</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">return $ TypedConstant (ConstantAbstract $ AbsLitSet outs) <span class="nottickedoff">ty</span></span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpIntersect (viewConstantMSet -&gt; Just as) (viewConstantMSet -&gt; Just bs)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty &lt;- typeOf p</span></span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let asHist = histogram as</span></span>
<span class="lineno">  254 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">bsHist = histogram bs</span></span>
<span class="lineno">  255 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">allElems = sortNub (as++bs)</span></span>
<span class="lineno">  256 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">outs =</span></span>
<span class="lineno">  257 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ replicate (fromInteger (min countA countB)) e</span></span>
<span class="lineno">  258 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">| e &lt;- allElems</span></span>
<span class="lineno">  259 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, let countA = fromMaybe 0 (e `lookup` asHist)</span></span>
<span class="lineno">  260 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, let countB = fromMaybe 0 (e `lookup` bsHist)</span></span>
<span class="lineno">  261 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  262 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ TypedConstant (ConstantAbstract $ AbsLitMSet $ concat outs) ty</span></span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpIntersect (viewConstantFunction -&gt; Just as) (viewConstantFunction -&gt; Just bs)) = do</span>
<span class="lineno">  264 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- typeOf p</span>
<span class="lineno">  265 </span><span class="spaces">        </span><span class="istickedoff">let outs = sortNub [ i | i &lt;- as, i `elem` bs]</span>
<span class="lineno">  266 </span><span class="spaces">        </span><span class="istickedoff">return $ TypedConstant (ConstantAbstract $ AbsLitFunction outs) ty</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpIntersect (viewConstantRelation -&gt; Just as) (viewConstantRelation -&gt; Just bs)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  268 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty &lt;- typeOf p</span></span>
<span class="lineno">  269 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let outs = sortNub [ i | i &lt;- as, i `elem` bs]</span></span>
<span class="lineno">  270 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ TypedConstant (ConstantAbstract $ AbsLitRelation outs) ty</span></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpIntersect}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>instance EvaluateOp OpInverse where
<span class="lineno">  274 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpInverse (viewConstantFunction -&gt; Just xs) (viewConstantFunction -&gt; Just ys)) =</span>
<span class="lineno">  275 </span><span class="spaces">        </span><span class="nottickedoff">return $ ConstantBool $ and $ concat [ [ (j,i) `elem` ys | (i,j) &lt;- xs ]</span>
<span class="lineno">  276 </span><span class="spaces">                                             </span><span class="nottickedoff">, [ (j,i) `elem` xs | (i,j) &lt;- ys ]</span>
<span class="lineno">  277 </span><span class="spaces">                                             </span><span class="nottickedoff">]</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpInverse}:&quot; &lt;++&gt; pretty (show op)</span></span>
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>instance EvaluateOp OpLeq where
<span class="lineno">  281 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpLeq x y) = return $ ConstantBool $ x &lt;= y</span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>instance EvaluateOp OpLexLeq where
<span class="lineno">  284 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpLexLeq (viewConstantMatrix -&gt; Just (_, xs)) (viewConstantMatrix -&gt; Just (_, ys))) =</span>
<span class="lineno">  285 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ xs &lt;= ys</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpLexLeq}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>instance EvaluateOp OpLexLt where
<span class="lineno">  289 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpLexLt (viewConstantMatrix -&gt; Just (_, xs)) (viewConstantMatrix -&gt; Just (_, ys))) =</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ xs &lt; ys</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpLexLt}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>instance EvaluateOp OpLt where
<span class="lineno">  294 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpLt x y) = return $ ConstantBool $ x &lt; y</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>instance EvaluateOp OpMakeTable where
<span class="lineno">  297 </span>    <span class="decl"><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpMakeTable}:&quot; &lt;++&gt; pretty (show op)</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>instance EvaluateOp OpMax where
<span class="lineno">  300 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  301 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpMax x)</span>
<span class="lineno">  303 </span><span class="spaces">        </span><span class="istickedoff">| Just xs &lt;- listOut x</span>
<span class="lineno">  304 </span><span class="spaces">        </span><span class="istickedoff">, <span class="tickonlyfalse">any isUndef xs</span> =</span>
<span class="lineno">  305 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMax (DomainInConstant DomainBool)) = <span class="nottickedoff">return (ConstantBool True)</span></span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMax (DomainInConstant (DomainInt t rs))) = do</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">is &lt;- rangesInts rs</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null is</span></span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">then <span class="nottickedoff">mkUndef (TypeInt TagInt) &quot;Empty collection in max&quot;</span></span>
<span class="lineno">  311 </span><span class="spaces">            </span><span class="istickedoff">else ConstantInt t (maximum is)</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMax coll@(viewConstantMatrix -&gt; Just (_, xs))) =</span>
<span class="lineno">  313 </span><span class="spaces">        </span><span class="istickedoff">case xs of</span>
<span class="lineno">  314 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; do</span>
<span class="lineno">  315 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span>
<span class="lineno">  316 </span><span class="spaces">                </span><span class="istickedoff">return $ mkUndef tyInner <span class="nottickedoff">&quot;Empty collection in max&quot;</span></span>
<span class="lineno">  317 </span><span class="spaces">            </span><span class="istickedoff">(x:_) -&gt; do</span>
<span class="lineno">  318 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf x</span>
<span class="lineno">  319 </span><span class="spaces">                </span><span class="istickedoff">case tyInner of</span>
<span class="lineno">  320 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt t -&gt; do</span>
<span class="lineno">  321 </span><span class="spaces">                        </span><span class="istickedoff">is &lt;- concatMapM (intsOut <span class="nottickedoff">&quot;OpMax 1&quot;</span>) xs</span>
<span class="lineno">  322 </span><span class="spaces">                        </span><span class="istickedoff">return $ ConstantInt t (maximum is)</span>
<span class="lineno">  323 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na &quot;evaluateOp{OpMax}&quot;</span></span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMax coll@(viewConstantSet -&gt; Just xs)) = do</span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff">case xs of</span>
<span class="lineno">  326 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  327 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span></span>
<span class="lineno">  328 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyInner &quot;Empty collection in max&quot;</span></span>
<span class="lineno">  329 </span><span class="spaces">            </span><span class="istickedoff">(x:_) -&gt; do</span>
<span class="lineno">  330 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf x</span>
<span class="lineno">  331 </span><span class="spaces">                </span><span class="istickedoff">case tyInner of</span>
<span class="lineno">  332 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt t -&gt; do</span>
<span class="lineno">  333 </span><span class="spaces">                        </span><span class="istickedoff">is &lt;- concatMapM (intsOut <span class="nottickedoff">&quot;OpMax 1&quot;</span>) xs</span>
<span class="lineno">  334 </span><span class="spaces">                        </span><span class="istickedoff">return $ ConstantInt <span class="nottickedoff">t</span> (maximum is)</span>
<span class="lineno">  335 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na &quot;evaluateOp{OpMax}&quot;</span></span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMax coll@(viewConstantMSet -&gt; Just xs)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  337 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case xs of</span></span>
<span class="lineno">  338 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[] -&gt; do</span></span>
<span class="lineno">  339 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span></span>
<span class="lineno">  340 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyInner &quot;Empty collection in max&quot;</span></span>
<span class="lineno">  341 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(x:_) -&gt; do</span></span>
<span class="lineno">  342 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf x</span></span>
<span class="lineno">  343 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">case tyInner of</span></span>
<span class="lineno">  344 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeInt t -&gt; do</span></span>
<span class="lineno">  345 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">is &lt;- concatMapM (intsOut &quot;OpMax 1&quot;) xs</span></span>
<span class="lineno">  346 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantInt t (maximum is)</span></span>
<span class="lineno">  347 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; na &quot;evaluateOp{OpMax}&quot;</span></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp _ = <span class="nottickedoff">na &quot;evaluateOp{OpMax}&quot;</span></span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>instance EvaluateOp OpMin where
<span class="lineno">  351 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpMin x)</span>
<span class="lineno">  354 </span><span class="spaces">        </span><span class="istickedoff">| Just xs &lt;- listOut x</span>
<span class="lineno">  355 </span><span class="spaces">        </span><span class="istickedoff">, any isUndef xs =</span>
<span class="lineno">  356 </span><span class="spaces">            </span><span class="istickedoff">return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMin (DomainInConstant DomainBool)) = <span class="nottickedoff">return (ConstantBool False)</span></span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMin (DomainInConstant (DomainInt t rs))) = do</span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="istickedoff">is &lt;- rangesInts rs</span>
<span class="lineno">  360 </span><span class="spaces">        </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null is</span></span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="istickedoff">then <span class="nottickedoff">mkUndef (TypeInt TagInt) &quot;Empty collection in min&quot;</span></span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="istickedoff">else ConstantInt t (minimum is)</span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMin coll@(viewConstantMatrix -&gt; Just (_, xs))) = do</span>
<span class="lineno">  364 </span><span class="spaces">        </span><span class="istickedoff">case xs of</span>
<span class="lineno">  365 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  366 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span></span>
<span class="lineno">  367 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyInner &quot;Empty collection in min&quot;</span></span>
<span class="lineno">  368 </span><span class="spaces">            </span><span class="istickedoff">(x:_) -&gt; do</span>
<span class="lineno">  369 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf x</span>
<span class="lineno">  370 </span><span class="spaces">                </span><span class="istickedoff">case tyInner of</span>
<span class="lineno">  371 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt t -&gt; do</span>
<span class="lineno">  372 </span><span class="spaces">                        </span><span class="istickedoff">is &lt;- concatMapM (intsOut <span class="nottickedoff">&quot;OpMin 1&quot;</span>) xs</span>
<span class="lineno">  373 </span><span class="spaces">                        </span><span class="istickedoff">return $ ConstantInt t (minimum is)</span>
<span class="lineno">  374 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na &quot;evaluateOp{OpMin}&quot;</span></span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMin coll@(viewConstantSet -&gt; Just xs)) = do</span>
<span class="lineno">  376 </span><span class="spaces">        </span><span class="istickedoff">case xs of</span>
<span class="lineno">  377 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  378 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span></span>
<span class="lineno">  379 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyInner &quot;Empty collection in min&quot;</span></span>
<span class="lineno">  380 </span><span class="spaces">            </span><span class="istickedoff">(x:_) -&gt; do</span>
<span class="lineno">  381 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf x</span>
<span class="lineno">  382 </span><span class="spaces">                </span><span class="istickedoff">case tyInner of</span>
<span class="lineno">  383 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt t -&gt; do</span>
<span class="lineno">  384 </span><span class="spaces">                        </span><span class="istickedoff">is &lt;- concatMapM (intsOut <span class="nottickedoff">&quot;OpMin 1&quot;</span>) xs</span>
<span class="lineno">  385 </span><span class="spaces">                        </span><span class="istickedoff">return $ ConstantInt <span class="nottickedoff">t</span> (minimum is)</span>
<span class="lineno">  386 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na &quot;evaluateOp{OpMin}&quot;</span></span>
<span class="lineno">  387 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMin coll@(viewConstantMSet -&gt; Just xs)) = do</span>
<span class="lineno">  388 </span><span class="spaces">        </span><span class="istickedoff">case xs of</span>
<span class="lineno">  389 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  390 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">tyInner &lt;- typeOf coll &gt;&gt;= innerTypeOf</span></span>
<span class="lineno">  391 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef tyInner &quot;Empty collection in min&quot;</span></span>
<span class="lineno">  392 </span><span class="spaces">            </span><span class="istickedoff">(x:_) -&gt; do</span>
<span class="lineno">  393 </span><span class="spaces">                </span><span class="istickedoff">tyInner &lt;- typeOf x</span>
<span class="lineno">  394 </span><span class="spaces">                </span><span class="istickedoff">case tyInner of</span>
<span class="lineno">  395 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt t -&gt; do</span>
<span class="lineno">  396 </span><span class="spaces">                        </span><span class="istickedoff">is &lt;- concatMapM (intsOut <span class="nottickedoff">&quot;OpMin 1&quot;</span>) xs</span>
<span class="lineno">  397 </span><span class="spaces">                        </span><span class="istickedoff">return $ ConstantInt <span class="nottickedoff">t</span> (minimum is)</span>
<span class="lineno">  398 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na &quot;evaluateOp{OpMin}&quot;</span></span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpMin}&quot; &lt;+&gt; pretty (show op)</span></span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>instance EvaluateOp OpMinus where
<span class="lineno">  402 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | any isUndef (childrenBi p) = do</span>
<span class="lineno">  403 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- typeOf p</span>
<span class="lineno">  404 </span><span class="spaces">        </span><span class="istickedoff">return $ mkUndef ty $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMinus (ConstantInt t a) (ConstantInt _ b))</span>
<span class="lineno">  406 </span><span class="spaces">      </span><span class="istickedoff">= return $ ConstantInt t (a - b)</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMinus (viewConstantSet -&gt; Just as) (viewConstantSet -&gt; Just bs)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  408 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let outs =</span></span>
<span class="lineno">  409 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ a</span></span>
<span class="lineno">  410 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">| a &lt;- as</span></span>
<span class="lineno">  411 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, a `notElem` bs</span></span>
<span class="lineno">  412 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  413 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitSet outs</span></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMinus (viewConstantMSet -&gt; Just as) (viewConstantMSet -&gt; Just bs)) = do</span>
<span class="lineno">  415 </span><span class="spaces">        </span><span class="istickedoff">let asHist = histogram as</span>
<span class="lineno">  416 </span><span class="spaces">            </span><span class="istickedoff">bsHist = histogram bs</span>
<span class="lineno">  417 </span><span class="spaces">            </span><span class="istickedoff">allElems = sortNub (as++bs)</span>
<span class="lineno">  418 </span><span class="spaces">            </span><span class="istickedoff">outs =</span>
<span class="lineno">  419 </span><span class="spaces">                </span><span class="istickedoff">[ replicate (fromInteger (countA - countB)) e</span>
<span class="lineno">  420 </span><span class="spaces">                </span><span class="istickedoff">| e &lt;- allElems</span>
<span class="lineno">  421 </span><span class="spaces">                </span><span class="istickedoff">, let countA = fromMaybe 0 (e `lookup` asHist)</span>
<span class="lineno">  422 </span><span class="spaces">                </span><span class="istickedoff">, let countB = fromMaybe 0 (e `lookup` bsHist)</span>
<span class="lineno">  423 </span><span class="spaces">                </span><span class="istickedoff">]</span>
<span class="lineno">  424 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitMSet $ concat outs</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMinus (viewConstantFunction -&gt; Just as) (viewConstantFunction -&gt; Just bs)) = do</span>
<span class="lineno">  426 </span><span class="spaces">        </span><span class="istickedoff">let outs =</span>
<span class="lineno">  427 </span><span class="spaces">                </span><span class="istickedoff">[ a</span>
<span class="lineno">  428 </span><span class="spaces">                </span><span class="istickedoff">| a &lt;- as</span>
<span class="lineno">  429 </span><span class="spaces">                </span><span class="istickedoff">, a `notElem` bs</span>
<span class="lineno">  430 </span><span class="spaces">                </span><span class="istickedoff">]</span>
<span class="lineno">  431 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitFunction outs</span>
<span class="lineno">  432 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpMinus (viewConstantRelation -&gt; Just as) (viewConstantRelation -&gt; Just bs)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  433 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let outs =</span></span>
<span class="lineno">  434 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ a</span></span>
<span class="lineno">  435 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">| a &lt;- as</span></span>
<span class="lineno">  436 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, a `notElem` bs</span></span>
<span class="lineno">  437 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  438 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitRelation outs</span></span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpMinus}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>instance EvaluateOp OpMod where
<span class="lineno">  442 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpMod x y)</span>
<span class="lineno">  445 </span><span class="spaces">        </span><span class="istickedoff">| y /= 0    = ConstantInt TagInt &lt;$&gt; (mod &lt;$&gt; intOut <span class="nottickedoff">&quot;mod x&quot;</span> x &lt;*&gt; intOut <span class="nottickedoff">&quot;mod y&quot;</span> y)</span>
<span class="lineno">  446 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;modulo zero:&quot; &lt;+&gt; pretty p</span></span></span>
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>instance EvaluateOp OpNegate where
<span class="lineno">  449 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  450 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpNegate x) = ConstantInt TagInt . negate &lt;$&gt; intOut <span class="nottickedoff">&quot;OpNegate&quot;</span> x</span></span>
<span class="lineno">  452 </span>
<span class="lineno">  453 </span>instance EvaluateOp OpNeq where
<span class="lineno">  454 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpNeq ConstantUndefined{} _) = <span class="nottickedoff">return $ fromBool False</span></span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpNeq _ ConstantUndefined{}) = return $ fromBool False</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpNeq x y) = do</span>
<span class="lineno">  457 </span><span class="spaces">        </span><span class="istickedoff">out &lt;- evaluateOp (OpEq x y)</span>
<span class="lineno">  458 </span><span class="spaces">        </span><span class="istickedoff">evaluateOp (OpNot out)</span></span>
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>instance EvaluateOp OpNot where
<span class="lineno">  461 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpNot x) = ConstantBool . not &lt;$&gt; boolOut x</span></span>
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>instance EvaluateOp OpOr where
<span class="lineno">  464 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpOr x) = ConstantBool . or &lt;$&gt; boolsOut x</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>instance EvaluateOp OpParticipants where
<span class="lineno">  467 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpParticipants (viewConstantPartition -&gt; Just xss)) =</span>
<span class="lineno">  468 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sort $ concat xss</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpParticipants}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>instance EvaluateOp OpParts where
<span class="lineno">  472 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpParts (viewConstantPartition -&gt; Just xs)) =</span>
<span class="lineno">  473 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ map (ConstantAbstract . AbsLitSet) xs</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpParts}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>instance EvaluateOp OpParty where
<span class="lineno">  477 </span>    <span class="decl"><span class="istickedoff">evaluateOp op@(OpParty x p@(viewConstantPartition -&gt; Just xss)) = do</span>
<span class="lineno">  478 </span><span class="spaces">        </span><span class="istickedoff">TypePartition tyInner &lt;- typeOf p</span>
<span class="lineno">  479 </span><span class="spaces">        </span><span class="istickedoff">let</span>
<span class="lineno">  480 </span><span class="spaces">            </span><span class="istickedoff">outSet = [ xs</span>
<span class="lineno">  481 </span><span class="spaces">                     </span><span class="istickedoff">| xs &lt;- xss</span>
<span class="lineno">  482 </span><span class="spaces">                     </span><span class="istickedoff">, x `elem` xs</span>
<span class="lineno">  483 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  484 </span><span class="spaces">        </span><span class="istickedoff">case outSet of</span>
<span class="lineno">  485 </span><span class="spaces">            </span><span class="istickedoff">[s] -&gt; return $ ConstantAbstract (AbsLitSet s)</span>
<span class="lineno">  486 </span><span class="spaces">            </span><span class="istickedoff">[]  -&gt; return $ TypedConstant (ConstantAbstract (AbsLitSet [])) <span class="nottickedoff">(TypeSet tyInner)</span></span>
<span class="lineno">  487 </span><span class="spaces">            </span><span class="istickedoff">_   -&gt; <span class="nottickedoff">return $ mkUndef (TypeSet tyInner) $ &quot;Element found in multiple parts of the partition:&quot;</span></span>
<span class="lineno">  488 </span><span class="spaces">                                                                                                </span><span class="istickedoff"><span class="nottickedoff">&lt;++&gt; pretty op</span></span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpParty}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>instance EvaluateOp OpPow where
<span class="lineno">  492 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  493 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  494 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpPow x y)</span>
<span class="lineno">  495 </span><span class="spaces">        </span><span class="istickedoff">| y &gt;= 0    = ConstantInt TagInt &lt;$&gt; ((^) &lt;$&gt; intOut <span class="nottickedoff">&quot;pow x&quot;</span> x &lt;*&gt; intOut <span class="nottickedoff">&quot;pow y&quot;</span> y)</span>
<span class="lineno">  496 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;negative exponent:&quot; &lt;+&gt; pretty p</span></span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>instance EvaluateOp OpPowerSet where
<span class="lineno">  499 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpPowerSet (viewConstantSet -&gt; Just xs)) =</span>
<span class="lineno">  500 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet</span>
<span class="lineno">  501 </span><span class="spaces">            </span><span class="istickedoff">[ ConstantAbstract $ AbsLitSet ys</span>
<span class="lineno">  502 </span><span class="spaces">            </span><span class="istickedoff">| ys &lt;- subsequences (sortBy ordTildeLt (sortNub xs)) ]</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpPowerSet}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>instance EvaluateOp OpPred where
<span class="lineno">  506 </span>    <span class="decl"><span class="nottickedoff">evaluateOp p | any isUndef (childrenBi p) =</span>
<span class="lineno">  507 </span><span class="spaces">        </span><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpPred (ConstantBool _)) = return (ConstantBool False)          -- True --&gt; False</span>
<span class="lineno">  509 </span><span class="spaces">                                                                                </span><span class="nottickedoff">-- False --&gt; undef, hence False</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpPred (ConstantInt TagInt x)) = return (ConstantInt TagInt (pred x))</span>
<span class="lineno">  511 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpPred (ConstantInt (TagEnum t) x))</span>
<span class="lineno">  512 </span><span class="spaces">        </span><span class="nottickedoff">= return (ConstantInt (TagEnum t) (pred x))</span>
<span class="lineno">  513 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpPred}&quot; &lt;+&gt; pretty (show op)</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>instance EvaluateOp OpPreImage where
<span class="lineno">  516 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpPreImage (viewConstantFunction -&gt; Just xs) a) =</span>
<span class="lineno">  517 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet [ x | (x,y) &lt;- xs, a == y ]</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpPreImage (viewConstantSequence -&gt; Just xs) a) =</span>
<span class="lineno">  519 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitSet [ x | (n,y) &lt;- zip allNats xs</span></span>
<span class="lineno">  520 </span><span class="spaces">                                                  </span><span class="istickedoff"><span class="nottickedoff">, let x = ConstantInt TagInt n</span></span>
<span class="lineno">  521 </span><span class="spaces">                                                  </span><span class="istickedoff"><span class="nottickedoff">, a == y ]</span></span>
<span class="lineno">  522 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpPreImage}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  523 </span>
<span class="lineno">  524 </span>instance EvaluateOp OpProduct where
<span class="lineno">  525 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> =</span>
<span class="lineno">  526 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpProduct x)</span>
<span class="lineno">  528 </span><span class="spaces">        </span><span class="istickedoff">| Just xs &lt;- listOut x</span>
<span class="lineno">  529 </span><span class="spaces">        </span><span class="istickedoff">, <span class="tickonlyfalse">any isUndef xs</span> =</span>
<span class="lineno">  530 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  531 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpProduct x) = ConstantInt TagInt . product &lt;$&gt; intsOut <span class="nottickedoff">&quot;OpProduct&quot;</span> x</span></span>
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>instance EvaluateOp OpRange where
<span class="lineno">  534 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> = <span class="nottickedoff">do</span></span>
<span class="lineno">  535 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty &lt;- typeOf p</span></span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef ty $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpRange (viewConstantFunction -&gt; Just xs)) =</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub $ map snd xs</span>
<span class="lineno">  539 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpRange}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>instance EvaluateOp OpRelationProj where
<span class="lineno">  542 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpRelationProj (viewConstantRelation -&gt; Just xss) mas) = do</span>
<span class="lineno">  543 </span><span class="spaces">        </span><span class="istickedoff">let mas' = catMaybes mas</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlytrue">length mas == length mas'</span></span>
<span class="lineno">  545 </span><span class="spaces">            </span><span class="istickedoff">then -- all Just's</span>
<span class="lineno">  546 </span><span class="spaces">                </span><span class="istickedoff">return $ ConstantBool $ mas' `elem` xss</span>
<span class="lineno">  547 </span><span class="spaces">            </span><span class="istickedoff">else</span>
<span class="lineno">  548 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitRelation</span></span>
<span class="lineno">  549 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ xsProject</span></span>
<span class="lineno">  550 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">| xs &lt;- xss</span></span>
<span class="lineno">  551 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, let xsProject   = [ x</span></span>
<span class="lineno">  552 </span><span class="spaces">                                        </span><span class="istickedoff"><span class="nottickedoff">| (x, Nothing) &lt;- zip xs mas</span></span>
<span class="lineno">  553 </span><span class="spaces">                                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  554 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, let xsCondition = [ x == y</span></span>
<span class="lineno">  555 </span><span class="spaces">                                        </span><span class="istickedoff"><span class="nottickedoff">| (x, Just y ) &lt;- zip xs mas</span></span>
<span class="lineno">  556 </span><span class="spaces">                                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  557 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, and xsCondition</span></span>
<span class="lineno">  558 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">-- leave the OpImage evaluator in -- it is just easier</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpRelationProj f@(viewConstantFunction -&gt; Just _) [Just arg]) =</span>
<span class="lineno">  561 </span><span class="spaces">        </span><span class="istickedoff">evaluateOp (OpImage f arg)</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpRelationProj f@(viewConstantSequence -&gt; Just _) [Just arg]) =</span>
<span class="lineno">  563 </span><span class="spaces">        </span><span class="istickedoff">evaluateOp (OpImage f arg)</span>
<span class="lineno">  564 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpRelationProj}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>instance EvaluateOp OpRestrict where
<span class="lineno">  567 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpRestrict (viewConstantFunction -&gt; Just xs) domX) = do</span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="nottickedoff">dom     &lt;- domainOut domX</span>
<span class="lineno">  569 </span><span class="spaces">        </span><span class="nottickedoff">outVals &lt;- concatForM xs $ \case</span>
<span class="lineno">  570 </span><span class="spaces">            </span><span class="nottickedoff">x@(a, _) -&gt; do</span>
<span class="lineno">  571 </span><span class="spaces">                </span><span class="nottickedoff">mres &lt;- runExceptT $ validateConstantForDomain &quot;&lt;in memory&gt;&quot; a (dom :: Domain () Constant)</span>
<span class="lineno">  572 </span><span class="spaces">                </span><span class="nottickedoff">case mres of</span>
<span class="lineno">  573 </span><span class="spaces">                    </span><span class="nottickedoff">Left {} -&gt; return []</span>
<span class="lineno">  574 </span><span class="spaces">                    </span><span class="nottickedoff">Right{} -&gt; return [x]</span>
<span class="lineno">  575 </span><span class="spaces">        </span><span class="nottickedoff">return $ ConstantAbstract $ AbsLitFunction $ sortNub outVals</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpRestrict}:&quot; &lt;++&gt; pretty (show op)</span></span>
<span class="lineno">  577 </span>
<span class="lineno">  578 </span>instance EvaluateOp OpSlicing where
<span class="lineno">  579 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSlicing (viewConstantMatrix -&gt; Just (DomainInt n index, vals)) lb ub)</span>
<span class="lineno">  580 </span><span class="spaces">      </span><span class="istickedoff">= do</span>
<span class="lineno">  581 </span><span class="spaces">        </span><span class="istickedoff">indexVals &lt;- valuesInIntDomain index</span>
<span class="lineno">  582 </span><span class="spaces">        </span><span class="istickedoff">outVals   &lt;- fmap catMaybes $ forM (zip indexVals vals)</span>
<span class="lineno">  583 </span><span class="spaces">                     </span><span class="istickedoff">$ \ (thisIndex, thisVal) -&gt;</span>
<span class="lineno">  584 </span><span class="spaces">                         </span><span class="istickedoff">case lb of</span>
<span class="lineno">  585 </span><span class="spaces">                             </span><span class="istickedoff">Just (ConstantInt cn lower)</span>
<span class="lineno">  586 </span><span class="spaces">                               </span><span class="istickedoff">| <span class="nottickedoff">cn == n &amp;&amp; lower &gt; thisIndex</span> -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno">  587 </span><span class="spaces">                             </span><span class="istickedoff">_ -&gt; case ub of</span>
<span class="lineno">  588 </span><span class="spaces">                                    </span><span class="istickedoff">Just (ConstantInt cn upper)</span>
<span class="lineno">  589 </span><span class="spaces">                                      </span><span class="istickedoff">| <span class="nottickedoff">cn == n &amp;&amp; upper &lt; thisIndex</span> -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno">  590 </span><span class="spaces">                                    </span><span class="istickedoff">_ -&gt; return $ Just (<span class="nottickedoff">thisIndex</span>, thisVal)</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">let <span class="nottickedoff">outDomain = DomainInt n $ map (RangeSingle . (ConstantInt n) . fst) outVals</span></span>
<span class="lineno">  592 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitMatrix <span class="nottickedoff">outDomain</span> (map snd outVals)</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpSlicing}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  594 </span>
<span class="lineno">  595 </span>instance EvaluateOp OpSubsequence where
<span class="lineno">  596 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSubsequence</span>
<span class="lineno">  597 </span><span class="spaces">        </span><span class="istickedoff">(viewConstantSequence -&gt; Just xs)</span>
<span class="lineno">  598 </span><span class="spaces">        </span><span class="istickedoff">(viewConstantSequence -&gt; Just ys)) =</span>
<span class="lineno">  599 </span><span class="spaces">            </span><span class="istickedoff">return $ fromBool $</span>
<span class="lineno">  600 </span><span class="spaces">                </span><span class="istickedoff">or [ and (zipWith (==) xs zs)</span>
<span class="lineno">  601 </span><span class="spaces">                   </span><span class="istickedoff">| zs &lt;- subsequences ys</span>
<span class="lineno">  602 </span><span class="spaces">                   </span><span class="istickedoff">, length zs &gt;= length xs</span>
<span class="lineno">  603 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpSubsequence}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  605 </span>
<span class="lineno">  606 </span>instance EvaluateOp OpSubset where
<span class="lineno">  607 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSubset a b) = do</span>
<span class="lineno">  608 </span><span class="spaces">        </span><span class="istickedoff">x &lt;- evaluateOp (OpSubsetEq a b)</span>
<span class="lineno">  609 </span><span class="spaces">        </span><span class="istickedoff">y &lt;- evaluateOp (OpNeq a b)</span>
<span class="lineno">  610 </span><span class="spaces">        </span><span class="istickedoff">evaluateOp (OpAnd (fromList [x,y]))</span></span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>instance EvaluateOp OpSubsetEq where
<span class="lineno">  613 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSubsetEq (viewConstantSet -&gt; Just as) (viewConstantSet -&gt; Just bs)) =</span>
<span class="lineno">  614 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ all (`elem` bs) as</span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpSubsetEq (viewConstantMSet -&gt; Just as) (viewConstantMSet -&gt; Just bs)) =</span>
<span class="lineno">  616 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let asHist = histogram as</span></span>
<span class="lineno">  617 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">bsHist = histogram bs</span></span>
<span class="lineno">  618 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">allElems = sortNub (as++bs)</span></span>
<span class="lineno">  619 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in return $ ConstantBool $ and</span></span>
<span class="lineno">  620 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ countA &lt;= countB</span></span>
<span class="lineno">  621 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">| e &lt;- allElems</span></span>
<span class="lineno">  622 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, let countA = fromMaybe 0 (e `lookup` asHist)</span></span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, let countB = fromMaybe 0 (e `lookup` bsHist)</span></span>
<span class="lineno">  624 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  625 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpSubsetEq (viewConstantFunction -&gt; Just as) (viewConstantFunction -&gt; Just bs)) =</span>
<span class="lineno">  626 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantBool $ all (`elem` bs) as</span></span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpSubsetEq (viewConstantRelation -&gt; Just as) (viewConstantRelation -&gt; Just bs)) =</span>
<span class="lineno">  628 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantBool $ all (`elem` bs) as</span></span>
<span class="lineno">  629 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpSubsetEq}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  630 </span>
<span class="lineno">  631 </span>instance EvaluateOp OpSubstring where
<span class="lineno">  632 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSubstring</span>
<span class="lineno">  633 </span><span class="spaces">        </span><span class="istickedoff">(viewConstantSequence -&gt; Just xs)</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="istickedoff">(viewConstantSequence -&gt; Just ys)) =</span>
<span class="lineno">  635 </span><span class="spaces">            </span><span class="istickedoff">return $ fromBool $</span>
<span class="lineno">  636 </span><span class="spaces">                </span><span class="istickedoff">or [ and (zipWith (==) xs zs)</span>
<span class="lineno">  637 </span><span class="spaces">                   </span><span class="istickedoff">| zs &lt;- tails ys</span>
<span class="lineno">  638 </span><span class="spaces">                   </span><span class="istickedoff">, length zs &gt;= length xs</span>
<span class="lineno">  639 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpSubstring}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>instance EvaluateOp OpSucc where
<span class="lineno">  643 </span>    <span class="decl"><span class="nottickedoff">evaluateOp p | any isUndef (childrenBi p) =</span>
<span class="lineno">  644 </span><span class="spaces">        </span><span class="nottickedoff">return $ mkUndef (TypeInt TagInt) $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span>
<span class="lineno">  645 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpSucc (ConstantBool False)) = return (ConstantBool True)</span>
<span class="lineno">  646 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpSucc (ConstantBool True )) = return (ConstantBool False)          -- undef</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpSucc (ConstantInt TagInt x)) = return (ConstantInt TagInt (succ x))</span>
<span class="lineno">  648 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp (OpSucc (ConstantInt (TagEnum t) x))</span>
<span class="lineno">  649 </span><span class="spaces">        </span><span class="nottickedoff">= return (ConstantInt (TagEnum t) (succ x))</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpSucc}&quot; &lt;+&gt; pretty (show op)</span></span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>instance EvaluateOp OpSum where
<span class="lineno">  653 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | any isUndef (childrenBi p) =</span>
<span class="lineno">  654 </span><span class="spaces">            </span><span class="istickedoff">return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  655 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp p@(OpSum x)</span>
<span class="lineno">  656 </span><span class="spaces">        </span><span class="istickedoff">| Just xs &lt;- listOut x</span>
<span class="lineno">  657 </span><span class="spaces">        </span><span class="istickedoff">, any isUndef xs =</span>
<span class="lineno">  658 </span><span class="spaces">            </span><span class="istickedoff">return $ mkUndef (TypeInt <span class="nottickedoff">TagInt</span>) $ <span class="nottickedoff">&quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  659 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpSum x) = ConstantInt TagInt . sum &lt;$&gt; intsOut <span class="nottickedoff">&quot;OpSum&quot;</span> x</span></span>
<span class="lineno">  660 </span>
<span class="lineno">  661 </span>instance EvaluateOp OpSupset where
<span class="lineno">  662 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpSupset a b) = evaluateOp (OpSubset b a)</span></span>
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>instance EvaluateOp OpSupsetEq where
<span class="lineno">  665 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpSupsetEq a b) = evaluateOp (OpSubsetEq b a)</span></span>
<span class="lineno">  666 </span>
<span class="lineno">  667 </span>instance EvaluateOp OpTable where
<span class="lineno">  668 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpTable rows table) = do</span>
<span class="lineno">  669 </span><span class="spaces">        </span><span class="nottickedoff">rows' &lt;- intsOut &quot;OpTable-rows&quot; rows</span>
<span class="lineno">  670 </span><span class="spaces">        </span><span class="nottickedoff">table' &lt;- intsOut2D &quot;OpTable-table&quot; table</span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="nottickedoff">return $ ConstantBool $ rows' `elem` table'</span></span>
<span class="lineno">  672 </span>
<span class="lineno">  673 </span>instance EvaluateOp OpGCC where
<span class="lineno">  674 </span>    <span class="decl"><span class="nottickedoff">evaluateOp op@OpGCC{} = na $ &quot;evaluateOp{OpGCC}&quot; &lt;+&gt; pretty op</span></span>
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>instance EvaluateOp OpAtLeast where
<span class="lineno">  677 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAtLeast (intsOut &quot;&quot; -&gt; Just vars)</span>
<span class="lineno">  678 </span><span class="spaces">                          </span><span class="istickedoff">(intsOut &quot;&quot; -&gt; Just bounds)</span>
<span class="lineno">  679 </span><span class="spaces">                          </span><span class="istickedoff">(intsOut &quot;&quot; -&gt; Just vals)) = do</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ and [ sum [1 | x &lt;- vars, x == val] &gt;= bound</span>
<span class="lineno">  681 </span><span class="spaces">                                    </span><span class="istickedoff">| (bound, val) &lt;- zip bounds vals</span>
<span class="lineno">  682 </span><span class="spaces">                                    </span><span class="istickedoff">]</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op@OpAtLeast{} = <span class="nottickedoff">na $ &quot;evaluateOp{OpAtLeast}&quot; &lt;+&gt; pretty op</span></span></span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>instance EvaluateOp OpAtMost where
<span class="lineno">  686 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpAtMost (intsOut &quot;&quot; -&gt; Just vars)</span>
<span class="lineno">  687 </span><span class="spaces">                         </span><span class="istickedoff">(intsOut &quot;&quot; -&gt; Just bounds)</span>
<span class="lineno">  688 </span><span class="spaces">                         </span><span class="istickedoff">(intsOut &quot;&quot; -&gt; Just vals)) = do</span>
<span class="lineno">  689 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ and [ sum [1 | x &lt;- vars, x == val] &lt;= bound</span>
<span class="lineno">  690 </span><span class="spaces">                                    </span><span class="istickedoff">| (bound, val) &lt;- zip bounds vals</span>
<span class="lineno">  691 </span><span class="spaces">                                    </span><span class="istickedoff">]</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op@OpAtMost{} = <span class="nottickedoff">na $ &quot;evaluateOp{OpAtMost}&quot; &lt;+&gt; pretty op</span></span></span>
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>instance EvaluateOp OpTildeLeq where
<span class="lineno">  695 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpTildeLeq x y) = do</span>
<span class="lineno">  696 </span><span class="spaces">        </span><span class="nottickedoff">flag1 &lt;- evaluateOp (OpEq x y)</span>
<span class="lineno">  697 </span><span class="spaces">        </span><span class="nottickedoff">flag2 &lt;- evaluateOp (OpTildeLt x y)</span>
<span class="lineno">  698 </span><span class="spaces">        </span><span class="nottickedoff">evaluateOp $ OpOr $ fromList [flag1, flag2]</span></span>
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>instance EvaluateOp OpTildeLt where
<span class="lineno">  701 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpTildeLt x y) = return $ ConstantBool $ tildeLt x y</span></span>
<span class="lineno">  702 </span>
<span class="lineno">  703 </span>instance EvaluateOp OpTogether where
<span class="lineno">  704 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpTogether _ ConstantUndefined{}) = return (fromBool False)</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpTogether (viewConstantSet -&gt; Just ys) (viewConstantPartition -&gt; Just xss)) =</span>
<span class="lineno">  706 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantBool $ or</span>
<span class="lineno">  707 </span><span class="spaces">            </span><span class="istickedoff">[ and [ y `elem` xs | y &lt;- ys ]</span>
<span class="lineno">  708 </span><span class="spaces">            </span><span class="istickedoff">| xs &lt;- xss</span>
<span class="lineno">  709 </span><span class="spaces">            </span><span class="istickedoff">]</span>
<span class="lineno">  710 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpTogether}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  711 </span>
<span class="lineno">  712 </span>instance EvaluateOp OpToInt where
<span class="lineno">  713 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpToInt (ConstantBool False)) = return (ConstantInt TagInt 0)</span>
<span class="lineno">  714 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToInt (ConstantBool True )) = return (ConstantInt TagInt 1)</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToInt ConstantUndefined{})  = <span class="nottickedoff">return (ConstantInt TagInt 0)</span></span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpToInt}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  717 </span>
<span class="lineno">  718 </span>instance EvaluateOp OpToMSet where
<span class="lineno">  719 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpToMSet (viewConstantSet -&gt; Just xs)) =</span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitMSet xs</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToMSet (viewConstantMSet -&gt; Just xs)) =</span>
<span class="lineno">  722 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitMSet xs</span></span>
<span class="lineno">  723 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToMSet (viewConstantFunction -&gt; Just xs)) =</span>
<span class="lineno">  724 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitMSet [ConstantAbstract $ AbsLitTuple [a,b] | (a,b) &lt;- xs]</span></span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToMSet (viewConstantRelation -&gt; Just xs)) =</span>
<span class="lineno">  726 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitMSet $ map (ConstantAbstract . AbsLitTuple) xs</span></span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpToMSet}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  728 </span>
<span class="lineno">  729 </span>instance EvaluateOp OpToRelation where
<span class="lineno">  730 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpToRelation (viewConstantFunction -&gt; Just xs)) =</span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitRelation $ sortNub [ [a,b] | (a,b) &lt;- xs ]</span>
<span class="lineno">  732 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpToRelation}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  733 </span>
<span class="lineno">  734 </span>instance EvaluateOp OpToSet where
<span class="lineno">  735 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpToSet _ (viewConstantMatrix -&gt; Just (_, xs))) =</span>
<span class="lineno">  736 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub xs</span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToSet _ (viewConstantSet -&gt; Just xs)) =</span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub xs</span></span>
<span class="lineno">  739 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToSet _ (viewConstantMSet -&gt; Just xs)) =</span>
<span class="lineno">  740 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub xs</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToSet _ (viewConstantFunction -&gt; Just xs)) =</span>
<span class="lineno">  742 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub [ConstantAbstract $ AbsLitTuple [a,b] | (a,b) &lt;- xs]</span></span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpToSet _ (viewConstantRelation -&gt; Just xs)) =</span>
<span class="lineno">  744 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub $ map (ConstantAbstract . AbsLitTuple) xs</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpToSet}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>instance EvaluateOp OpTransform where
<span class="lineno">  748 </span>    <span class="decl"><span class="nottickedoff">evaluateOp op = na $ &quot;evaluateOp{OpTransform}:&quot; &lt;++&gt; pretty (show op)</span></span>
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>instance EvaluateOp OpTrue where
<span class="lineno">  751 </span>    <span class="decl"><span class="istickedoff">evaluateOp _ = return (fromBool True)</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>instance EvaluateOp OpTwoBars where
<span class="lineno">  754 </span>    <span class="decl"><span class="istickedoff">evaluateOp (OpTwoBars x) =</span>
<span class="lineno">  755 </span><span class="spaces">        </span><span class="istickedoff">case x of</span>
<span class="lineno">  756 </span><span class="spaces">            </span><span class="istickedoff">-- absolute value</span>
<span class="lineno">  757 </span><span class="spaces">            </span><span class="istickedoff">ConstantInt _ y                         -&gt; return $ ConstantInt <span class="nottickedoff">TagInt</span> $ abs y</span>
<span class="lineno">  758 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  759 </span><span class="spaces">            </span><span class="istickedoff">-- cardinality of a constant</span>
<span class="lineno">  760 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantMatrix    -&gt; Just (_, xs)) -&gt; return $ ConstantInt <span class="nottickedoff">TagInt</span> $ genericLength                    xs</span>
<span class="lineno">  761 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantSet       -&gt; Just xs)      -&gt; return $ ConstantInt TagInt $ genericLength $ sortNub          xs</span>
<span class="lineno">  762 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantMSet      -&gt; Just xs)      -&gt; return $ ConstantInt <span class="nottickedoff">TagInt</span> $ genericLength                    xs</span>
<span class="lineno">  763 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantFunction  -&gt; Just xs)      -&gt; <span class="nottickedoff">return $ ConstantInt TagInt $ genericLength $ sortNub          xs</span></span>
<span class="lineno">  764 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantSequence  -&gt; Just xs)      -&gt; return $ ConstantInt TagInt $ genericLength                    xs</span>
<span class="lineno">  765 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantRelation  -&gt; Just xs)      -&gt; return $ ConstantInt TagInt $ genericLength $ sortNub          xs</span>
<span class="lineno">  766 </span><span class="spaces">            </span><span class="istickedoff">(viewConstantPartition -&gt; Just xs)      -&gt; <span class="nottickedoff">return $ ConstantInt TagInt $ genericLength $ sortNub $ concat xs</span></span>
<span class="lineno">  767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  768 </span><span class="spaces">            </span><span class="istickedoff">-- cardinality of a domain</span>
<span class="lineno">  769 </span><span class="spaces">            </span><span class="istickedoff">DomainInConstant (DomainInt _ rs) -&gt; ConstantInt TagInt . genericLength &lt;$&gt; rangesInts rs</span>
<span class="lineno">  770 </span><span class="spaces">            </span><span class="istickedoff">DomainInConstant dom            -&gt; runNameGen <span class="nottickedoff">()</span> $ domainSizeOf dom</span>
<span class="lineno">  771 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">na $ &quot;evaluateOp OpTwoBars&quot; &lt;+&gt; pretty (show x)</span></span></span>
<span class="lineno">  772 </span>
<span class="lineno">  773 </span>instance EvaluateOp OpUnion where
<span class="lineno">  774 </span>    <span class="decl"><span class="istickedoff">evaluateOp p | <span class="tickonlyfalse">any isUndef (childrenBi p)</span> = <span class="nottickedoff">do</span></span>
<span class="lineno">  775 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty &lt;- typeOf p</span></span>
<span class="lineno">  776 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ mkUndef ty $ &quot;Has undefined children:&quot; &lt;+&gt; pretty p</span></span>
<span class="lineno">  777 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpUnion (viewConstantSet -&gt; Just as) (viewConstantSet -&gt; Just bs)) =</span>
<span class="lineno">  778 </span><span class="spaces">        </span><span class="istickedoff">return $ ConstantAbstract $ AbsLitSet $ sortNub (as ++ bs)</span>
<span class="lineno">  779 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpUnion (viewConstantMSet -&gt; Just as) (viewConstantMSet -&gt; Just bs)) =</span>
<span class="lineno">  780 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let asHist = histogram as</span></span>
<span class="lineno">  781 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">bsHist = histogram bs</span></span>
<span class="lineno">  782 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">allElems = sortNub (as++bs)</span></span>
<span class="lineno">  783 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in</span></span>
<span class="lineno">  784 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitMSet $ concat</span></span>
<span class="lineno">  785 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ replicate (fromInteger (max countA countB)) e</span></span>
<span class="lineno">  786 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">| e &lt;- allElems</span></span>
<span class="lineno">  787 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, let countA = fromMaybe 0 (e `lookup` asHist)</span></span>
<span class="lineno">  788 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, let countB = fromMaybe 0 (e `lookup` bsHist)</span></span>
<span class="lineno">  789 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: what if the same thing is mapped to two different values? undefined behaviour?</span>
<span class="lineno">  791 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpUnion (viewConstantFunction -&gt; Just as) (viewConstantFunction -&gt; Just bs)) =</span>
<span class="lineno">  792 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitFunction $ sortNub (as ++ bs)</span></span>
<span class="lineno">  793 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (OpUnion (viewConstantRelation -&gt; Just as) (viewConstantRelation -&gt; Just bs)) =</span>
<span class="lineno">  794 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return $ ConstantAbstract $ AbsLitRelation $ sortNub (as ++ bs)</span></span>
<span class="lineno">  795 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp op = <span class="nottickedoff">na $ &quot;evaluateOp{OpUnion}:&quot; &lt;++&gt; pretty (show op)</span></span></span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>instance EvaluateOp OpXor where
<span class="lineno">  798 </span>    <span class="decl"><span class="nottickedoff">evaluateOp (OpXor x) = ConstantBool . xor &lt;$&gt; boolsOut x</span>
<span class="lineno">  799 </span><span class="spaces">        </span><span class="nottickedoff">where xor xs = odd (length [ () | True &lt;- xs ])</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>
<span class="lineno">  802 </span>boolsOut :: MonadFailDoc m =&gt; Constant -&gt; m [Bool]
<span class="lineno">  803 </span><span class="decl"><span class="istickedoff">boolsOut (viewConstantMatrix -&gt; Just (_, cs)) = concatMapM boolsOut cs</span>
<span class="lineno">  804 </span><span class="spaces"></span><span class="istickedoff">boolsOut b = return &lt;$&gt; boolOut b</span></span>
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>intsOut :: MonadFailDoc m =&gt; Doc -&gt; Constant -&gt; m [Integer]
<span class="lineno">  807 </span><span class="decl"><span class="istickedoff">intsOut doc (viewConstantMatrix -&gt; Just (_, cs)) = concatMapM (intsOut <span class="nottickedoff">doc</span>) cs</span>
<span class="lineno">  808 </span><span class="spaces"></span><span class="istickedoff">intsOut doc (viewConstantSet -&gt; Just cs) = concatMapM (intsOut <span class="nottickedoff">doc</span>) cs</span>
<span class="lineno">  809 </span><span class="spaces"></span><span class="istickedoff">intsOut doc (viewConstantMSet -&gt; Just cs) = <span class="nottickedoff">concatMapM (intsOut doc) cs</span></span>
<span class="lineno">  810 </span><span class="spaces"></span><span class="istickedoff">intsOut doc b = return &lt;$&gt; intOut <span class="nottickedoff">(&quot;intsOut&quot; &lt;+&gt; doc)</span> b</span></span>
<span class="lineno">  811 </span>
<span class="lineno">  812 </span>intsOut2D :: MonadFailDoc m =&gt; Doc -&gt; Constant -&gt; m [[Integer]]
<span class="lineno">  813 </span><span class="decl"><span class="nottickedoff">intsOut2D doc (viewConstantMatrix -&gt; Just (_, cs)) = mapM (intsOut doc) cs</span>
<span class="lineno">  814 </span><span class="spaces"></span><span class="nottickedoff">intsOut2D doc (viewConstantSet -&gt; Just cs) = mapM (intsOut doc) cs</span>
<span class="lineno">  815 </span><span class="spaces"></span><span class="nottickedoff">intsOut2D doc (viewConstantMSet -&gt; Just cs) = mapM (intsOut doc) cs</span>
<span class="lineno">  816 </span><span class="spaces"></span><span class="nottickedoff">intsOut2D doc _ = failDoc (&quot;intsOut2D&quot; &lt;+&gt; doc)</span></span>
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>tildeLt :: Constant -&gt; Constant -&gt; Bool
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">tildeLt = tilLt</span>
<span class="lineno">  820 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  821 </span><span class="spaces">        </span><span class="istickedoff">freq :: Eq a =&gt; a -&gt; [a] -&gt; Int</span>
<span class="lineno">  822 </span><span class="spaces">        </span><span class="istickedoff">freq i xs = sum [ 1 | j &lt;- xs , i == j ]</span>
<span class="lineno">  823 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  824 </span><span class="spaces">        </span><span class="istickedoff">tupleE (i,j) = ConstantAbstract $ AbsLitTuple [i,j]</span>
<span class="lineno">  825 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  826 </span><span class="spaces">        </span><span class="istickedoff">tilLt :: Constant -&gt; Constant -&gt; Bool</span>
<span class="lineno">  827 </span><span class="spaces">        </span><span class="istickedoff">tilLt (ConstantBool a) (ConstantBool b) = a &lt; b</span>
<span class="lineno">  828 </span><span class="spaces">        </span><span class="istickedoff">tilLt (ConstantInt TagInt a) (ConstantInt TagInt b) = a &lt; b</span>
<span class="lineno">  829 </span><span class="spaces">        </span><span class="istickedoff">tilLt (ConstantInt (TagEnum an) a) (ConstantInt (TagEnum bn) b)</span>
<span class="lineno">  830 </span><span class="spaces">              </span><span class="istickedoff">| <span class="nottickedoff">an == bn</span> = <span class="nottickedoff">a &lt; b</span></span>
<span class="lineno">  831 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantTuple -&gt; Just [])</span>
<span class="lineno">  832 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantTuple -&gt; Just []) = False</span>
<span class="lineno">  833 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantTuple -&gt; Just (a:as))</span>
<span class="lineno">  834 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantTuple -&gt; Just (b:bs)) =</span>
<span class="lineno">  835 </span><span class="spaces">                  </span><span class="istickedoff">if tilLt a b</span>
<span class="lineno">  836 </span><span class="spaces">                      </span><span class="istickedoff">then True</span>
<span class="lineno">  837 </span><span class="spaces">                      </span><span class="istickedoff">else a == b &amp;&amp;</span>
<span class="lineno">  838 </span><span class="spaces">                           </span><span class="istickedoff">tilLt (ConstantAbstract $ AbsLitTuple as)</span>
<span class="lineno">  839 </span><span class="spaces">                                 </span><span class="istickedoff">(ConstantAbstract $ AbsLitTuple bs)</span>
<span class="lineno">  840 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantSet -&gt; Just as)</span>
<span class="lineno">  841 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantSet -&gt; Just bs) =</span>
<span class="lineno">  842 </span><span class="spaces">            </span><span class="istickedoff">or [ and [ freq i as &lt; freq i bs</span>
<span class="lineno">  843 </span><span class="spaces">                     </span><span class="istickedoff">, and [ if tilLt j i</span>
<span class="lineno">  844 </span><span class="spaces">                                 </span><span class="istickedoff">then freq j as == freq j bs</span>
<span class="lineno">  845 </span><span class="spaces">                                 </span><span class="istickedoff">else True</span>
<span class="lineno">  846 </span><span class="spaces">                           </span><span class="istickedoff">| j &lt;- cs</span>
<span class="lineno">  847 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  848 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  849 </span><span class="spaces">               </span><span class="istickedoff">| let cs = sortNub (as ++ bs)</span>
<span class="lineno">  850 </span><span class="spaces">               </span><span class="istickedoff">, i &lt;- cs</span>
<span class="lineno">  851 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  852 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantMSet -&gt; Just as)</span>
<span class="lineno">  853 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantMSet -&gt; Just bs) =</span>
<span class="lineno">  854 </span><span class="spaces">            </span><span class="istickedoff">or [ and [ freq i as &lt; freq i bs</span>
<span class="lineno">  855 </span><span class="spaces">                     </span><span class="istickedoff">, and [ if <span class="tickonlyfalse">tilLt j i</span></span>
<span class="lineno">  856 </span><span class="spaces">                                 </span><span class="istickedoff">then <span class="nottickedoff">freq j as == freq j bs</span></span>
<span class="lineno">  857 </span><span class="spaces">                                 </span><span class="istickedoff">else True</span>
<span class="lineno">  858 </span><span class="spaces">                           </span><span class="istickedoff">| j &lt;- cs</span>
<span class="lineno">  859 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  860 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  861 </span><span class="spaces">               </span><span class="istickedoff">| let cs = as ++ bs</span>
<span class="lineno">  862 </span><span class="spaces">               </span><span class="istickedoff">, i &lt;- cs</span>
<span class="lineno">  863 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  864 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantFunction -&gt; Just as')</span>
<span class="lineno">  865 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantFunction -&gt; Just bs') =</span>
<span class="lineno">  866 </span><span class="spaces">            </span><span class="istickedoff">or [ and [ freq i as &lt; freq i bs</span>
<span class="lineno">  867 </span><span class="spaces">                     </span><span class="istickedoff">, and [ if tilLt j i</span>
<span class="lineno">  868 </span><span class="spaces">                                 </span><span class="istickedoff">then freq j as == freq j bs</span>
<span class="lineno">  869 </span><span class="spaces">                                 </span><span class="istickedoff">else True</span>
<span class="lineno">  870 </span><span class="spaces">                           </span><span class="istickedoff">| j &lt;- cs</span>
<span class="lineno">  871 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  872 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  873 </span><span class="spaces">               </span><span class="istickedoff">| let as = map tupleE as'</span>
<span class="lineno">  874 </span><span class="spaces">               </span><span class="istickedoff">, let bs = map tupleE bs'</span>
<span class="lineno">  875 </span><span class="spaces">               </span><span class="istickedoff">, let cs = as ++ bs</span>
<span class="lineno">  876 </span><span class="spaces">               </span><span class="istickedoff">, i &lt;- cs</span>
<span class="lineno">  877 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  878 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantRelation -&gt; Just as')</span>
<span class="lineno">  879 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantRelation -&gt; Just bs') =</span>
<span class="lineno">  880 </span><span class="spaces">            </span><span class="istickedoff">or [ and [ freq i as &lt; freq i bs</span>
<span class="lineno">  881 </span><span class="spaces">                     </span><span class="istickedoff">, and [ if tilLt j i</span>
<span class="lineno">  882 </span><span class="spaces">                                 </span><span class="istickedoff">then freq j as == freq j bs</span>
<span class="lineno">  883 </span><span class="spaces">                                 </span><span class="istickedoff">else True</span>
<span class="lineno">  884 </span><span class="spaces">                           </span><span class="istickedoff">| j &lt;- cs</span>
<span class="lineno">  885 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  886 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  887 </span><span class="spaces">               </span><span class="istickedoff">| let as = map (ConstantAbstract . AbsLitTuple) as'</span>
<span class="lineno">  888 </span><span class="spaces">               </span><span class="istickedoff">, let bs = map (ConstantAbstract . AbsLitTuple) bs'</span>
<span class="lineno">  889 </span><span class="spaces">               </span><span class="istickedoff">, let cs = as ++ bs</span>
<span class="lineno">  890 </span><span class="spaces">               </span><span class="istickedoff">, i &lt;- cs</span>
<span class="lineno">  891 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  892 </span><span class="spaces">        </span><span class="istickedoff">tilLt (viewConstantPartition -&gt; Just as')</span>
<span class="lineno">  893 </span><span class="spaces">              </span><span class="istickedoff">(viewConstantPartition -&gt; Just bs') =</span>
<span class="lineno">  894 </span><span class="spaces">            </span><span class="istickedoff">or [ and [ freq i as &lt; freq i bs</span>
<span class="lineno">  895 </span><span class="spaces">                     </span><span class="istickedoff">, and [ if tilLt j i</span>
<span class="lineno">  896 </span><span class="spaces">                                 </span><span class="istickedoff">then freq j as == freq j bs</span>
<span class="lineno">  897 </span><span class="spaces">                                 </span><span class="istickedoff">else True</span>
<span class="lineno">  898 </span><span class="spaces">                           </span><span class="istickedoff">| j &lt;- cs</span>
<span class="lineno">  899 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  900 </span><span class="spaces">                     </span><span class="istickedoff">]</span>
<span class="lineno">  901 </span><span class="spaces">               </span><span class="istickedoff">| let as = map (ConstantAbstract . AbsLitSet) as'</span>
<span class="lineno">  902 </span><span class="spaces">               </span><span class="istickedoff">, let bs = map (ConstantAbstract . AbsLitSet) bs'</span>
<span class="lineno">  903 </span><span class="spaces">               </span><span class="istickedoff">, let cs = as ++ bs</span>
<span class="lineno">  904 </span><span class="spaces">               </span><span class="istickedoff">, i &lt;- cs</span>
<span class="lineno">  905 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  906 </span><span class="spaces">        </span><span class="istickedoff">tilLt a b = <span class="nottickedoff">a &lt; b</span></span></span>
<span class="lineno">  907 </span>
<span class="lineno">  908 </span>ordTildeLt :: Constant -&gt; Constant -&gt; Ordering
<span class="lineno">  909 </span><span class="decl"><span class="istickedoff">ordTildeLt x y =</span>
<span class="lineno">  910 </span><span class="spaces">    </span><span class="istickedoff">case (tildeLt x y, <span class="nottickedoff">tildeLt y x</span>) of</span>
<span class="lineno">  911 </span><span class="spaces">        </span><span class="istickedoff">(True, _) -&gt; LT</span>
<span class="lineno">  912 </span><span class="spaces">        </span><span class="istickedoff">(_, True) -&gt; <span class="nottickedoff">GT</span></span>
<span class="lineno">  913 </span><span class="spaces">        </span><span class="istickedoff">_         -&gt; <span class="nottickedoff">EQ</span></span></span>
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>
<span class="lineno">  916 </span>instance EvaluateOp Op where
<span class="lineno">  917 </span>    <span class="decl"><span class="istickedoff">evaluateOp (MkOpActive x) = evaluateOp x</span>
<span class="lineno">  918 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAllDiff x) = evaluateOp x</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAllDiffExcept x) = evaluateOp x</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAnd x) = evaluateOp x</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpApart x) = evaluateOp x</span>
<span class="lineno">  922 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAtLeast x) = evaluateOp x</span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAtMost x) = evaluateOp x</span>
<span class="lineno">  924 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpAttributeAsConstraint x) = evaluateOp x</span>
<span class="lineno">  925 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpCatchUndef x) = evaluateOp x</span>
<span class="lineno">  926 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpDefined x) = evaluateOp x</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpDiv x) = evaluateOp x</span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpDontCare x) = evaluateOp <span class="nottickedoff">x</span></span>
<span class="lineno">  929 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpDotLeq x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  930 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpDotLt x) = evaluateOp x</span>
<span class="lineno">  931 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpEq x) = evaluateOp x</span>
<span class="lineno">  932 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpFactorial x) = evaluateOp x</span>
<span class="lineno">  933 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpFlatten x) = evaluateOp x</span>
<span class="lineno">  934 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpFreq x) = evaluateOp x</span>
<span class="lineno">  935 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpGCC x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  936 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpGeq x) = evaluateOp x</span>
<span class="lineno">  937 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpGt x) = evaluateOp x</span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpHist x) = evaluateOp x</span>
<span class="lineno">  939 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpIff x) = evaluateOp x</span>
<span class="lineno">  940 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpImage x) = evaluateOp x</span>
<span class="lineno">  941 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpImageSet x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpImply x) = evaluateOp x</span>
<span class="lineno">  943 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpIn x) = evaluateOp x</span>
<span class="lineno">  944 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpIndexing x) = evaluateOp x</span>
<span class="lineno">  945 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpIntersect x) = evaluateOp x</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpInverse x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  947 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpLeq x) = evaluateOp x</span>
<span class="lineno">  948 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpLexLeq x) = evaluateOp x</span>
<span class="lineno">  949 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpLexLt x) = evaluateOp x</span>
<span class="lineno">  950 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpLt x) = evaluateOp x</span>
<span class="lineno">  951 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpMakeTable x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  952 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpMax x) = evaluateOp x</span>
<span class="lineno">  953 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpMin x) = evaluateOp x</span>
<span class="lineno">  954 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpMinus x) = evaluateOp x</span>
<span class="lineno">  955 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpMod x) = evaluateOp x</span>
<span class="lineno">  956 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpNegate x) = evaluateOp x</span>
<span class="lineno">  957 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpNeq x) = evaluateOp x</span>
<span class="lineno">  958 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpNot x) = evaluateOp x</span>
<span class="lineno">  959 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpOr x) = evaluateOp x</span>
<span class="lineno">  960 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpParticipants x) = evaluateOp x</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpParts x) = evaluateOp x</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpParty x) = evaluateOp x</span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpPow x) = evaluateOp x</span>
<span class="lineno">  964 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpPowerSet x) = evaluateOp x</span>
<span class="lineno">  965 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpPred x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  966 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpPreImage x) = evaluateOp x</span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpProduct x) = evaluateOp x</span>
<span class="lineno">  968 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpRange x) = evaluateOp x</span>
<span class="lineno">  969 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpRelationProj x) = evaluateOp x</span>
<span class="lineno">  970 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpRestrict x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  971 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSlicing x) = evaluateOp x</span>
<span class="lineno">  972 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSubsequence x) = evaluateOp x</span>
<span class="lineno">  973 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSubset x) = evaluateOp x</span>
<span class="lineno">  974 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSubsetEq x) = evaluateOp x</span>
<span class="lineno">  975 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSubstring x) = evaluateOp x</span>
<span class="lineno">  976 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSucc x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSum x) = evaluateOp x</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSupset x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpSupsetEq x) = evaluateOp x</span>
<span class="lineno">  980 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTable x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  981 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTildeLeq x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTildeLt x) = evaluateOp x</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTogether x) = evaluateOp x</span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpToInt x) = evaluateOp x</span>
<span class="lineno">  985 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpToMSet x) = evaluateOp x</span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpToRelation x) = evaluateOp x</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpToSet x) = evaluateOp x</span>
<span class="lineno">  988 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTransform x) = <span class="nottickedoff">evaluateOp x</span></span>
<span class="lineno">  989 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTrue x) = evaluateOp <span class="nottickedoff">x</span></span>
<span class="lineno">  990 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpTwoBars x) = evaluateOp x</span>
<span class="lineno">  991 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpUnion x) = evaluateOp x</span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="istickedoff">evaluateOp (MkOpXor x) = <span class="nottickedoff">evaluateOp x</span></span></span>
<span class="lineno">  993 </span>

</pre>
</body>
</html>
