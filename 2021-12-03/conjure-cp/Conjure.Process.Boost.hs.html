<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-
<span class="lineno">    2 </span> - Module      : Conjure.Process.Boost
<span class="lineno">    3 </span> - Description : Strengthen a model using type- and domain-inference.
<span class="lineno">    4 </span> - Copyright   : Billy Brown 2017
<span class="lineno">    5 </span> - License     : BSD3
<span class="lineno">    6 </span>
<span class="lineno">    7 </span> Processing step that attempts to strengthen an Essence model, using methods described in the &quot;Reformulating Essence Specifications for Robustness&quot; paper.
<span class="lineno">    8 </span>-}
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   11 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module Conjure.Process.Boost ( boost ) where
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>import Data.List ( find, union )
<span class="lineno">   16 </span>import Data.Map.Strict ( Map )
<span class="lineno">   17 </span>import qualified Data.Map.Strict as M ( (!?), empty, union )
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>import Conjure.Prelude
<span class="lineno">   20 </span>import Conjure.Language
<span class="lineno">   21 </span>import Conjure.Language.Domain.AddAttributes
<span class="lineno">   22 </span>import Conjure.Language.NameResolution ( resolveNames )
<span class="lineno">   23 </span>-- These two are needed together
<span class="lineno">   24 </span>import Conjure.Language.Expression.DomainSizeOf ()
<span class="lineno">   25 </span>import Conjure.Language.DomainSizeOf ( domainSizeOf )
<span class="lineno">   26 </span>import Conjure.Compute.DomainOf ( domainOf )
<span class="lineno">   27 </span>import Conjure.UI.Model ( evaluateModel )
<span class="lineno">   28 </span>import Conjure.UI.VarSymBreaking ( outputVarSymBreaking )
<span class="lineno">   29 </span>import Conjure.Process.Enumerate ( EnumerateDomain )
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>-- aeson
<span class="lineno">   33 </span>import qualified Data.Aeson as JSON ( decodeStrict )
<span class="lineno">   34 </span>-- shelly
<span class="lineno">   35 </span>import Shelly ( run )
<span class="lineno">   36 </span>-- directory
<span class="lineno">   37 </span>import System.Directory ( removeFile )
<span class="lineno">   38 </span>-- text
<span class="lineno">   39 </span>import qualified Data.Text.Encoding as T ( encodeUtf8 )
<span class="lineno">   40 </span>-- uniplate zipper
<span class="lineno">   41 </span>import Data.Generics.Uniplate.Zipper ( Zipper, zipper, down, fromZipper, hole, replaceHole, right, up )
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>type ExpressionZ = Zipper Expression Expression
<span class="lineno">   44 </span>type FindVar     = (Name, Domain () Expression)
<span class="lineno">   45 </span>type AttrPair    = (AttrName, Maybe Expression)
<span class="lineno">   46 </span>type ToAddToRem  = ([ExpressionZ], [ExpressionZ])
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>-- | Strengthen a model using type- and domain-inference.
<span class="lineno">   49 </span>boost ::
<span class="lineno">   50 </span>    MonadFail m =&gt;
<span class="lineno">   51 </span>    MonadIO m =&gt;
<span class="lineno">   52 </span>    MonadLog m =&gt;
<span class="lineno">   53 </span>    MonadUserError m =&gt;
<span class="lineno">   54 </span>    NameGen m =&gt;
<span class="lineno">   55 </span>    EnumerateDomain m =&gt;
<span class="lineno">   56 </span>    (?typeCheckerMode :: TypeCheckerMode) =&gt;
<span class="lineno">   57 </span>    LogLevel -&gt; -- ^ Log level to use.
<span class="lineno">   58 </span>    Bool -&gt;     -- ^ Generate logs for rule applications.
<span class="lineno">   59 </span>    Model -&gt;    -- ^ Model to strengthen.
<span class="lineno">   60 </span>    m Model  -- ^ Strengthened model.
<span class="lineno">   61 </span><span class="decl"><span class="nottickedoff">boost logLevel logRuleSuccesses = resolveNames &gt;=&gt; return . fixRelationProj &gt;=&gt; core</span>
<span class="lineno">   62 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   63 </span><span class="spaces">    </span><span class="nottickedoff">-- core :: ... =&gt; Model -&gt; m Model</span>
<span class="lineno">   64 </span><span class="spaces">    </span><span class="nottickedoff">core model1 = do</span>
<span class="lineno">   65 </span><span class="spaces">      </span><span class="nottickedoff">-- Apply attribute rules to each decision (find) variable</span>
<span class="lineno">   66 </span><span class="spaces">      </span><span class="nottickedoff">(model2, toAddToRem) &lt;- foldM (\modelAndToKeep findAndCstrs@((n, d), _) -&gt;</span>
<span class="lineno">   67 </span><span class="spaces">          </span><span class="nottickedoff">foldM (\(m1, tatr1) (rule, name) -&gt; do</span>
<span class="lineno">   68 </span><span class="spaces">                  </span><span class="nottickedoff">(attrs, tatr2) &lt;- nested rule m1 findAndCstrs</span>
<span class="lineno">   69 </span><span class="spaces">                  </span><span class="nottickedoff">let m2 = foldr (uncurry3 addAttrsToModel) m1 attrs</span>
<span class="lineno">   70 </span><span class="spaces">                  </span><span class="nottickedoff">when (((not (null attrs) &amp;&amp; m1 /= m2) ||</span>
<span class="lineno">   71 </span><span class="spaces">                         </span><span class="nottickedoff">(tatr2 /= mempty &amp;&amp; toAddRem tatr2 tatr1 /= tatr1)) &amp;&amp;</span>
<span class="lineno">   72 </span><span class="spaces">                        </span><span class="nottickedoff">logRuleSuccesses)</span>
<span class="lineno">   73 </span><span class="spaces">                       </span><span class="nottickedoff">(log logLevel $ name &lt;+&gt; if null attrs</span>
<span class="lineno">   74 </span><span class="spaces">                                                   </span><span class="nottickedoff">then vcat $ map (pretty . hole) (fst tatr2)</span>
<span class="lineno">   75 </span><span class="spaces">                                                   </span><span class="nottickedoff">else pretty n &lt;+&gt; &quot;:&quot; &lt;+&gt; pretty d)</span>
<span class="lineno">   76 </span><span class="spaces">                  </span><span class="nottickedoff">return (m2, toAddRem tatr2 tatr1))</span>
<span class="lineno">   77 </span><span class="spaces">              </span><span class="nottickedoff">modelAndToKeep [ (surjectiveIsTotalBijective, &quot;function marked total and bijective&quot;)</span>
<span class="lineno">   78 </span><span class="spaces">                             </span><span class="nottickedoff">, (totalInjectiveIsBijective,  &quot;function marked bijective&quot;)</span>
<span class="lineno">   79 </span><span class="spaces">                             </span><span class="nottickedoff">, (definedForAllIsTotal,       &quot;function marked total&quot;)</span>
<span class="lineno">   80 </span><span class="spaces">                             </span><span class="nottickedoff">, (diffArgResultIsInjective,   &quot;function marked injective&quot;)</span>
<span class="lineno">   81 </span><span class="spaces">                             </span><span class="nottickedoff">, (varSize,                    &quot;added or refined domain size attribute&quot;)</span>
<span class="lineno">   82 </span><span class="spaces">                             </span><span class="nottickedoff">, (setSize,                    &quot;added or refined set domain size attribute&quot;)</span>
<span class="lineno">   83 </span><span class="spaces">                             </span><span class="nottickedoff">, (mSetSizeOccur,              &quot;added or refined multiset occurrence attribute&quot;)</span>
<span class="lineno">   84 </span><span class="spaces">                             </span><span class="nottickedoff">, (mSetOccur,                  &quot;added or refined multiset occurrence attribute&quot;)</span>
<span class="lineno">   85 </span><span class="spaces">                             </span><span class="nottickedoff">, (partRegular,                &quot;marked partition regular&quot;)</span>
<span class="lineno">   86 </span><span class="spaces">                             </span><span class="nottickedoff">, (numPartsToAttr,             &quot;added or refined partition domain numParts attribute&quot;)</span>
<span class="lineno">   87 </span><span class="spaces">                             </span><span class="nottickedoff">, (partSizeToAttr,             &quot;added or refined partition domain partSize attribute&quot;)</span>
<span class="lineno">   88 </span><span class="spaces">                             </span><span class="nottickedoff">, (funcRangeEqSet,             &quot;equated function range and set&quot;)</span>
<span class="lineno">   89 </span><span class="spaces">                             </span><span class="nottickedoff">, (forAllIneqToIneqSum,        &quot;lifted arithmetic relation from two forAlls to a sum&quot;)</span>
<span class="lineno">   90 </span><span class="spaces">                             </span><span class="nottickedoff">, (fasterIteration,            &quot;refined distinctness condition on forAll&quot;)</span>
<span class="lineno">   91 </span><span class="spaces">                             </span><span class="nottickedoff">])</span>
<span class="lineno">   92 </span><span class="spaces">          </span><span class="nottickedoff">(model1, ([], []))</span>
<span class="lineno">   93 </span><span class="spaces">          </span><span class="nottickedoff">(zip (collectFindVariables model1)</span>
<span class="lineno">   94 </span><span class="spaces">               </span><span class="nottickedoff">(repeat $ map zipper $ collectConstraints model1))</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">   96 </span><span class="spaces">      </span><span class="nottickedoff">-- Apply constraint additions and removals</span>
<span class="lineno">   97 </span><span class="spaces">      </span><span class="nottickedoff">model3' &lt;- resolveNames $</span>
<span class="lineno">   98 </span><span class="spaces">                 </span><span class="nottickedoff">addConstraints (fst toAddToRem) $</span>
<span class="lineno">   99 </span><span class="spaces">                 </span><span class="nottickedoff">remConstraints (snd toAddToRem) model2</span>
<span class="lineno">  100 </span><span class="spaces">      </span><span class="nottickedoff">model3  &lt;- evaluateModel model3'</span>
<span class="lineno">  101 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  102 </span><span class="spaces">      </span><span class="nottickedoff">-- Apply type change rules to each decision (find) variable</span>
<span class="lineno">  103 </span><span class="spaces">      </span><span class="nottickedoff">(model4, toAddToRem') &lt;- foldM (\modelAndToKeep findAndCstrs@((n, d), _) -&gt;</span>
<span class="lineno">  104 </span><span class="spaces">          </span><span class="nottickedoff">foldM (\(m1, tatr1) (rule, name) -&gt; do</span>
<span class="lineno">  105 </span><span class="spaces">                  </span><span class="nottickedoff">(dom, tatr2) &lt;- rule m1 findAndCstrs</span>
<span class="lineno">  106 </span><span class="spaces">                  </span><span class="nottickedoff">when ((dom /= d || toAddRem tatr2 tatr1 /= tatr1) &amp;&amp;</span>
<span class="lineno">  107 </span><span class="spaces">                        </span><span class="nottickedoff">logRuleSuccesses)</span>
<span class="lineno">  108 </span><span class="spaces">                       </span><span class="nottickedoff">(log logLevel $ name &lt;+&gt; pretty n &lt;+&gt; &quot;:&quot; &lt;+&gt; pretty d)</span>
<span class="lineno">  109 </span><span class="spaces">                  </span><span class="nottickedoff">return (updateDecl (n, dom) m1, toAddRem tatr2 tatr1))</span>
<span class="lineno">  110 </span><span class="spaces">              </span><span class="nottickedoff">modelAndToKeep [ (mSetToSet, &quot;multiset changed to set&quot;)</span>
<span class="lineno">  111 </span><span class="spaces">                             </span><span class="nottickedoff">-- , (relationToFunction, &quot;relation to function&quot;)</span>
<span class="lineno">  112 </span><span class="spaces">                             </span><span class="nottickedoff">])</span>
<span class="lineno">  113 </span><span class="spaces">          </span><span class="nottickedoff">(model3, ([], []))</span>
<span class="lineno">  114 </span><span class="spaces">          </span><span class="nottickedoff">(zip (collectFindVariables model3)</span>
<span class="lineno">  115 </span><span class="spaces">               </span><span class="nottickedoff">(repeat $ map zipper $ collectConstraints model3))</span>
<span class="lineno">  116 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  117 </span><span class="spaces">      </span><span class="nottickedoff">-- Apply constraint additions and removals</span>
<span class="lineno">  118 </span><span class="spaces">      </span><span class="nottickedoff">model5' &lt;- resolveNames $</span>
<span class="lineno">  119 </span><span class="spaces">                 </span><span class="nottickedoff">addConstraints (fst toAddToRem') $</span>
<span class="lineno">  120 </span><span class="spaces">                 </span><span class="nottickedoff">remConstraints (snd toAddToRem') model4</span>
<span class="lineno">  121 </span><span class="spaces">      </span><span class="nottickedoff">model5  &lt;- evaluateModel model5'</span>
<span class="lineno">  122 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  123 </span><span class="spaces">      </span><span class="nottickedoff">-- Make another pass if the model was updated, but stop if it contains machine names</span>
<span class="lineno">  124 </span><span class="spaces">      </span><span class="nottickedoff">if model1 == model5 || any containsMachineName (collectConstraints model5)</span>
<span class="lineno">  125 </span><span class="spaces">         </span><span class="nottickedoff">then return model5</span>
<span class="lineno">  126 </span><span class="spaces">         </span><span class="nottickedoff">else core model5</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="nottickedoff">-- Does an expression contain a reference with a machine name?</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="nottickedoff">containsMachineName = any isMachineName . universe</span>
<span class="lineno">  129 </span><span class="spaces">    </span><span class="nottickedoff">isMachineName (Reference MachineName{} _) = True</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="nottickedoff">isMachineName _                           = False</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- | 'uncurry' for functions of three arguments and triples.
<span class="lineno">  133 </span>uncurry3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; ((a, b, c) -&gt; d)
<span class="lineno">  134 </span><span class="decl"><span class="nottickedoff">uncurry3 f (x, y, z) = f x y z</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- | Collect decision (find) variables from a model, returning their name and domain.
<span class="lineno">  137 </span>collectFindVariables :: Model -&gt; [FindVar]
<span class="lineno">  138 </span><span class="decl"><span class="nottickedoff">collectFindVariables = mapMaybe collectFind . mStatements</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  140 </span><span class="spaces">    </span><span class="nottickedoff">collectFind (Declaration (FindOrGiven Find n d)) = Just (n, d)</span>
<span class="lineno">  141 </span><span class="spaces">    </span><span class="nottickedoff">collectFind _                                    = Nothing</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | Collect the constraints in a model.
<span class="lineno">  144 </span>collectConstraints :: Model -&gt; [Expression]
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">collectConstraints = concatMap getSuchThat . mStatements</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="nottickedoff">getSuchThat (SuchThat cs) = cs</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="nottickedoff">getSuchThat _             = []</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>-- | Add constraints to a model.
<span class="lineno">  151 </span>addConstraints :: [ExpressionZ] -&gt; Model -&gt; Model
<span class="lineno">  152 </span><span class="decl"><span class="nottickedoff">addConstraints [] m = m</span>
<span class="lineno">  153 </span><span class="spaces"></span><span class="nottickedoff">addConstraints cs m@Model { mStatements = stmts }</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="nottickedoff">= m { mStatements = addConstraints' stmts }</span>
<span class="lineno">  155 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="nottickedoff">addConstraints' (SuchThat cs':ss) = SuchThat (cs' `union` map fromZipper cs) : ss</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="nottickedoff">addConstraints' (s:ss)            = s : addConstraints' ss</span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="nottickedoff">addConstraints' []                = [SuchThat (map fromZipper cs)]</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Remove a list of constraints from a model.
<span class="lineno">  161 </span>remConstraints :: [ExpressionZ] -&gt; Model -&gt; Model
<span class="lineno">  162 </span><span class="decl"><span class="nottickedoff">remConstraints cs m@Model { mStatements = stmts }</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="nottickedoff">= m { mStatements = filter (not . emptySuchThat) $ map remConstraints' stmts }</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="nottickedoff">remConstraints' (SuchThat cs') = SuchThat $ filter (`notElem` map fromZipper cs) cs'</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="nottickedoff">remConstraints' s              = s</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="nottickedoff">emptySuchThat (SuchThat []) = True</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="nottickedoff">emptySuchThat _             = False</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- | Update the domain of a declaration in a model.
<span class="lineno">  171 </span>updateDecl :: FindVar -&gt; Model -&gt; Model
<span class="lineno">  172 </span><span class="decl"><span class="nottickedoff">updateDecl (n, d) m@Model { mStatements = stmts } = m { mStatements = map updateDecl' stmts }</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="nottickedoff">updateDecl' (Declaration (FindOrGiven Find n' _))</span>
<span class="lineno">  175 </span><span class="spaces">      </span><span class="nottickedoff">| n == n' = Declaration (FindOrGiven Find n d)</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="nottickedoff">updateDecl' decl = decl</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Try adding an attribute at a given depth of a variable's domain, in a model.
<span class="lineno">  179 </span>addAttrsToModel :: FindVar -&gt; Int -&gt; [AttrPair] -&gt; Model -&gt; Model
<span class="lineno">  180 </span><span class="decl"><span class="nottickedoff">addAttrsToModel (n, _) depth attrs m</span>
<span class="lineno">  181 </span><span class="spaces">  </span><span class="nottickedoff">= let d = snd &lt;$&gt; find (\(n', _) -&gt; n == n') (collectFindVariables m)</span>
<span class="lineno">  182 </span><span class="spaces">        </span><span class="nottickedoff">in case d &gt;&gt;= flip (addAttrsToDomain depth) attrs of</span>
<span class="lineno">  183 </span><span class="spaces">                </span><span class="nottickedoff">Just d' -&gt; updateDecl (n, d') m</span>
<span class="lineno">  184 </span><span class="spaces">                </span><span class="nottickedoff">Nothing -&gt; m</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain :: (MonadFail m) =&gt; Int -&gt; Domain () Expression -&gt; [AttrPair] -&gt; m (Domain () Expression)</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain 0 dom = addAttributesToDomain dom . map mkAttr</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainSet r as inner)           = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainSet r as)</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainMSet r as inner)          = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainMSet r as)</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainMatrix index inner)       = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainMatrix index)</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainFunction r as from inner) = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainFunction r as from)</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainSequence r as inner) = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainSequence r as)</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain level (DomainPartition r as inner)     = addAttrsToDomain (level - 1) inner &gt;=&gt; (pure . DomainPartition r as)</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="nottickedoff">addAttrsToDomain _ _ = const (fail &quot;[addAttrsToDomain] not a supported nested domain&quot;)</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="nottickedoff">-- Special treatment for functions</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="nottickedoff">mkAttr (attr, Just [essence| image(&amp;f, &amp;_) |])     = (attr, Just [essence| max(range(&amp;f)) |])</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="nottickedoff">mkAttr (attr, Just [essence| image(&amp;f, &amp;_) - 1 |]) = (attr, Just [essence| max(range(&amp;f)) - 1 |])</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="nottickedoff">mkAttr (attr, Just [essence| image(&amp;f, &amp;_) + 1 |]) = (attr, Just [essence| max(range(&amp;f)) + 1 |])</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="nottickedoff">mkAttr (attr, e')                                  = (attr, e')</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>-- | Does an expression directly reference a given name variable?
<span class="lineno">  202 </span>nameExpEq :: Name -&gt; Expression -&gt; Bool
<span class="lineno">  203 </span><span class="decl"><span class="nottickedoff">nameExpEq n (Reference n' _)           = n == n'</span>
<span class="lineno">  204 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq n [essence| image(&amp;f, &amp;x) |] = nameExpEq n f || nameExpEq n x</span>
<span class="lineno">  205 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq n [essence| &amp;f(&amp;x) |]        = nameExpEq n f || nameExpEq n x</span>
<span class="lineno">  206 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq n [essence| defined(&amp;f) |]   = nameExpEq n f</span>
<span class="lineno">  207 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq n [essence| range(&amp;f) |]     = nameExpEq n f</span>
<span class="lineno">  208 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq n [essence| |&amp;x| |]          = nameExpEq n x</span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="nottickedoff">nameExpEq _ _                          = False</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | Does a reference refer to an abstract pattern?
<span class="lineno">  212 </span>refersTo :: Expression -&gt; AbstractPattern -&gt; Bool
<span class="lineno">  213 </span><span class="decl"><span class="nottickedoff">refersTo (Reference n _) a = n `elem` namesFromAbstractPattern a</span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="nottickedoff">refersTo _ _               = False</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | Get a single name from an abstract pattern.
<span class="lineno">  217 </span>nameFromAbstractPattern :: (MonadFail m) =&gt; AbstractPattern -&gt; m Name
<span class="lineno">  218 </span><span class="decl"><span class="nottickedoff">nameFromAbstractPattern a = case namesFromAbstractPattern a of</span>
<span class="lineno">  219 </span><span class="spaces">                                 </span><span class="nottickedoff">[n] -&gt; pure n</span>
<span class="lineno">  220 </span><span class="spaces">                                 </span><span class="nottickedoff">[]  -&gt; fail &quot;[nameFromAbstractPattern] no names in abstract pattern&quot;</span>
<span class="lineno">  221 </span><span class="spaces">                                 </span><span class="nottickedoff">_   -&gt; fail &quot;[nameFromAbstractPattern] more than one name in abstract pattern&quot;</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>-- | Get the list of names from an abstract pattern.
<span class="lineno">  224 </span>namesFromAbstractPattern :: AbstractPattern -&gt; [Name]
<span class="lineno">  225 </span><span class="decl"><span class="nottickedoff">namesFromAbstractPattern (Single n)        = [n]</span>
<span class="lineno">  226 </span><span class="spaces"></span><span class="nottickedoff">namesFromAbstractPattern (AbsPatTuple ns)  = concatMap namesFromAbstractPattern ns</span>
<span class="lineno">  227 </span><span class="spaces"></span><span class="nottickedoff">namesFromAbstractPattern (AbsPatMatrix ns) = concatMap namesFromAbstractPattern ns</span>
<span class="lineno">  228 </span><span class="spaces"></span><span class="nottickedoff">namesFromAbstractPattern (AbsPatSet ns)    = concatMap namesFromAbstractPattern ns</span>
<span class="lineno">  229 </span><span class="spaces"></span><span class="nottickedoff">namesFromAbstractPattern _                 = []</span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | Get the list of names from a generator.
<span class="lineno">  232 </span>namesFromGenerator :: Generator -&gt; [Name]
<span class="lineno">  233 </span><span class="decl"><span class="nottickedoff">namesFromGenerator (GenDomainNoRepr a _)  = namesFromAbstractPattern a</span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="nottickedoff">namesFromGenerator (GenDomainHasRepr n _) = [n]</span>
<span class="lineno">  235 </span><span class="spaces"></span><span class="nottickedoff">namesFromGenerator (GenInExpr a _)        = namesFromAbstractPattern a</span></span>
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>-- | Find an expression at any depth of unconditional forAll expressions.
<span class="lineno">  238 </span>findInUncondForAll :: (Expression -&gt; Bool) -&gt; [ExpressionZ] -&gt; [Expression]
<span class="lineno">  239 </span><span class="decl"><span class="nottickedoff">findInUncondForAll p = map hole . findInUncondForAllZ p</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>-- | Find an expression at any depth of unconditional forAll expressions,
<span class="lineno">  242 </span>--   returning a Zipper containing the expression's context.
<span class="lineno">  243 </span>findInUncondForAllZ :: (Expression -&gt; Bool) -&gt; [ExpressionZ] -&gt; [ExpressionZ]
<span class="lineno">  244 </span><span class="decl"><span class="nottickedoff">findInUncondForAllZ p = concatMap findInForAll</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="nottickedoff">findInForAll z | p (hole z) = [z]</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="nottickedoff">findInForAll z</span>
<span class="lineno">  248 </span><span class="spaces">      </span><span class="nottickedoff">= case hole z of</span>
<span class="lineno">  249 </span><span class="spaces">             </span><span class="nottickedoff">[essence| forAll &amp;_ in defined(&amp;_) . &amp;_ |]</span>
<span class="lineno">  250 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; []</span>
<span class="lineno">  251 </span><span class="spaces">             </span><span class="nottickedoff">[essence| forAll &amp;x, &amp;y : &amp;_, &amp;x' != &amp;y' . &amp;_ |]</span>
<span class="lineno">  252 </span><span class="spaces">               </span><span class="nottickedoff">| x' `refersTo` x &amp;&amp; y' `refersTo` y</span>
<span class="lineno">  253 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; maybe [] findInForAll (down z &gt;&gt;= down)</span>
<span class="lineno">  254 </span><span class="spaces">             </span><span class="nottickedoff">[essence| forAll &amp;x, &amp;y in &amp;_, &amp;x' != &amp;y' . &amp;_ |]</span>
<span class="lineno">  255 </span><span class="spaces">               </span><span class="nottickedoff">| x' `refersTo` x &amp;&amp; y' `refersTo` y</span>
<span class="lineno">  256 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; maybe [] findInForAll (down z &gt;&gt;= down)</span>
<span class="lineno">  257 </span><span class="spaces">             </span><span class="nottickedoff">Op (MkOpAnd (OpAnd (Comprehension _ gorcs)))</span>
<span class="lineno">  258 </span><span class="spaces">               </span><span class="nottickedoff">| all (not . isCondition) gorcs</span>
<span class="lineno">  259 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; maybe [] findInForAll (down z &gt;&gt;= down)</span>
<span class="lineno">  260 </span><span class="spaces">             </span><span class="nottickedoff">[essence| &amp;_ /\ &amp;_ |]</span>
<span class="lineno">  261 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; maybe [] findInForAll (down z)</span>
<span class="lineno">  262 </span><span class="spaces">                    </span><span class="nottickedoff">`union`</span>
<span class="lineno">  263 </span><span class="spaces">                    </span><span class="nottickedoff">maybe [] findInForAll (right z &gt;&gt;= down)</span>
<span class="lineno">  264 </span><span class="spaces">             </span><span class="nottickedoff">-- Only accept OR cases if both sides contain a match</span>
<span class="lineno">  265 </span><span class="spaces">             </span><span class="nottickedoff">[essence| &amp;_ \/ &amp;_ |]</span>
<span class="lineno">  266 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; let leftResult  = maybe [] findInForAll (down z)</span>
<span class="lineno">  267 </span><span class="spaces">                        </span><span class="nottickedoff">rightResult = maybe [] findInForAll (right z &gt;&gt;= down)</span>
<span class="lineno">  268 </span><span class="spaces">                        </span><span class="nottickedoff">in if not (null leftResult) &amp;&amp; not (null rightResult)</span>
<span class="lineno">  269 </span><span class="spaces">                              </span><span class="nottickedoff">then leftResult `union` rightResult</span>
<span class="lineno">  270 </span><span class="spaces">                              </span><span class="nottickedoff">else []</span>
<span class="lineno">  271 </span><span class="spaces">             </span><span class="nottickedoff">_   -&gt; []</span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="nottickedoff">isCondition Condition{} = True</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="nottickedoff">isCondition _           = False</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | Lens function over a binary expression.
<span class="lineno">  276 </span>type BinExprLens m = Proxy m -&gt; (Expression -&gt; Expression -&gt; Expression,
<span class="lineno">  277 </span>                                 Expression -&gt; m (Expression, Expression))
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>-- | Get the lens for an expression and the values it matches.
<span class="lineno">  280 </span>matching :: Expression
<span class="lineno">  281 </span>         -&gt; [(BinExprLens Maybe, a)]
<span class="lineno">  282 </span>         -&gt; Maybe (a, (Expression, Expression))
<span class="lineno">  283 </span><span class="decl"><span class="nottickedoff">matching e ops = case mapMaybe (\(f1, f2) -&gt; (,) f2 &lt;$&gt; match f1 e) ops of</span>
<span class="lineno">  284 </span><span class="spaces">                      </span><span class="nottickedoff">[x] -&gt; pure x</span>
<span class="lineno">  285 </span><span class="spaces">                      </span><span class="nottickedoff">_   -&gt; fail $ &quot;no matching operator for expression:&quot; &lt;+&gt; pretty e</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>-- | (In)equality operator lens pairs.
<span class="lineno">  288 </span>ineqOps :: [(BinExprLens Maybe, BinExprLens Identity)]
<span class="lineno">  289 </span><span class="decl"><span class="nottickedoff">ineqOps = [ (opEq,  opEq)</span>
<span class="lineno">  290 </span><span class="spaces">          </span><span class="nottickedoff">, (opLt,  opLt)</span>
<span class="lineno">  291 </span><span class="spaces">          </span><span class="nottickedoff">, (opLeq, opLeq)</span>
<span class="lineno">  292 </span><span class="spaces">          </span><span class="nottickedoff">, (opGt,  opGt)</span>
<span class="lineno">  293 </span><span class="spaces">          </span><span class="nottickedoff">, (opGeq, opGeq)</span>
<span class="lineno">  294 </span><span class="spaces">          </span><span class="nottickedoff">]</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Opposites of (in)equality operator lens pairs.
<span class="lineno">  297 </span>oppIneqOps :: [(BinExprLens Maybe, BinExprLens Identity)]
<span class="lineno">  298 </span><span class="decl"><span class="nottickedoff">oppIneqOps = [ (opEq, opEq)</span>
<span class="lineno">  299 </span><span class="spaces">             </span><span class="nottickedoff">, (opLt, opGt)</span>
<span class="lineno">  300 </span><span class="spaces">             </span><span class="nottickedoff">, (opLeq, opGeq)</span>
<span class="lineno">  301 </span><span class="spaces">             </span><span class="nottickedoff">, (opGt, opLt)</span>
<span class="lineno">  302 </span><span class="spaces">             </span><span class="nottickedoff">, (opGeq, opLeq)</span>
<span class="lineno">  303 </span><span class="spaces">             </span><span class="nottickedoff">]</span></span>
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- | (In)equality operator to size attribute modifier pairs.
<span class="lineno">  306 </span>ineqSizeAttrs :: [(BinExprLens Maybe, (AttrName, Expression -&gt; Maybe Expression))]
<span class="lineno">  307 </span><span class="decl"><span class="nottickedoff">ineqSizeAttrs = [ (opEq,  (&quot;size&quot;,    Just))</span>
<span class="lineno">  308 </span><span class="spaces">                </span><span class="nottickedoff">, (opLt,  (&quot;maxSize&quot;, Just . \x -&gt; x - 1))</span>
<span class="lineno">  309 </span><span class="spaces">                </span><span class="nottickedoff">, (opLeq, (&quot;maxSize&quot;, Just))</span>
<span class="lineno">  310 </span><span class="spaces">                </span><span class="nottickedoff">, (opGt,  (&quot;minSize&quot;, Just . (+ 1)))</span>
<span class="lineno">  311 </span><span class="spaces">                </span><span class="nottickedoff">, (opGeq, (&quot;minSize&quot;, Just))</span>
<span class="lineno">  312 </span><span class="spaces">                </span><span class="nottickedoff">]</span></span>
<span class="lineno">  313 </span>
<span class="lineno">  314 </span>-- | (In)equality operator to size attribute modifier pairs.
<span class="lineno">  315 </span>ineqOccurAttrs :: [(BinExprLens Maybe, [(AttrName, Expression -&gt; Maybe Expression)])]
<span class="lineno">  316 </span><span class="decl"><span class="nottickedoff">ineqOccurAttrs = [ (opEq,  [ (&quot;minOccur&quot;, Just), (&quot;maxOccur&quot;, Just) ])</span>
<span class="lineno">  317 </span><span class="spaces">                 </span><span class="nottickedoff">, (opLt,  [ (&quot;maxOccur&quot;, Just . \x -&gt; x - 1) ])</span>
<span class="lineno">  318 </span><span class="spaces">                 </span><span class="nottickedoff">, (opLeq, [ (&quot;maxOccur&quot;, Just) ])</span>
<span class="lineno">  319 </span><span class="spaces">                 </span><span class="nottickedoff">, (opGt,  [ (&quot;minOccur&quot;, Just . (+ 1)) ])</span>
<span class="lineno">  320 </span><span class="spaces">                 </span><span class="nottickedoff">, (opGeq, [ (&quot;minOccur&quot;, Just) ])</span>
<span class="lineno">  321 </span><span class="spaces">                 </span><span class="nottickedoff">]</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>-- | Unzip where the key is a 'Maybe' but the values should all be combined.
<span class="lineno">  324 </span>unzipMaybeK :: Monoid m =&gt; [(Maybe a, m)] -&gt; ([a], m)
<span class="lineno">  325 </span><span class="decl"><span class="nottickedoff">unzipMaybeK = foldr (\(mx, y) (xs, z) -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">                     </span><span class="nottickedoff">case mx of</span>
<span class="lineno">  327 </span><span class="spaces">                          </span><span class="nottickedoff">Just x  -&gt; (x:xs, y `mappend` z)</span>
<span class="lineno">  328 </span><span class="spaces">                          </span><span class="nottickedoff">Nothing -&gt; (  xs, y `mappend` z))</span>
<span class="lineno">  329 </span><span class="spaces">              </span><span class="nottickedoff">([], mempty)</span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>-- | Does an expression contain a find variable?
<span class="lineno">  332 </span>isFind :: Expression -&gt; Bool
<span class="lineno">  333 </span><span class="decl"><span class="nottickedoff">isFind (Reference _ (Just (DeclNoRepr  Find _ _ _))) = True</span>
<span class="lineno">  334 </span><span class="spaces"></span><span class="nottickedoff">isFind (Reference _ (Just (DeclHasRepr Find _ _)))   = True</span>
<span class="lineno">  335 </span><span class="spaces"></span><span class="nottickedoff">isFind Reference{}                                   = False</span>
<span class="lineno">  336 </span><span class="spaces"></span><span class="nottickedoff">isFind Constant{}                                    = False</span>
<span class="lineno">  337 </span><span class="spaces"></span><span class="nottickedoff">isFind [essence| &amp;f(&amp;_) |]                           = isFind f</span>
<span class="lineno">  338 </span><span class="spaces"></span><span class="nottickedoff">isFind [essence| image(&amp;f, &amp;_) |]                    = isFind f</span>
<span class="lineno">  339 </span><span class="spaces"></span><span class="nottickedoff">isFind e                                             = any isFind $ children e</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Add expressions to the ToAdd list.
<span class="lineno">  342 </span>toAdd :: [ExpressionZ] -&gt; ToAddToRem -&gt; ToAddToRem
<span class="lineno">  343 </span><span class="decl"><span class="nottickedoff">toAdd e = first (`union` e)</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>-- | Add expressions to the ToRemove list.
<span class="lineno">  346 </span>toRem :: [ExpressionZ] -&gt; ToAddToRem -&gt; ToAddToRem
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">toRem e = second (`union` e)</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>-- | Combine two 'ToAddToRem' values.
<span class="lineno">  350 </span>toAddRem :: ToAddToRem -&gt; ToAddToRem -&gt; ToAddToRem
<span class="lineno">  351 </span><span class="decl"><span class="nottickedoff">toAddRem (ta, tr) = toAdd ta . toRem tr</span></span>
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>-- | Apply a rule to arbitrary levels of nested domains.
<span class="lineno">  354 </span>nested :: (MonadFail m, MonadLog m, NameGen m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  355 </span>       =&gt; (Model -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  356 </span>                 -&gt; m ([AttrPair], ToAddToRem))
<span class="lineno">  357 </span>       -&gt; Model
<span class="lineno">  358 </span>       -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  359 </span>       -&gt; m ([(FindVar, Int, [AttrPair])], ToAddToRem)
<span class="lineno">  360 </span><span class="decl"><span class="nottickedoff">nested rule m fc@(fv, cs) = do</span>
<span class="lineno">  361 </span><span class="spaces">  </span><span class="nottickedoff">-- Apply the rule at the top level</span>
<span class="lineno">  362 </span><span class="spaces">  </span><span class="nottickedoff">(attrs, toAddToRem) &lt;- rule m fc</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="nottickedoff">-- Look deeper into the domain if possible, for forAll constraints involving it</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="nottickedoff">nestedResults &lt;- fmap mconcat $ forM cs $ \c -&gt;</span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="nottickedoff">case hole c of</span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in &amp;gen . &amp;_ |] | nameExpEq (fst fv) gen -&gt;</span>
<span class="lineno">  367 </span><span class="spaces">           </span><span class="nottickedoff">-- Create the new decision variable at this level</span>
<span class="lineno">  368 </span><span class="spaces">           </span><span class="nottickedoff">case (,) &lt;$&gt; nameFromAbstractPattern x</span>
<span class="lineno">  369 </span><span class="spaces">                    </span><span class="nottickedoff">&lt;*&gt; (domainOf gen &gt;&gt;= innerDomainOf) of</span>
<span class="lineno">  370 </span><span class="spaces">                </span><span class="nottickedoff">Left  _   -&gt; return mempty</span>
<span class="lineno">  371 </span><span class="spaces">                </span><span class="nottickedoff">Right fv' -&gt; do</span>
<span class="lineno">  372 </span><span class="spaces">                            </span><span class="nottickedoff">-- Apply the rule from here</span>
<span class="lineno">  373 </span><span class="spaces">                            </span><span class="nottickedoff">out &lt;- nested rule m (fv', mapMaybe (down &gt;=&gt; down) [c])</span>
<span class="lineno">  374 </span><span class="spaces">                            </span><span class="nottickedoff">case out of</span>
<span class="lineno">  375 </span><span class="spaces">                                 </span><span class="nottickedoff">([], _)     -&gt; return mempty</span>
<span class="lineno">  376 </span><span class="spaces">                                 </span><span class="nottickedoff">-- The rule was applied, so unwrap the variable and increase the depth</span>
<span class="lineno">  377 </span><span class="spaces">                                 </span><span class="nottickedoff">(vs, tatr') -&gt; return ( [ (fv, d + 1, as) | (_, d, as) &lt;- vs ]</span>
<span class="lineno">  378 </span><span class="spaces">                                                       </span><span class="nottickedoff">, tatr')</span>
<span class="lineno">  379 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return mempty</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="nottickedoff">-- Do not add a modification if there are no attributes</span>
<span class="lineno">  381 </span><span class="spaces">  </span><span class="nottickedoff">let attrs' = if null attrs then [] else [(fv, 0, attrs)]</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="nottickedoff">return $ mappend nestedResults (attrs', toAddToRem)</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>-- | If a function is surjective or bijective, and its domain and codomain
<span class="lineno">  385 </span>--   are of equal size, then it is total and bijective.
<span class="lineno">  386 </span>surjectiveIsTotalBijective :: (MonadFail m, MonadLog m)
<span class="lineno">  387 </span>                           =&gt; Model
<span class="lineno">  388 </span>                           -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  389 </span>                           -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  390 </span><span class="decl"><span class="nottickedoff">surjectiveIsTotalBijective _ ((_, dom), _)</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="nottickedoff">= case dom of</span>
<span class="lineno">  392 </span><span class="spaces">         </span><span class="nottickedoff">DomainFunction _ (FunctionAttr _ p j) from to</span>
<span class="lineno">  393 </span><span class="spaces">           </span><span class="nottickedoff">| (p == PartialityAttr_Partial &amp;&amp; j == JectivityAttr_Bijective) ||</span>
<span class="lineno">  394 </span><span class="spaces">             </span><span class="nottickedoff">j == JectivityAttr_Surjective -&gt; do</span>
<span class="lineno">  395 </span><span class="spaces">               </span><span class="nottickedoff">(fromSize, toSize) &lt;- functionDomainSizes from to</span>
<span class="lineno">  396 </span><span class="spaces">               </span><span class="nottickedoff">if fromSize == toSize</span>
<span class="lineno">  397 </span><span class="spaces">                  </span><span class="nottickedoff">then return ([(&quot;total&quot;, Nothing), (&quot;bijective&quot;, Nothing)], mempty)</span>
<span class="lineno">  398 </span><span class="spaces">                  </span><span class="nottickedoff">else return mempty</span>
<span class="lineno">  399 </span><span class="spaces">         </span><span class="nottickedoff">DomainSequence _ (SequenceAttr (SizeAttr_Size s ) j) to</span>
<span class="lineno">  400 </span><span class="spaces">           </span><span class="nottickedoff">| j `elem` [JectivityAttr_Bijective, JectivityAttr_Surjective] -&gt; do</span>
<span class="lineno">  401 </span><span class="spaces">               </span><span class="nottickedoff">toSize &lt;- domainSizeOf to</span>
<span class="lineno">  402 </span><span class="spaces">               </span><span class="nottickedoff">if s == toSize</span>
<span class="lineno">  403 </span><span class="spaces">                  </span><span class="nottickedoff">then return ([(&quot;bijective&quot;, Nothing)], mempty)</span>
<span class="lineno">  404 </span><span class="spaces">                  </span><span class="nottickedoff">else return mempty</span>
<span class="lineno">  405 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return mempty</span></span>
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>-- | Calculate the sizes of the domain and codomain of a function.
<span class="lineno">  408 </span>functionDomainSizes :: (MonadFail m)
<span class="lineno">  409 </span>                    =&gt; Domain () Expression       -- ^ The function's domain.
<span class="lineno">  410 </span>                    -&gt; Domain () Expression       -- ^ The function's codomain.
<span class="lineno">  411 </span>                    -&gt; m (Expression, Expression) -- ^ The sizes of the two.
<span class="lineno">  412 </span><span class="decl"><span class="nottickedoff">functionDomainSizes from to = (,) &lt;$&gt; domainSizeOf from &lt;*&gt; domainSizeOf to</span></span>
<span class="lineno">  413 </span>
<span class="lineno">  414 </span>-- | If a function is total and injective, and its domain and codomain
<span class="lineno">  415 </span>--   are of equal size, then it is bijective.
<span class="lineno">  416 </span>totalInjectiveIsBijective :: (MonadFail m, MonadLog m)
<span class="lineno">  417 </span>                          =&gt; Model
<span class="lineno">  418 </span>                          -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  419 </span>                          -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  420 </span><span class="decl"><span class="nottickedoff">totalInjectiveIsBijective _ ((_, dom), _)</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">= case dom of</span>
<span class="lineno">  422 </span><span class="spaces">         </span><span class="nottickedoff">DomainFunction _ (FunctionAttr _ PartialityAttr_Total JectivityAttr_Injective) from to -&gt; do</span>
<span class="lineno">  423 </span><span class="spaces">           </span><span class="nottickedoff">(fromSize, toSize) &lt;- functionDomainSizes from to</span>
<span class="lineno">  424 </span><span class="spaces">           </span><span class="nottickedoff">if fromSize == toSize</span>
<span class="lineno">  425 </span><span class="spaces">              </span><span class="nottickedoff">then return ([(&quot;bijective&quot;, Nothing)], mempty)</span>
<span class="lineno">  426 </span><span class="spaces">              </span><span class="nottickedoff">else return mempty</span>
<span class="lineno">  427 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return mempty</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>-- | If a function is defined for all values in its domain, then it is total.
<span class="lineno">  430 </span>definedForAllIsTotal :: (MonadFail m, MonadLog m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  431 </span>                     =&gt; Model
<span class="lineno">  432 </span>                     -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  433 </span>                     -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  434 </span><span class="decl"><span class="nottickedoff">definedForAllIsTotal _ ((n, dom), cs)</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="nottickedoff">-- Is the function called with parameters generated from its domain in an expression?</span>
<span class="lineno">  436 </span><span class="spaces">  </span><span class="nottickedoff">= let definedIn from e = any (funcCalledWithGenParams from) (children e)</span>
<span class="lineno">  437 </span><span class="spaces">        </span><span class="nottickedoff">in case dom of</span>
<span class="lineno">  438 </span><span class="spaces">                </span><span class="nottickedoff">DomainFunction _ (FunctionAttr _ PartialityAttr_Partial _) from _</span>
<span class="lineno">  439 </span><span class="spaces">                  </span><span class="nottickedoff">| any (definedIn from) $ findInUncondForAll isOp cs</span>
<span class="lineno">  440 </span><span class="spaces">                    </span><span class="nottickedoff">-&gt; return ([(&quot;total&quot;, Nothing)], mempty)</span>
<span class="lineno">  441 </span><span class="spaces">                </span><span class="nottickedoff">_ -&gt; return mempty</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="nottickedoff">-- Look for operator expressions but leave comprehensions, ANDs and ORs up to findInUncondForAll</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="nottickedoff">isOp (Op (MkOpAnd (OpAnd Comprehension{}))) = False</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="nottickedoff">isOp [essence| &amp;_ /\ &amp;_ |]                  = False</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="nottickedoff">isOp [essence| &amp;_ \/ &amp;_ |]                  = False</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="nottickedoff">-- Disallow implications which may remove some cases</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="nottickedoff">isOp [essence| &amp;_ -&gt; &amp;_ |]                  = False</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="nottickedoff">isOp Op{}                                   = True</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="nottickedoff">isOp _                                      = False</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="nottickedoff">-- Determine whether a function is called with values generated from its domain</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="nottickedoff">funcCalledWithGenParams d [essence| image(&amp;f, &amp;param) |]</span>
<span class="lineno">  453 </span><span class="spaces">      </span><span class="nottickedoff">= nameExpEq n f &amp;&amp; case domainOf param of</span>
<span class="lineno">  454 </span><span class="spaces">                              </span><span class="nottickedoff">Right d' -&gt; d' == d</span>
<span class="lineno">  455 </span><span class="spaces">                              </span><span class="nottickedoff">Left _   -&gt; False</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="nottickedoff">funcCalledWithGenParams _ _ = False</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>-- | If all distinct inputs to a function have distinct results, then it is injective.
<span class="lineno">  459 </span>--   It will also be total if there are no conditions other than the disequality between
<span class="lineno">  460 </span>--   the two inputs.
<span class="lineno">  461 </span>diffArgResultIsInjective :: (MonadFail m, MonadLog m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  462 </span>                         =&gt; Model
<span class="lineno">  463 </span>                         -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  464 </span>                         -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  465 </span><span class="decl"><span class="nottickedoff">diffArgResultIsInjective _ ((n, DomainFunction _ (FunctionAttr _ _ ject) from _), cs)</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="nottickedoff">| (ject == JectivityAttr_None || ject == JectivityAttr_Surjective) &amp;&amp;</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="nottickedoff">not (null $ findInUncondForAll isDistinctDisequality cs)</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="nottickedoff">-- It is known that no inputs are ignored</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="nottickedoff">= return ([(&quot;injective&quot;, Nothing), (&quot;total&quot;, Nothing)], mempty)</span>
<span class="lineno">  470 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="nottickedoff">-- Match a very specific pattern, which will also add the total attribute</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="nottickedoff">isDistinctDisequality [essence| &amp;i != &amp;j -&gt; image(&amp;f, &amp;i') != image(&amp;f', &amp;j') |]</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="nottickedoff">= f == f' &amp;&amp; i == i' &amp;&amp; j == j' &amp;&amp;</span>
<span class="lineno">  474 </span><span class="spaces">        </span><span class="nottickedoff">nameExpEq n f &amp;&amp;          -- the function is the one under consideration</span>
<span class="lineno">  475 </span><span class="spaces">        </span><span class="nottickedoff">domIsGen i &amp;&amp; domIsGen j  -- the values are generated from the function's domain</span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="nottickedoff">isDistinctDisequality _ = False</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="nottickedoff">domIsGen x = case domainOf x of</span>
<span class="lineno">  478 </span><span class="spaces">                      </span><span class="nottickedoff">Right dom -&gt; dom == from</span>
<span class="lineno">  479 </span><span class="spaces">                      </span><span class="nottickedoff">Left _    -&gt; False</span>
<span class="lineno">  480 </span><span class="spaces"></span><span class="nottickedoff">diffArgResultIsInjective _ _ = return mempty</span></span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>-- | Set a size attribute on a variable.
<span class="lineno">  483 </span>varSize :: (MonadFail m, MonadLog m)
<span class="lineno">  484 </span>        =&gt; Model
<span class="lineno">  485 </span>        -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  486 </span>        -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  487 </span><span class="decl"><span class="nottickedoff">varSize _ ((n, _), cs) = do</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="nottickedoff">results &lt;- forM cs $ \c -&gt;</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="nottickedoff">case matching (hole c) ineqSizeAttrs of</span>
<span class="lineno">  490 </span><span class="spaces">         </span><span class="nottickedoff">-- Do not allow find variables to be put in attributes</span>
<span class="lineno">  491 </span><span class="spaces">         </span><span class="nottickedoff">Just ((attr, f), (cardinalityOf -&gt; Just x, e)) | nameExpEq n x &amp;&amp; not (isFind e)</span>
<span class="lineno">  492 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; pure (Just (attr, f e), ([], [c]))</span>
<span class="lineno">  493 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; pure (Nothing, mempty)</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="nottickedoff">return $ unzipMaybeK results</span></span>
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>cardinalityOf :: Expression -&gt; Maybe Expression
<span class="lineno">  498 </span><span class="decl"><span class="nottickedoff">cardinalityOf [essence| |&amp;x| |] = Just x</span>
<span class="lineno">  499 </span><span class="spaces"></span><span class="nottickedoff">cardinalityOf [essence| sum([1 | &amp;_ &lt;- &amp;x]) |] = Just x</span>
<span class="lineno">  500 </span><span class="spaces"></span><span class="nottickedoff">cardinalityOf _ = Nothing</span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>-- | Set the minimum size of a set based on it being a superset of another.
<span class="lineno">  504 </span>setSize :: (MonadFail m, MonadLog m, NameGen m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  505 </span>        =&gt; Model
<span class="lineno">  506 </span>        -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  507 </span>        -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  508 </span><span class="decl"><span class="nottickedoff">setSize _ ((n, DomainSet{}), cs)</span>
<span class="lineno">  509 </span><span class="spaces">  </span><span class="nottickedoff">= fmap mconcat $ forM (findInUncondForAllZ isSubSupSet cs) $ \c -&gt;</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="nottickedoff">case hole c of</span>
<span class="lineno">  511 </span><span class="spaces">         </span><span class="nottickedoff">-- subset(Eq)</span>
<span class="lineno">  512 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l subset   &amp;r |] | nameExpEq n r -&gt; return (minSize l (+ 1), mempty)</span>
<span class="lineno">  513 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l subset   &amp;r |] | nameExpEq n l -&gt; return (maxSize r (\x -&gt; x - 1), mempty)</span>
<span class="lineno">  514 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l subsetEq &amp;r |] | nameExpEq n r -&gt; return (minSize l id, mempty)</span>
<span class="lineno">  515 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l subsetEq &amp;r |] | nameExpEq n l -&gt; return (maxSize r id, mempty)</span>
<span class="lineno">  516 </span><span class="spaces">         </span><span class="nottickedoff">-- supset(Eq)</span>
<span class="lineno">  517 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l supset   &amp;r |] | nameExpEq n l -&gt; return (minSize r (+ 1), mempty)</span>
<span class="lineno">  518 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l supset   &amp;r |] | nameExpEq n r -&gt; return (maxSize l (\x -&gt; x - 1), mempty)</span>
<span class="lineno">  519 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l supsetEq &amp;r |] | nameExpEq n l -&gt; return (minSize r id, mempty)</span>
<span class="lineno">  520 </span><span class="spaces">         </span><span class="nottickedoff">[essence| &amp;l supsetEq &amp;r |] | nameExpEq n r -&gt; return (maxSize l id, mempty)</span>
<span class="lineno">  521 </span><span class="spaces">         </span><span class="nottickedoff">_                                           -&gt; return mempty</span>
<span class="lineno">  522 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  523 </span><span class="spaces">    </span><span class="nottickedoff">isSubSupSet [essence| &amp;_ subset   &amp;_ |] = True</span>
<span class="lineno">  524 </span><span class="spaces">    </span><span class="nottickedoff">isSubSupSet [essence| &amp;_ subsetEq &amp;_ |] = True</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="nottickedoff">isSubSupSet [essence| &amp;_ supset   &amp;_ |] = True</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="nottickedoff">isSubSupSet [essence| &amp;_ supsetEq &amp;_ |] = True</span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="nottickedoff">isSubSupSet _                           = False</span>
<span class="lineno">  528 </span><span class="spaces">    </span><span class="nottickedoff">minSize [essence| defined(&amp;g) |] f</span>
<span class="lineno">  529 </span><span class="spaces">      </span><span class="nottickedoff">= case domainOf g of</span>
<span class="lineno">  530 </span><span class="spaces">             </span><span class="nottickedoff">Right (DomainFunction _ (FunctionAttr _ PartialityAttr_Total _) from _) -&gt;</span>
<span class="lineno">  531 </span><span class="spaces">               </span><span class="nottickedoff">case domainSizeOf from of</span>
<span class="lineno">  532 </span><span class="spaces">                    </span><span class="nottickedoff">Just s  -&gt; [(&quot;minSize&quot;, Just (f s))]</span>
<span class="lineno">  533 </span><span class="spaces">                    </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  534 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  535 </span><span class="spaces">    </span><span class="nottickedoff">minSize [essence| range(&amp;g) |] f</span>
<span class="lineno">  536 </span><span class="spaces">      </span><span class="nottickedoff">= case domainOf g of</span>
<span class="lineno">  537 </span><span class="spaces">             </span><span class="nottickedoff">Right (DomainFunction _ (FunctionAttr _ PartialityAttr_Total j) from to)</span>
<span class="lineno">  538 </span><span class="spaces">               </span><span class="nottickedoff">| j == JectivityAttr_Bijective || j == JectivityAttr_Surjective -&gt;</span>
<span class="lineno">  539 </span><span class="spaces">                 </span><span class="nottickedoff">case domainSizeOf to of</span>
<span class="lineno">  540 </span><span class="spaces">                      </span><span class="nottickedoff">Just s  -&gt; [(&quot;minSize&quot;, Just (f s))]</span>
<span class="lineno">  541 </span><span class="spaces">                      </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  542 </span><span class="spaces">               </span><span class="nottickedoff">| j == JectivityAttr_Injective -&gt;</span>
<span class="lineno">  543 </span><span class="spaces">                 </span><span class="nottickedoff">case domainSizeOf from of</span>
<span class="lineno">  544 </span><span class="spaces">                      </span><span class="nottickedoff">Just s  -&gt; [(&quot;minSize&quot;, Just (f s))]</span>
<span class="lineno">  545 </span><span class="spaces">                      </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  546 </span><span class="spaces">               </span><span class="nottickedoff">| otherwise    -&gt; [(&quot;minSize&quot;, Just (f 1))]</span>
<span class="lineno">  547 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="nottickedoff">minSize e f = case domainOf e of</span>
<span class="lineno">  549 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_Size mn)) _) -&gt;</span>
<span class="lineno">  550 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;minSize&quot;, Just (f mn))]</span>
<span class="lineno">  551 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_MinSize mn)) _) -&gt;</span>
<span class="lineno">  552 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;minSize&quot;, Just (f mn))]</span>
<span class="lineno">  553 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_MinMaxSize mn _)) _) -&gt;</span>
<span class="lineno">  554 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;minSize&quot;, Just (f mn))]</span>
<span class="lineno">  555 </span><span class="spaces">                       </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  556 </span><span class="spaces">                       </span><span class="nottickedoff">-- TODO: extend for Matrix, MSet, Partition and Sequence</span>
<span class="lineno">  557 </span><span class="spaces">    </span><span class="nottickedoff">maxSize [essence| defined(&amp;g) |] f</span>
<span class="lineno">  558 </span><span class="spaces">      </span><span class="nottickedoff">= case domainOf g &gt;&gt;= innerDomainOf of</span>
<span class="lineno">  559 </span><span class="spaces">             </span><span class="nottickedoff">Right (DomainTuple [d, _]) -&gt;</span>
<span class="lineno">  560 </span><span class="spaces">               </span><span class="nottickedoff">case domainSizeOf d of</span>
<span class="lineno">  561 </span><span class="spaces">                    </span><span class="nottickedoff">Just s  -&gt; [(&quot;maxSize&quot;, Just (f s))]</span>
<span class="lineno">  562 </span><span class="spaces">                    </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  563 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  564 </span><span class="spaces">    </span><span class="nottickedoff">maxSize [essence| range(&amp;g) |] f</span>
<span class="lineno">  565 </span><span class="spaces">      </span><span class="nottickedoff">= case domainOf g &gt;&gt;= innerDomainOf of</span>
<span class="lineno">  566 </span><span class="spaces">             </span><span class="nottickedoff">Right (DomainTuple [_, d]) -&gt;</span>
<span class="lineno">  567 </span><span class="spaces">               </span><span class="nottickedoff">case domainSizeOf d of</span>
<span class="lineno">  568 </span><span class="spaces">                    </span><span class="nottickedoff">Just s  -&gt; [(&quot;maxSize&quot;, Just (f s))]</span>
<span class="lineno">  569 </span><span class="spaces">                    </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  570 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  571 </span><span class="spaces">    </span><span class="nottickedoff">maxSize e f = case domainOf e of</span>
<span class="lineno">  572 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_Size mx)) _) -&gt;</span>
<span class="lineno">  573 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;maxSize&quot;, Just (f mx))]</span>
<span class="lineno">  574 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_MaxSize mx)) _) -&gt;</span>
<span class="lineno">  575 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;maxSize&quot;, Just (f mx))]</span>
<span class="lineno">  576 </span><span class="spaces">                       </span><span class="nottickedoff">Right (DomainSet _ (SetAttr (SizeAttr_MinMaxSize _ mx)) _) -&gt;</span>
<span class="lineno">  577 </span><span class="spaces">                         </span><span class="nottickedoff">[(&quot;maxSize&quot;, Just (f mx))]</span>
<span class="lineno">  578 </span><span class="spaces">                       </span><span class="nottickedoff">Right d@(DomainSet _ (SetAttr SizeAttr_None) _) -&gt;</span>
<span class="lineno">  579 </span><span class="spaces">                         </span><span class="nottickedoff">case domainSizeOf d of</span>
<span class="lineno">  580 </span><span class="spaces">                              </span><span class="nottickedoff">Just mx -&gt; [(&quot;maxSize&quot;, Just (f mx))]</span>
<span class="lineno">  581 </span><span class="spaces">                              </span><span class="nottickedoff">Nothing -&gt; mempty</span>
<span class="lineno">  582 </span><span class="spaces">                       </span><span class="nottickedoff">_ -&gt; mempty</span>
<span class="lineno">  583 </span><span class="spaces">                       </span><span class="nottickedoff">-- TODO: extend for Matrix, MSet, Partition and Sequence</span>
<span class="lineno">  584 </span><span class="spaces"></span><span class="nottickedoff">setSize _ _ = return mempty</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- | The maxSize, and minOccur attributes of an mset affect its maxOccur and minSize attributes.
<span class="lineno">  587 </span>mSetSizeOccur :: (MonadFail m, MonadLog m)
<span class="lineno">  588 </span>              =&gt; Model
<span class="lineno">  589 </span>              -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  590 </span>              -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  591 </span><span class="decl"><span class="nottickedoff">mSetSizeOccur _ ((_, d), _)</span>
<span class="lineno">  592 </span><span class="spaces">  </span><span class="nottickedoff">= case d of</span>
<span class="lineno">  593 </span><span class="spaces">         </span><span class="nottickedoff">-- Ordering is important here, as there is a rule that applies</span>
<span class="lineno">  594 </span><span class="spaces">         </span><span class="nottickedoff">-- to maxSize and minOccur, but none that applies to minSize</span>
<span class="lineno">  595 </span><span class="spaces">         </span><span class="nottickedoff">-- and maxOccur. size uses the maxSize rule, but can ignore a</span>
<span class="lineno">  596 </span><span class="spaces">         </span><span class="nottickedoff">-- minOccur because it cannot have its minSize changed.</span>
<span class="lineno">  597 </span><span class="spaces">         </span><span class="nottickedoff">-- size -&gt; maxOccur</span>
<span class="lineno">  598 </span><span class="spaces">         </span><span class="nottickedoff">DomainMSet _ (MSetAttr (SizeAttr_Size mx) _) _</span>
<span class="lineno">  599 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; return ([(&quot;maxOccur&quot;, Just mx)], mempty)</span>
<span class="lineno">  600 </span><span class="spaces">         </span><span class="nottickedoff">-- minOccur -&gt; minSize</span>
<span class="lineno">  601 </span><span class="spaces">         </span><span class="nottickedoff">DomainMSet _ (MSetAttr _ (OccurAttr_MinOccur mn)) _</span>
<span class="lineno">  602 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; return ([(&quot;minSize&quot;, Just mn)], mempty)</span>
<span class="lineno">  603 </span><span class="spaces">         </span><span class="nottickedoff">DomainMSet _ (MSetAttr _ (OccurAttr_MinMaxOccur mn _)) _</span>
<span class="lineno">  604 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; return ([(&quot;minSize&quot;, Just mn)], mempty)</span>
<span class="lineno">  605 </span><span class="spaces">         </span><span class="nottickedoff">-- maxSize -&gt; maxOccur</span>
<span class="lineno">  606 </span><span class="spaces">         </span><span class="nottickedoff">DomainMSet _ (MSetAttr (SizeAttr_MaxSize mx) _) _</span>
<span class="lineno">  607 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; return ([(&quot;maxOccur&quot;, Just mx)], mempty)</span>
<span class="lineno">  608 </span><span class="spaces">         </span><span class="nottickedoff">DomainMSet _ (MSetAttr (SizeAttr_MinMaxSize _ mx) _) _</span>
<span class="lineno">  609 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; return ([(&quot;maxOccur&quot;, Just mx)], mempty)</span>
<span class="lineno">  610 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return mempty</span></span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>-- | Infer multiset occurrence attributes from constraints.
<span class="lineno">  613 </span>mSetOccur :: (MonadFail m, MonadLog m)
<span class="lineno">  614 </span>          =&gt; Model
<span class="lineno">  615 </span>          -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  616 </span>          -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  617 </span><span class="decl"><span class="nottickedoff">mSetOccur _ ((n, DomainMSet _ _ d), cs)</span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="nottickedoff">= return $ mconcat $ flip mapMaybe (findInUncondForAllZ (not . null . isFreq) cs) $ \e -&gt;</span>
<span class="lineno">  619 </span><span class="spaces">      </span><span class="nottickedoff">case isFreq (hole e) of</span>
<span class="lineno">  620 </span><span class="spaces">           </span><span class="nottickedoff">[] -&gt; Nothing</span>
<span class="lineno">  621 </span><span class="spaces">           </span><span class="nottickedoff">-- Only remove constraints if they are all used up.</span>
<span class="lineno">  622 </span><span class="spaces">           </span><span class="nottickedoff">-- Because freq(a, b) = c adds two attributes, removing constraints</span>
<span class="lineno">  623 </span><span class="spaces">           </span><span class="nottickedoff">-- in an AND expression cannot work, in the case of freq(a, b) = c /\ e</span>
<span class="lineno">  624 </span><span class="spaces">           </span><span class="nottickedoff">-- because there are two attributes and two terms, but term e may not</span>
<span class="lineno">  625 </span><span class="spaces">           </span><span class="nottickedoff">-- be removed.</span>
<span class="lineno">  626 </span><span class="spaces">           </span><span class="nottickedoff">as -&gt; let tattr = case hole e of</span>
<span class="lineno">  627 </span><span class="spaces">                                  </span><span class="nottickedoff">AbstractLiteral AbsLitMatrix{} -&gt; mempty</span>
<span class="lineno">  628 </span><span class="spaces">                                  </span><span class="nottickedoff">_                              -&gt; ([], [e])</span>
<span class="lineno">  629 </span><span class="spaces">                     </span><span class="nottickedoff">in Just (as, tattr)</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="nottickedoff">isFreq :: Expression -&gt; [AttrPair]</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="nottickedoff">isFreq (AbstractLiteral (AbsLitMatrix _ es)) = concatMap isFreq es</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="nottickedoff">isFreq e = case matching e oppIneqOps of</span>
<span class="lineno">  634 </span><span class="spaces">                    </span><span class="nottickedoff">Just (_, ([essence| freq(&amp;x, &amp;v) |], e'))</span>
<span class="lineno">  635 </span><span class="spaces">                      </span><span class="nottickedoff">| valid x v e' -&gt; case matching e ineqOccurAttrs of</span>
<span class="lineno">  636 </span><span class="spaces">                                             </span><span class="nottickedoff">Just (as, _) -&gt; map (second ($ e')) as</span>
<span class="lineno">  637 </span><span class="spaces">                                             </span><span class="nottickedoff">Nothing      -&gt; []</span>
<span class="lineno">  638 </span><span class="spaces">                    </span><span class="nottickedoff">-- Flip the terms</span>
<span class="lineno">  639 </span><span class="spaces">                    </span><span class="nottickedoff">Just (oper, (l, r@[essence| freq(&amp;x, &amp;v) |]))</span>
<span class="lineno">  640 </span><span class="spaces">                      </span><span class="nottickedoff">| valid x v l -&gt; isFreq $ make oper r l</span>
<span class="lineno">  641 </span><span class="spaces">                    </span><span class="nottickedoff">_               -&gt; []</span>
<span class="lineno">  642 </span><span class="spaces">    </span><span class="nottickedoff">-- Make sure that the expression's components are valid</span>
<span class="lineno">  643 </span><span class="spaces">    </span><span class="nottickedoff">valid :: Expression -&gt; Expression -&gt; Expression -&gt; Bool</span>
<span class="lineno">  644 </span><span class="spaces">    </span><span class="nottickedoff">valid x v e = nameExpEq n x &amp;&amp; isGen v &amp;&amp; isConst e</span>
<span class="lineno">  645 </span><span class="spaces">    </span><span class="nottickedoff">-- Make sure that the value is generated from the mset's domain</span>
<span class="lineno">  646 </span><span class="spaces">    </span><span class="nottickedoff">isGen (Reference _ (Just (InComprehension (GenDomainNoRepr _ d')))) = d == d'</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="nottickedoff">isGen (Reference _ (Just (DeclNoRepr Quantified _ d' _)))           = d == d'</span>
<span class="lineno">  648 </span><span class="spaces">    </span><span class="nottickedoff">isGen (Reference _ (Just (InComprehension (GenInExpr _ e ))))       = nameExpEq n e</span>
<span class="lineno">  649 </span><span class="spaces">    </span><span class="nottickedoff">isGen _                                                             = False</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="nottickedoff">-- Make sure that the mset is being equated to a constant</span>
<span class="lineno">  651 </span><span class="spaces">    </span><span class="nottickedoff">isConst (Reference _ (Just (DeclNoRepr Given _ _ _))) = True</span>
<span class="lineno">  652 </span><span class="spaces">    </span><span class="nottickedoff">isConst (Constant ConstantInt{})                      = True</span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="nottickedoff">isConst _                                             = False</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="nottickedoff">mSetOccur _ _ = return mempty</span></span>
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>-- | Mark a partition regular if there is a constraint on its parts constraining them to be of equal size.
<span class="lineno">  657 </span>partRegular :: (MonadFail m, MonadLog m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  658 </span>            =&gt; Model
<span class="lineno">  659 </span>            -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  660 </span>            -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  661 </span><span class="decl"><span class="nottickedoff">partRegular _ ((_, DomainPartition{}), cs) = do</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="nottickedoff">attrs &lt;- forM cs $ \c -&gt;</span>
<span class="lineno">  663 </span><span class="spaces">      </span><span class="nottickedoff">case hole c of</span>
<span class="lineno">  664 </span><span class="spaces">           </span><span class="nottickedoff">-- [essence| forAll &amp;x in parts(&amp;p) . forAll &amp;y in parts(&amp;p') . &amp;xCard = &amp;yCard |]</span>
<span class="lineno">  665 </span><span class="spaces">           </span><span class="nottickedoff">[essence| and([ &amp;xCard = &amp;yCard | &amp;x &lt;- parts(&amp;p), &amp;y &lt;- parts(&amp;p') ]) |]</span>
<span class="lineno">  666 </span><span class="spaces">             </span><span class="nottickedoff">| Just (Reference x' _) &lt;- cardinalityOf xCard</span>
<span class="lineno">  667 </span><span class="spaces">             </span><span class="nottickedoff">, Just (Reference y' _) &lt;- cardinalityOf yCard</span>
<span class="lineno">  668 </span><span class="spaces">             </span><span class="nottickedoff">, or [ and [x == Single x', y == Single y']</span>
<span class="lineno">  669 </span><span class="spaces">                  </span><span class="nottickedoff">, and [x == Single y', y == Single x']</span>
<span class="lineno">  670 </span><span class="spaces">                  </span><span class="nottickedoff">]</span>
<span class="lineno">  671 </span><span class="spaces">             </span><span class="nottickedoff">, p == p'</span>
<span class="lineno">  672 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;regular&quot;, Nothing), ([], [c]))</span>
<span class="lineno">  673 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; pure (Nothing, mempty)</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="nottickedoff">return $ unzipMaybeK attrs</span>
<span class="lineno">  675 </span><span class="spaces"></span><span class="nottickedoff">partRegular _ _ = return mempty</span></span>
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>-- | Convert constraints acting on the number of parts in a partition to an attribute.
<span class="lineno">  679 </span>numPartsToAttr :: (MonadFail m, MonadLog m)
<span class="lineno">  680 </span>               =&gt; Model
<span class="lineno">  681 </span>               -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  682 </span>               -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  683 </span><span class="decl"><span class="nottickedoff">numPartsToAttr _ ((n, DomainPartition{}), cs) = do</span>
<span class="lineno">  684 </span><span class="spaces">  </span><span class="nottickedoff">attrs &lt;- forM cs $ \c -&gt;</span>
<span class="lineno">  685 </span><span class="spaces">    </span><span class="nottickedoff">case matching (hole c) ineqSizeAttrs of</span>
<span class="lineno">  686 </span><span class="spaces">         </span><span class="nottickedoff">-- Do not allow find variables to be put in attributes</span>
<span class="lineno">  687 </span><span class="spaces">         </span><span class="nottickedoff">Just ((attr, f), ([essence| |parts(&amp;x)| |], e)) | nameExpEq n x &amp;&amp; not (isFind e)</span>
<span class="lineno">  688 </span><span class="spaces">           </span><span class="nottickedoff">-&gt; pure (Just (changeAttr attr, f e), ([], [c]))</span>
<span class="lineno">  689 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; pure (Nothing, mempty)</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="nottickedoff">return $ unzipMaybeK attrs</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="nottickedoff">-- Change a size attribute name to a numParts attribute name</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="nottickedoff">changeAttr &quot;size&quot;    = &quot;numParts&quot;</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="nottickedoff">changeAttr &quot;minSize&quot; = &quot;minNumParts&quot;</span>
<span class="lineno">  695 </span><span class="spaces">    </span><span class="nottickedoff">changeAttr &quot;maxSize&quot; = &quot;maxNumParts&quot;</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="nottickedoff">changeAttr a         = a</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="nottickedoff">numPartsToAttr _ _ = return mempty</span></span>
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>-- | Convert constraints acting on the sizes of parts in a partition to an attribute.
<span class="lineno">  700 </span>partSizeToAttr :: (MonadFail m, MonadLog m)
<span class="lineno">  701 </span>               =&gt; Model
<span class="lineno">  702 </span>               -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  703 </span>               -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  704 </span><span class="decl"><span class="nottickedoff">partSizeToAttr _ ((n, DomainPartition{}), cs) = do</span>
<span class="lineno">  705 </span><span class="spaces">  </span><span class="nottickedoff">attrs &lt;- forM cs $ \c -&gt;</span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="nottickedoff">case hole c of</span>
<span class="lineno">  707 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in parts(&amp;p) . &amp;xCard =  &amp;e |]</span>
<span class="lineno">  708 </span><span class="spaces">             </span><span class="nottickedoff">| Just x' &lt;- cardinalityOf xCard</span>
<span class="lineno">  709 </span><span class="spaces">             </span><span class="nottickedoff">, valid p x x' e</span>
<span class="lineno">  710 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;partSize&quot;, Just e), ([], [c]))</span>
<span class="lineno">  711 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in parts(&amp;p) . &amp;xCard &lt;  &amp;e |]</span>
<span class="lineno">  712 </span><span class="spaces">             </span><span class="nottickedoff">| Just x' &lt;- cardinalityOf xCard</span>
<span class="lineno">  713 </span><span class="spaces">             </span><span class="nottickedoff">, valid p x x' e</span>
<span class="lineno">  714 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;maxPartSize&quot;, Just (e - 1)), ([], [c]))</span>
<span class="lineno">  715 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in parts(&amp;p) . &amp;xCard &lt;= &amp;e |]</span>
<span class="lineno">  716 </span><span class="spaces">             </span><span class="nottickedoff">| Just x' &lt;- cardinalityOf xCard</span>
<span class="lineno">  717 </span><span class="spaces">             </span><span class="nottickedoff">, valid p x x' e</span>
<span class="lineno">  718 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;maxPartSize&quot;, Just e), ([], [c]))</span>
<span class="lineno">  719 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in parts(&amp;p) . &amp;xCard &gt;  &amp;e |]</span>
<span class="lineno">  720 </span><span class="spaces">             </span><span class="nottickedoff">| Just x' &lt;- cardinalityOf xCard</span>
<span class="lineno">  721 </span><span class="spaces">             </span><span class="nottickedoff">, valid p x x' e</span>
<span class="lineno">  722 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;minPartSize&quot;, Just (e + 1)), ([], [c]))</span>
<span class="lineno">  723 </span><span class="spaces">         </span><span class="nottickedoff">[essence| forAll &amp;x in parts(&amp;p) . &amp;xCard &gt;= &amp;e |]</span>
<span class="lineno">  724 </span><span class="spaces">             </span><span class="nottickedoff">| Just x' &lt;- cardinalityOf xCard</span>
<span class="lineno">  725 </span><span class="spaces">             </span><span class="nottickedoff">, valid p x x' e</span>
<span class="lineno">  726 </span><span class="spaces">             </span><span class="nottickedoff">-&gt; pure (Just (&quot;minPartSize&quot;, Just e), ([], [c]))</span>
<span class="lineno">  727 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; pure (Nothing, mempty)</span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="nottickedoff">return $ unzipMaybeK attrs</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  730 </span><span class="spaces">    </span><span class="nottickedoff">-- Make sure that the expression's components are valid</span>
<span class="lineno">  731 </span><span class="spaces">    </span><span class="nottickedoff">valid :: Expression -&gt; AbstractPattern -&gt; Expression -&gt; Expression -&gt; Bool</span>
<span class="lineno">  732 </span><span class="spaces">    </span><span class="nottickedoff">valid p x v e = nameExpEq n p &amp;&amp; v `refersTo` x &amp;&amp; not (isFind e)</span>
<span class="lineno">  733 </span><span class="spaces"></span><span class="nottickedoff">partSizeToAttr _ _ = return mempty</span></span>
<span class="lineno">  734 </span>
<span class="lineno">  735 </span>-- | Equate the range of a function to a set of the former is a subset of the latter
<span class="lineno">  736 </span>--   and all values in the set are results of the function.
<span class="lineno">  737 </span>funcRangeEqSet :: (MonadFail m, MonadLog m)
<span class="lineno">  738 </span>               =&gt; Model
<span class="lineno">  739 </span>               -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  740 </span>               -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  741 </span><span class="decl"><span class="nottickedoff">funcRangeEqSet _ ((n, DomainSet{}), cs)</span>
<span class="lineno">  742 </span><span class="spaces">  </span><span class="nottickedoff">-- Get references to the set and the function whose range it is a superset of</span>
<span class="lineno">  743 </span><span class="spaces">  </span><span class="nottickedoff">= let funcSubsets = mapMaybe funcSubsetEqOf $</span>
<span class="lineno">  744 </span><span class="spaces">                      </span><span class="nottickedoff">findInUncondForAllZ (isJust . funcSubsetEqOf . zipper) cs</span>
<span class="lineno">  745 </span><span class="spaces">        </span><span class="nottickedoff">-- Reduce the functions to those whose values are equated to the values in the set</span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="nottickedoff">fsToUse = flip filter funcSubsets $ \(_, f) -&gt;</span>
<span class="lineno">  747 </span><span class="spaces">                  </span><span class="nottickedoff">not $ null $ findInUncondForAll (funcValEqSetVal (hole f)) cs</span>
<span class="lineno">  748 </span><span class="spaces">        </span><span class="nottickedoff">-- Transform the functions into new constraints, preserving structure</span>
<span class="lineno">  749 </span><span class="spaces">        </span><span class="nottickedoff">csToAdd = flip mapMaybe fsToUse $ \(s, f) -&gt;</span>
<span class="lineno">  750 </span><span class="spaces">                  </span><span class="nottickedoff">let f' = hole f</span>
<span class="lineno">  751 </span><span class="spaces">                      </span><span class="nottickedoff">in replaceHole [essence| range(&amp;f') = &amp;s |] &lt;$&gt;</span>
<span class="lineno">  752 </span><span class="spaces">                         </span><span class="nottickedoff">(up f &gt;&gt;= up)</span>
<span class="lineno">  753 </span><span class="spaces">        </span><span class="nottickedoff">in return ([], (csToAdd, []))</span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  755 </span><span class="spaces">    </span><span class="nottickedoff">-- Get the function whose range is a subsetEq of the set</span>
<span class="lineno">  756 </span><span class="spaces">    </span><span class="nottickedoff">funcSubsetEqOf z = case hole z of</span>
<span class="lineno">  757 </span><span class="spaces">                            </span><span class="nottickedoff">[essence| range(&amp;_) subsetEq &amp;s |] | nameExpEq n s</span>
<span class="lineno">  758 </span><span class="spaces">                              </span><span class="nottickedoff">-&gt; (,) s &lt;$&gt; (down z &gt;&gt;= down)</span>
<span class="lineno">  759 </span><span class="spaces">                            </span><span class="nottickedoff">[essence| &amp;s supsetEq range(&amp;_) |] | nameExpEq n s</span>
<span class="lineno">  760 </span><span class="spaces">                              </span><span class="nottickedoff">-&gt; (,) s &lt;$&gt; (down z &gt;&gt;= right &gt;&gt;= down)</span>
<span class="lineno">  761 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  762 </span><span class="spaces">    </span><span class="nottickedoff">-- Are the values of the function equal to the values of the set?</span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="nottickedoff">funcValEqSetVal f [essence| forAll &amp;x in &amp;s . image(&amp;f', &amp;_) = &amp;x' |]</span>
<span class="lineno">  764 </span><span class="spaces">      </span><span class="nottickedoff">= nameExpEq n s &amp;&amp; f == f' &amp;&amp; x' `refersTo` x</span>
<span class="lineno">  765 </span><span class="spaces">    </span><span class="nottickedoff">funcValEqSetVal f [essence| forAll &amp;x in &amp;s . &amp;x' = image(&amp;f', &amp;_) |]</span>
<span class="lineno">  766 </span><span class="spaces">      </span><span class="nottickedoff">= nameExpEq n s &amp;&amp; f == f' &amp;&amp; x' `refersTo` x</span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="nottickedoff">funcValEqSetVal _ _ = False</span>
<span class="lineno">  768 </span><span class="spaces"></span><span class="nottickedoff">funcRangeEqSet _ _ = return mempty</span></span>
<span class="lineno">  769 </span>
<span class="lineno">  770 </span>
<span class="lineno">  771 </span>-- | An (in)equality in a forAll implies that the (in)equality also applies to
<span class="lineno">  772 </span>--   the sums of both terms.
<span class="lineno">  773 </span>forAllIneqToIneqSum :: (MonadFail m, MonadLog m, NameGen m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  774 </span>                    =&gt; Model
<span class="lineno">  775 </span>                    -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  776 </span>                    -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  777 </span><span class="decl"><span class="nottickedoff">forAllIneqToIneqSum _ (_, cs) = do</span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="nottickedoff">let matches = mapMaybe matchParts $ findInUncondForAllZ (isJust . matchParts . zipper) cs</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="nottickedoff">csToAdd &lt;- mapMaybe mkConstraint &lt;$&gt; filterM partsAreNumeric matches</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="nottickedoff">return ([], (csToAdd, []))</span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  782 </span><span class="spaces">    </span><span class="nottickedoff">-- Match and extract the desired parts of the expression</span>
<span class="lineno">  783 </span><span class="spaces">    </span><span class="nottickedoff">matchParts :: ExpressionZ -&gt; Maybe (Generator, Maybe ExpressionZ, Expression, Expression)</span>
<span class="lineno">  784 </span><span class="spaces">    </span><span class="nottickedoff">matchParts z = case hole z of</span>
<span class="lineno">  785 </span><span class="spaces">                        </span><span class="nottickedoff">Op (MkOpAnd (OpAnd (Comprehension e [Generator g])))</span>
<span class="lineno">  786 </span><span class="spaces">                          </span><span class="nottickedoff">-&gt; matching e ineqOps &gt;&gt;=</span>
<span class="lineno">  787 </span><span class="spaces">                             </span><span class="nottickedoff">uncurry (matchComponents g z) . snd</span>
<span class="lineno">  788 </span><span class="spaces">                        </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="nottickedoff">-- Match the components of the expression of interest</span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="nottickedoff">matchComponents :: Generator -&gt; ExpressionZ -&gt; Expression -&gt; Expression</span>
<span class="lineno">  791 </span><span class="spaces">                    </span><span class="nottickedoff">-&gt; Maybe (Generator, Maybe ExpressionZ, Expression, Expression)</span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="nottickedoff">matchComponents g z e1 e2</span>
<span class="lineno">  793 </span><span class="spaces">      </span><span class="nottickedoff">| refInExpr (namesFromGenerator g) e1 &amp;&amp; refInExpr (namesFromGenerator g) e2</span>
<span class="lineno">  794 </span><span class="spaces">        </span><span class="nottickedoff">= Just (g, down z &gt;&gt;= down, e1, e2)</span>
<span class="lineno">  795 </span><span class="spaces">    </span><span class="nottickedoff">matchComponents _ _ _ _ = Nothing</span>
<span class="lineno">  796 </span><span class="spaces">    </span><span class="nottickedoff">-- Is a name referred to in an expression?</span>
<span class="lineno">  797 </span><span class="spaces">    </span><span class="nottickedoff">refInExpr names = any (\e -&gt; any (`nameExpEq` e) names) . universe</span>
<span class="lineno">  798 </span><span class="spaces">    </span><span class="nottickedoff">-- Are the parts of the matched expression numeric?</span>
<span class="lineno">  799 </span><span class="spaces">    </span><span class="nottickedoff">partsAreNumeric (_, _, e1, e2) = (&amp;&amp;) &lt;$&gt; domainIsNumeric e1 &lt;*&gt; domainIsNumeric e2</span>
<span class="lineno">  800 </span><span class="spaces">    </span><span class="nottickedoff">domainIsNumeric e = case domainOf e of</span>
<span class="lineno">  801 </span><span class="spaces">                             </span><span class="nottickedoff">Right DomainInt{}           -&gt; return True</span>
<span class="lineno">  802 </span><span class="spaces">                             </span><span class="nottickedoff">Right (DomainAny _ (TypeInt _)) -&gt; return True</span>
<span class="lineno">  803 </span><span class="spaces">                             </span><span class="nottickedoff">_                               -&gt; return False</span>
<span class="lineno">  804 </span><span class="spaces">    </span><span class="nottickedoff">-- Replace the forAll with the (in)equality between sums</span>
<span class="lineno">  805 </span><span class="spaces">    </span><span class="nottickedoff">mkConstraint :: (Generator, Maybe ExpressionZ, Expression, Expression) -&gt; Maybe ExpressionZ</span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="nottickedoff">mkConstraint (gen, Just z, _, _)</span>
<span class="lineno">  807 </span><span class="spaces">      </span><span class="nottickedoff">-- Use matching with ineqOps to get the operation that is used on the two expressions</span>
<span class="lineno">  808 </span><span class="spaces">      </span><span class="nottickedoff">= case matching (hole z) ineqOps of</span>
<span class="lineno">  809 </span><span class="spaces">             </span><span class="nottickedoff">Just (f, (e1, e2))</span>
<span class="lineno">  810 </span><span class="spaces">               </span><span class="nottickedoff">-&gt; let mkSumOf = Op . MkOpSum . OpSum . flip Comprehension [Generator gen]</span>
<span class="lineno">  811 </span><span class="spaces">                      </span><span class="nottickedoff">-- Two steps to get out of the forAll, and replace it with the constraint</span>
<span class="lineno">  812 </span><span class="spaces">                      </span><span class="nottickedoff">in replaceHole (make f (mkSumOf e1) (mkSumOf e2)) &lt;$&gt; (up z &gt;&gt;= up)</span>
<span class="lineno">  813 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  814 </span><span class="spaces">    </span><span class="nottickedoff">mkConstraint _ = Nothing</span></span>
<span class="lineno">  815 </span>
<span class="lineno">  816 </span>-- | Iterate slightly faster over a domain if generating two distinct variables.
<span class="lineno">  817 </span>fasterIteration :: (MonadFail m, MonadIO m, MonadLog m, ?typeCheckerMode :: TypeCheckerMode)
<span class="lineno">  818 </span>                =&gt; Model
<span class="lineno">  819 </span>                -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  820 </span>                -&gt; m ([AttrPair], ToAddToRem)
<span class="lineno">  821 </span><span class="decl"><span class="nottickedoff">fasterIteration m (_, cs) = do</span>
<span class="lineno">  822 </span><span class="spaces">  </span><span class="nottickedoff">let iters = findInUncondForAllZ (isJust . doubleDistinctIter . zipper) cs</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="nottickedoff">fmap ((,) [] . mconcat) $ forM iters $ \z -&gt; do</span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="nottickedoff">-- Find the equivalent variables</span>
<span class="lineno">  825 </span><span class="spaces">    </span><span class="nottickedoff">[equivs] &lt;- sequence [ findEquivVars (hole z) ]</span>
<span class="lineno">  826 </span><span class="spaces">    </span><span class="nottickedoff">-- Only apply to equivalent variables and make the new constraint</span>
<span class="lineno">  827 </span><span class="spaces">    </span><span class="nottickedoff">case doubleDistinctIter z &gt;&gt;= onlyEquivalent equivs &gt;&gt;= changeIterator of</span>
<span class="lineno">  828 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; return mempty</span>
<span class="lineno">  829 </span><span class="spaces">         </span><span class="nottickedoff">-- Remove the old constraint</span>
<span class="lineno">  830 </span><span class="spaces">         </span><span class="nottickedoff">Just z' -&gt; return ([z'], [z])</span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  832 </span><span class="spaces">    </span><span class="nottickedoff">-- Match the elemenents of interest in the constraint</span>
<span class="lineno">  833 </span><span class="spaces">    </span><span class="nottickedoff">doubleDistinctIter z</span>
<span class="lineno">  834 </span><span class="spaces">      </span><span class="nottickedoff">= case hole z of</span>
<span class="lineno">  835 </span><span class="spaces">             </span><span class="nottickedoff">Op (MkOpAnd (OpAnd (Comprehension _ [ Generator (GenInExpr x v)</span>
<span class="lineno">  836 </span><span class="spaces">                                                 </span><span class="nottickedoff">, Generator (GenInExpr y v')</span>
<span class="lineno">  837 </span><span class="spaces">                                                 </span><span class="nottickedoff">, Condition [essence| &amp;x' != &amp;y' |]</span>
<span class="lineno">  838 </span><span class="spaces">                                                 </span><span class="nottickedoff">])))</span>
<span class="lineno">  839 </span><span class="spaces">               </span><span class="nottickedoff">| v == v' &amp;&amp; x' `refersTo` x &amp;&amp; y' `refersTo` y</span>
<span class="lineno">  840 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; Just ((x, x'), (y, y'), v, down z &gt;&gt;= down)</span>
<span class="lineno">  841 </span><span class="spaces">             </span><span class="nottickedoff">Op (MkOpAnd (OpAnd (Comprehension _ [ Generator (GenDomainNoRepr x d)</span>
<span class="lineno">  842 </span><span class="spaces">                                                 </span><span class="nottickedoff">, Generator (GenDomainNoRepr y d')</span>
<span class="lineno">  843 </span><span class="spaces">                                                 </span><span class="nottickedoff">, Condition [essence| &amp;x' != &amp;y' |]</span>
<span class="lineno">  844 </span><span class="spaces">                                                 </span><span class="nottickedoff">])))</span>
<span class="lineno">  845 </span><span class="spaces">               </span><span class="nottickedoff">| d == d' &amp;&amp; x' `refersTo` x &amp;&amp; y' `refersTo` y</span>
<span class="lineno">  846 </span><span class="spaces">                 </span><span class="nottickedoff">-&gt; Just ((x, x'), (y, y'), Domain d, down z &gt;&gt;= down)</span>
<span class="lineno">  847 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="nottickedoff">-- Find which variables are equivalent in an expression</span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="nottickedoff">findEquivVars :: (MonadIO m) =&gt; Expression -&gt; m (Map Text Text)</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="nottickedoff">findEquivVars e = case e of</span>
<span class="lineno">  851 </span><span class="spaces">                           </span><span class="nottickedoff">[essence| forAll &amp;_, &amp;_ : &amp;_, &amp;_ . &amp;e' |]  -&gt; liftIO $ findSyms e'</span>
<span class="lineno">  852 </span><span class="spaces">                           </span><span class="nottickedoff">[essence| forAll &amp;_, &amp;_ in &amp;_, &amp;_ . &amp;e' |] -&gt; liftIO $ findSyms e'</span>
<span class="lineno">  853 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; return M.empty</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="nottickedoff">-- Find the symmetries in an expression</span>
<span class="lineno">  855 </span><span class="spaces">    </span><span class="nottickedoff">findSyms :: Expression -&gt; IO (Map Text Text)</span>
<span class="lineno">  856 </span><span class="spaces">    </span><span class="nottickedoff">findSyms e = do</span>
<span class="lineno">  857 </span><span class="spaces">      </span><span class="nottickedoff">let m' = addConstraints [zipper e] $ remConstraints cs m</span>
<span class="lineno">  858 </span><span class="spaces">      </span><span class="nottickedoff">let filename = &quot;.tmp-variable-strengthening.json&quot;</span>
<span class="lineno">  859 </span><span class="spaces">      </span><span class="nottickedoff">outputVarSymBreaking filename m'</span>
<span class="lineno">  860 </span><span class="spaces">      </span><span class="nottickedoff">symmetries &lt;- ferret $ stringToText filename</span>
<span class="lineno">  861 </span><span class="spaces">      </span><span class="nottickedoff">removeFile filename</span>
<span class="lineno">  862 </span><span class="spaces">      </span><span class="nottickedoff">case (JSON.decodeStrict $ T.encodeUtf8 symmetries) :: Maybe [Map Text Text] of</span>
<span class="lineno">  863 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; return M.empty</span>
<span class="lineno">  864 </span><span class="spaces">           </span><span class="nottickedoff">Just ss -&gt; return $ foldr M.union M.empty ss</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="nottickedoff">-- Only perform the modification if the variables are equivalent in the expression</span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="nottickedoff">onlyEquivalent es v@((x, _), (y, _), _, _)</span>
<span class="lineno">  867 </span><span class="spaces">      </span><span class="nottickedoff">= case namesFromAbstractPattern x of</span>
<span class="lineno">  868 </span><span class="spaces">             </span><span class="nottickedoff">[Name nx] -&gt; case namesFromAbstractPattern y of</span>
<span class="lineno">  869 </span><span class="spaces">                               </span><span class="nottickedoff">[Name ny] -&gt; case es M.!? nx of</span>
<span class="lineno">  870 </span><span class="spaces">                                                 </span><span class="nottickedoff">Just ny' | ny == ny' -&gt; Just v</span>
<span class="lineno">  871 </span><span class="spaces">                                                 </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  872 </span><span class="spaces">                               </span><span class="nottickedoff">_         -&gt; Nothing</span>
<span class="lineno">  873 </span><span class="spaces">             </span><span class="nottickedoff">_         -&gt; Nothing</span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="nottickedoff">-- Change the iterator to use the new, faster notation</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="nottickedoff">changeIterator ((x, x'), (y, y'), v, Just z)</span>
<span class="lineno">  876 </span><span class="spaces">      </span><span class="nottickedoff">= let e = hole z</span>
<span class="lineno">  877 </span><span class="spaces">            </span><span class="nottickedoff">in case v of</span>
<span class="lineno">  878 </span><span class="spaces">                    </span><span class="nottickedoff">r@Reference{}</span>
<span class="lineno">  879 </span><span class="spaces">                      </span><span class="nottickedoff">-&gt; case domainOf r of</span>
<span class="lineno">  880 </span><span class="spaces">                              </span><span class="nottickedoff">Left _ -&gt; Nothing</span>
<span class="lineno">  881 </span><span class="spaces">                              </span><span class="nottickedoff">Right DomainSet{}</span>
<span class="lineno">  882 </span><span class="spaces">                                </span><span class="nottickedoff">-&gt; replaceHole [essence| forAll {&amp;x, &amp;y} subsetEq &amp;v . &amp;e |] &lt;$&gt;</span>
<span class="lineno">  883 </span><span class="spaces">                                   </span><span class="nottickedoff">(up z &gt;&gt;= up)</span>
<span class="lineno">  884 </span><span class="spaces">                              </span><span class="nottickedoff">Right _</span>
<span class="lineno">  885 </span><span class="spaces">                                </span><span class="nottickedoff">-&gt; replaceHole [essence| forAll &amp;x, &amp;y in &amp;v, &amp;y' &gt; &amp;x' . &amp;e |] &lt;$&gt;</span>
<span class="lineno">  886 </span><span class="spaces">                                   </span><span class="nottickedoff">(up z &gt;&gt;= up)</span>
<span class="lineno">  887 </span><span class="spaces">                    </span><span class="nottickedoff">Op MkOpDefined{}</span>
<span class="lineno">  888 </span><span class="spaces">                      </span><span class="nottickedoff">-&gt; replaceHole [essence| forAll &amp;x, &amp;y in &amp;v, &amp;y' &gt; &amp;x' . &amp;e |] &lt;$&gt;</span>
<span class="lineno">  889 </span><span class="spaces">                         </span><span class="nottickedoff">(up z &gt;&gt;= up)</span>
<span class="lineno">  890 </span><span class="spaces">                    </span><span class="nottickedoff">Domain d</span>
<span class="lineno">  891 </span><span class="spaces">                      </span><span class="nottickedoff">-&gt; replaceHole [essence| forAll &amp;x, &amp;y : &amp;d, &amp;y' &gt; &amp;x' . &amp;e |] &lt;$&gt;</span>
<span class="lineno">  892 </span><span class="spaces">                         </span><span class="nottickedoff">(up z &gt;&gt;= up)</span>
<span class="lineno">  893 </span><span class="spaces">                    </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno">  894 </span><span class="spaces">    </span><span class="nottickedoff">changeIterator _ = Nothing</span></span>
<span class="lineno">  895 </span>
<span class="lineno">  896 </span>-- | Call ferret's symmetry detection on a JSON file
<span class="lineno">  897 </span>ferret :: Text -&gt; IO Text
<span class="lineno">  898 </span><span class="decl"><span class="nottickedoff">ferret path = sh (run &quot;symmetry_detect&quot; [ &quot;--json&quot;, path ]) `catch`</span>
<span class="lineno">  899 </span><span class="spaces">              </span><span class="nottickedoff">(\(_ :: SomeException) -&gt; return &quot;{}&quot;)</span></span>
<span class="lineno">  900 </span>
<span class="lineno">  901 </span>-- | Change the type of a multiset with `maxOccur 1` to set.
<span class="lineno">  902 </span>mSetToSet :: (MonadFail m, MonadLog m)
<span class="lineno">  903 </span>          =&gt; Model
<span class="lineno">  904 </span>          -&gt; (FindVar, [ExpressionZ])
<span class="lineno">  905 </span>          -&gt; m (Domain () Expression, ToAddToRem)
<span class="lineno">  906 </span><span class="decl"><span class="nottickedoff">mSetToSet _ ((n, DomainMSet r (MSetAttr sa oa) d), cs) | maxOccur1 oa = do</span>
<span class="lineno">  907 </span><span class="spaces">  </span><span class="nottickedoff">let dom'  = DomainSet r (SetAttr sa) d</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="nottickedoff">let torem = filter (any (nameExpEq n) . universe . hole) cs</span>
<span class="lineno">  909 </span><span class="spaces">  </span><span class="nottickedoff">let toadd = map (zipper . transform (\e -&gt; if nameExpEq n e</span>
<span class="lineno">  910 </span><span class="spaces">                                                </span><span class="nottickedoff">then [essence| toMSet(&amp;e) |]</span>
<span class="lineno">  911 </span><span class="spaces">                                                </span><span class="nottickedoff">else e)</span>
<span class="lineno">  912 </span><span class="spaces">                          </span><span class="nottickedoff">. hole)</span>
<span class="lineno">  913 </span><span class="spaces">                  </span><span class="nottickedoff">cs</span>
<span class="lineno">  914 </span><span class="spaces">  </span><span class="nottickedoff">return (dom', (toadd, torem))</span>
<span class="lineno">  915 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  916 </span><span class="spaces">    </span><span class="nottickedoff">maxOccur1 (OccurAttr_MaxOccur 1)      = True</span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="nottickedoff">maxOccur1 (OccurAttr_MinMaxOccur _ 1) = True</span>
<span class="lineno">  918 </span><span class="spaces">    </span><span class="nottickedoff">maxOccur1 _                           = False</span>
<span class="lineno">  919 </span><span class="spaces"></span><span class="nottickedoff">mSetToSet _ ((_, dom), _) = return (dom, mempty)</span></span>
<span class="lineno">  920 </span>
<span class="lineno">  921 </span>-- relationToFunction ::
<span class="lineno">  922 </span>--     MonadFail m =&gt;
<span class="lineno">  923 </span>--     MonadLog m =&gt;
<span class="lineno">  924 </span>--     Model -&gt;
<span class="lineno">  925 </span>--     (FindVar, [ExpressionZ]) -&gt;
<span class="lineno">  926 </span>--     m (Domain () Expression, ToAddToRem)
<span class="lineno">  927 </span>-- -- relationToFunction _ ((n, DomainRelation r (MSetAttr sa oa) d), cs) | maxOccur1 oa = do
<span class="lineno">  928 </span>-- --   let dom'  = DomainSet r (SetAttr sa) d
<span class="lineno">  929 </span>-- --   let torem = filter (any (nameExpEq n) . universe . hole) cs
<span class="lineno">  930 </span>-- --   let toadd = map (zipper . transform (\e -&gt; if nameExpEq n e
<span class="lineno">  931 </span>-- --                                                 then [essence| toMSet(&amp;e) |]
<span class="lineno">  932 </span>-- --                                                 else e)
<span class="lineno">  933 </span>-- --                           . hole)
<span class="lineno">  934 </span>-- --                   cs
<span class="lineno">  935 </span>-- --   return (dom', (toadd, torem))
<span class="lineno">  936 </span>-- --   where
<span class="lineno">  937 </span>-- --     maxOccur1 (OccurAttr_MaxOccur 1)      = True
<span class="lineno">  938 </span>-- --     maxOccur1 (OccurAttr_MinMaxOccur _ 1) = True
<span class="lineno">  939 </span>-- --     maxOccur1 _                           = False
<span class="lineno">  940 </span>-- relationToFunction _ ((_, dom), _) = return (dom, mempty)

</pre>
</body>
</html>
