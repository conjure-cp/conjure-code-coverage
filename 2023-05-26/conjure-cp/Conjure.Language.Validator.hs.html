<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE InstanceSigs #-}
<span class="lineno">    2 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    3 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>-- This module is where the syntax tree is mapped to the model. This is also the
<span class="lineno">    6 </span>-- stage at which all errrors are reported. 
<span class="lineno">    7 </span>-- This has three main parts
<span class="lineno">    8 </span>-- Syntax checking:
<span class="lineno">    9 </span>--      When it comes to missing tokens these should usually be handled by the 
<span class="lineno">   10 </span>--      low level token validation functions, however in some special cases
<span class="lineno">   11 </span>--      where the tokens are manipulated manually the checks need to be added
<span class="lineno">   12 </span>-- Type checking:
<span class="lineno">   13 </span>--      Type check operators and build up the symbol table. 
<span class="lineno">   14 </span>-- Metadata additions:
<span class="lineno">   15 </span>--      this includeds things like marking tokens for documentation, as well as
<span class="lineno">   16 </span>--      setting up structural regions such as quantigied expressions
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module Conjure.Language.Validator where
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>import Conjure.Language.AST.Syntax as S
<span class="lineno">   21 </span>import Conjure.Language.Definition hiding (Typed)
<span class="lineno">   22 </span>import qualified Conjure.Language.Expression as D
<span class="lineno">   23 </span>    ( Expression(Typed) )
<span class="lineno">   24 </span>import Conjure.Language.Domain
<span class="lineno">   25 </span>import Conjure.Language.Lexemes
<span class="lineno">   26 </span>import Conjure.Language.Lexer (ETok (ETok, lexeme), tokenSourcePos, totalLength, tokenStart, trueLength, sourcePos0)
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>import Conjure.Language.Attributes
<span class="lineno">   29 </span>import Conjure.Prelude
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>import Control.Monad.Writer.Strict (Writer)
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import Conjure.Language.Type
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>import Data.Map.Strict (Map)
<span class="lineno">   36 </span>import qualified Data.Map.Strict as M
<span class="lineno">   37 </span>import qualified Data.Set as S
<span class="lineno">   38 </span>import qualified Data.Text as T
<span class="lineno">   39 </span>import Data.Text (pack, unpack, append)
<span class="lineno">   40 </span>import Text.Megaparsec ( SourcePos, mkPos, unPos )
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import Conjure.Language.Expression.Op
<span class="lineno">   43 </span>    ( OpSlicing(..),
<span class="lineno">   44 </span>      Op(..),
<span class="lineno">   45 </span>      OpPowerSet(..),
<span class="lineno">   46 </span>      mkOp,
<span class="lineno">   47 </span>      mkBinOp,
<span class="lineno">   48 </span>      Op(MkOpRelationProj, MkOpSlicing, MkOpIndexing),
<span class="lineno">   49 </span>      OpRelationProj(OpRelationProj),
<span class="lineno">   50 </span>      OpIndexing(OpIndexing), OpType (..), OpAttributeAsConstraint (OpAttributeAsConstraint),
<span class="lineno">   51 </span>      )
<span class="lineno">   52 </span>import Conjure.Language.Domain.AddAttributes (allSupportedAttributes)
<span class="lineno">   53 </span>import Conjure.Language.AST.Reformer (Flattenable (flatten))
<span class="lineno">   54 </span>import Text.Megaparsec.Pos (SourcePos(..))
<span class="lineno">   55 </span>import Data.Sequence (Seq (..), viewr, ViewR (..))
<span class="lineno">   56 </span>import Control.Monad (mapAndUnzipM)
<span class="lineno">   57 </span>import Conjure.Bug (bug)
<span class="lineno">   58 </span>import Conjure.Language.Pretty
<span class="lineno">   59 </span>import Data.List (splitAt)
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>data TagType
<span class="lineno">   62 </span>    =TtType
<span class="lineno">   63 </span>    |TtNumber
<span class="lineno">   64 </span>    |TtBool
<span class="lineno">   65 </span>    |TtDomain
<span class="lineno">   66 </span>    |TtEnum
<span class="lineno">   67 </span>    |TtEnumMember
<span class="lineno">   68 </span>    |TtRecord
<span class="lineno">   69 </span>    |TtRecordMember
<span class="lineno">   70 </span>    |TtUserFunction
<span class="lineno">   71 </span>    |TtFunction
<span class="lineno">   72 </span>    |TtAttribute
<span class="lineno">   73 </span>    |TtAAC
<span class="lineno">   74 </span>    |TtVariable
<span class="lineno">   75 </span>    |TtKeyword
<span class="lineno">   76 </span>    |TtQuantifier
<span class="lineno">   77 </span>    |TtSubKeyword
<span class="lineno">   78 </span>    |TtOperator
<span class="lineno">   79 </span>    |TtLocal
<span class="lineno">   80 </span>    |TtOther Text
<span class="lineno">   81 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">   82 </span>data TaggedToken
<span class="lineno">   83 </span>    = TaggedToken TagType ETok
<span class="lineno">   84 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>class WithRegion a where
<span class="lineno">   88 </span>    getRegion :: (WithRegion a) =&gt; a -&gt; DiagnosticRegion
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>instance WithRegion (DiagnosticRegion,a) where
<span class="lineno">   91 </span>    <span class="decl"><span class="istickedoff">getRegion (r,_) = r</span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>instance WithRegion DiagnosticRegion where
<span class="lineno">   94 </span>    <span class="decl"><span class="istickedoff">getRegion = id</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>instance WithRegion LToken where
<span class="lineno">   97 </span>    <span class="decl"><span class="istickedoff">getRegion = symbolRegion</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>instance WithRegion SToken where
<span class="lineno">  100 </span>    <span class="decl"><span class="nottickedoff">getRegion = symbolRegion</span></span>
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>type RegionTagged a = (DiagnosticRegion,a)
<span class="lineno">  103 </span>unregion :: RegionTagged a -&gt; a
<span class="lineno">  104 </span><span class="decl"><span class="istickedoff">unregion (_,a) =a</span></span>
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>data Typed a = Typed Type a
<span class="lineno">  107 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  108 </span>instance Functor Typed where
<span class="lineno">  109 </span>  <span class="decl"><span class="nottickedoff">fmap f (Typed k a) = Typed k (f a)</span></span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- instance TypeOf (Typed a) where
<span class="lineno">  112 </span>--     typeOf (Typed () _) = return t
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>simple :: Type -&gt; Kind
<span class="lineno">  115 </span><span class="decl"><span class="istickedoff">simple = Kind ValueType</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>data Kind = Kind Class Type
<span class="lineno">  118 </span>    deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>instance Pretty Kind where
<span class="lineno">  121 </span>    -- pretty (Kind MemberType t) = &quot;Member of &quot; &lt;&gt; pretty t
<span class="lineno">  122 </span>    <span class="decl"><span class="nottickedoff">pretty (Kind DomainType t) = &quot;domain `&quot; &lt;&gt; pretty t &lt;&gt; &quot;`&quot;</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="nottickedoff">pretty (Kind ValueType t) = pretty t</span></span>
<span class="lineno">  124 </span>data Class = DomainType | ValueType 
<span class="lineno">  125 </span>    deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  126 </span>instance Pretty Class where
<span class="lineno">  127 </span>    <span class="decl"><span class="istickedoff">pretty c = case c of</span>
<span class="lineno">  128 </span><span class="spaces">      </span><span class="istickedoff">DomainType -&gt; &quot;Domain&quot;</span>
<span class="lineno">  129 </span><span class="spaces">      </span><span class="istickedoff">ValueType -&gt; &quot;Value&quot;</span></span>
<span class="lineno">  130 </span>untype :: Typed a -&gt; a
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">untype (Typed _ a) = a</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>typeOf_ :: Typed a -&gt; Type
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">typeOf_ (Typed t _) = t</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>untypeAs :: Type -&gt; Typed a -&gt; ValidatorS a
<span class="lineno">  137 </span><span class="decl"><span class="istickedoff">untypeAs r ((Typed t a)) = if let ?typeCheckerMode=StronglyTyped in typeUnify r t</span>
<span class="lineno">  138 </span><span class="spaces">                                </span><span class="istickedoff">then return <span class="nottickedoff">a</span></span>
<span class="lineno">  139 </span><span class="spaces">                                </span><span class="istickedoff">else contextTypeError <span class="nottickedoff">(TypeError r t)</span> &gt;&gt; return <span class="nottickedoff">a</span></span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>type TypeCheck a = Typed a -&gt; ValidatorS ()
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>exactly :: Type -&gt; TypeCheck a
<span class="lineno">  145 </span><span class="decl"><span class="istickedoff">exactly t r = void $ untypeAs t r</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>typeAs :: Type -&gt; Maybe a -&gt; Maybe (Typed a)
<span class="lineno">  148 </span><span class="decl"><span class="nottickedoff">typeAs t (Just a) = Just $ Typed t a</span>
<span class="lineno">  149 </span><span class="spaces"></span><span class="nottickedoff">typeAs _ Nothing = Nothing</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>(?=&gt;) :: ValidatorS (Typed a) -&gt; TypeCheck a -&gt; ValidatorS a
<span class="lineno">  152 </span><span class="decl"><span class="istickedoff">v ?=&gt; t = v &gt;&gt;= (\a -&gt; t a &gt;&gt; return (untype a))</span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>castAny :: Validator a -&gt; Validator (Typed a)
<span class="lineno">  155 </span><span class="decl"><span class="nottickedoff">castAny a = typeAs TypeAny &lt;$&gt; a</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>tInt :: Type
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">tInt = TypeInt TagInt</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>typeSplit :: Typed a -&gt; (Type,a)
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">typeSplit (Typed t v) = (t,v)</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>getTypeList :: [Typed a] -&gt; [(Type,a)]
<span class="lineno">  164 </span><span class="decl"><span class="nottickedoff">getTypeList = map typeSplit</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>data ErrorType
<span class="lineno">  167 </span>    = TokenError LToken
<span class="lineno">  168 </span>    | SyntaxError Text
<span class="lineno">  169 </span>    | WithReplacements ErrorType [Text]
<span class="lineno">  170 </span>    | SemanticError Text
<span class="lineno">  171 </span>    | CustomError Text
<span class="lineno">  172 </span>    | SkippedTokens
<span class="lineno">  173 </span>    | MissingArgsError Int Int
<span class="lineno">  174 </span>    | UnexpectedArg
<span class="lineno">  175 </span>    | TypeError Type Type -- Expected, got
<span class="lineno">  176 </span>    | ComplexTypeError Text Type -- Expected, got
<span class="lineno">  177 </span>    | KindError Class Class
<span class="lineno">  178 </span>    | InternalError --Used to explicitly tag invalid pattern matches
<span class="lineno">  179 </span>    | InternalErrorS Text -- Used for giving detail to bug messages
<span class="lineno">  180 </span>    deriving  (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff">Ord</span></span>)
<span class="lineno">  181 </span>data WarningType = UnclassifiedWarning Text 
<span class="lineno">  182 </span>                 | AmbiguousTypeWarning deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  183 </span>data InfoType = UnclassifiedInfo Text deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>data Diagnostic = Error ErrorType | Warning WarningType | Info InfoType
<span class="lineno">  187 </span>    deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="nottickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>data ValidatorDiagnostic = ValidatorDiagnostic DiagnosticRegion Diagnostic
<span class="lineno">  191 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>isError :: ValidatorDiagnostic -&gt; Bool
<span class="lineno">  194 </span><span class="decl"><span class="istickedoff">isError (ValidatorDiagnostic _ (Error _)) = True</span>
<span class="lineno">  195 </span><span class="spaces"></span><span class="istickedoff">isError _ = False</span></span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>data RegionType 
<span class="lineno">  198 </span>    = Definition Text Kind
<span class="lineno">  199 </span>    | LiteralDecl Kind
<span class="lineno">  200 </span>    | Ref Text Kind DiagnosticRegion
<span class="lineno">  201 </span>    | Structural StructuralType
<span class="lineno">  202 </span>    | Documentation DocType Text
<span class="lineno">  203 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  204 </span>data DocType = OperatorD | FunctionD | KeywordD | TypeD | AttributeD
<span class="lineno">  205 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  206 </span>data StructuralType 
<span class="lineno">  207 </span>    = SSuchThat 
<span class="lineno">  208 </span>    | SGiven 
<span class="lineno">  209 </span>    | SFind 
<span class="lineno">  210 </span>    | SLetting
<span class="lineno">  211 </span>    | SWhere
<span class="lineno">  212 </span>    | SBranching
<span class="lineno">  213 </span>    | SGoal Text
<span class="lineno">  214 </span>    | SEnum Text
<span class="lineno">  215 </span>    | SQuantification Text Kind
<span class="lineno">  216 </span>    | SComprehension Kind
<span class="lineno">  217 </span>    | SGuard
<span class="lineno">  218 </span>    | SGen
<span class="lineno">  219 </span>    | SBody
<span class="lineno">  220 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>data RegionInfo = RegionInfo {
<span class="lineno">  223 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rRegion</span></span></span> :: DiagnosticRegion,
<span class="lineno">  224 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rSubRegion</span></span></span> :: Maybe DiagnosticRegion,
<span class="lineno">  225 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rRegionType</span></span></span> :: RegionType,
<span class="lineno">  226 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">rChildren</span></span></span> :: [RegionInfo]
<span class="lineno">  227 </span>} deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  228 </span>
<span class="lineno">  229 </span>mkDeclaration :: DiagnosticRegion -&gt; Text -&gt; Kind -&gt; RegionInfo
<span class="lineno">  230 </span><span class="decl"><span class="nottickedoff">mkDeclaration r n (t) = RegionInfo r (Just r) (Definition n t) []</span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>mkLiteral :: DiagnosticRegion -&gt; Text -&gt; Typed a -&gt; RegionInfo
<span class="lineno">  233 </span><span class="decl"><span class="nottickedoff">mkLiteral r _ (Typed t _) = RegionInfo r (Just r) (LiteralDecl (simple t)) []</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>putReference :: DiagnosticRegion -&gt; Text -&gt; Kind -&gt; DiagnosticRegion -&gt; ValidatorS ()
<span class="lineno">  236 </span><span class="decl"><span class="istickedoff">putReference r n t ref = addRegion <span class="nottickedoff">(RegionInfo r Nothing (Ref n t ref) [])</span></span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>holdDeclarations :: ValidatorS a -&gt; ValidatorS (a,[RegionInfo])
<span class="lineno">  239 </span><span class="decl"><span class="istickedoff">holdDeclarations f = do</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">prev &lt;- gets regionInfo</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">modify (\s-&gt;s{regionInfo=[]})</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- f</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">decls &lt;- gets regionInfo</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">modify (\s-&gt;s{regionInfo=prev})</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">return (res,decls)</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>wrapRegion :: (Flattenable a,Flattenable b) =&gt; a -&gt; b -&gt; StructuralType -&gt; ValidatorS n -&gt; ValidatorS n
<span class="lineno">  248 </span><span class="decl"><span class="istickedoff">wrapRegion regMain regSel = wrapRegion' <span class="nottickedoff">(symbolRegion regMain)</span> <span class="nottickedoff">(symbolRegion regSel)</span></span></span> 
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>wrapRegion' ::  DiagnosticRegion -&gt; DiagnosticRegion -&gt; StructuralType -&gt; ValidatorS n -&gt; ValidatorS n
<span class="lineno">  251 </span><span class="decl"><span class="istickedoff">wrapRegion' regMain regSel ty f = do</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">(res,ds) &lt;- holdDeclarations f</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">rMain = regMain</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">rSel = Just $ regSel</span></span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">new = RegionInfo rMain rSel (Structural ty) ds</span></span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">unless (null ds) $ addRegion <span class="nottickedoff">new</span></span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">return res</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>-- injectRegion :: DiagnosticRegion -&gt; DiagnosticRegion -&gt; ()
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>putDocs :: Flattenable a =&gt; DocType -&gt; Text -&gt; a -&gt; ValidatorS ()
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">putDocs t nm r = addRegion $ <span class="nottickedoff">RegionInfo {rRegion=symbolRegion r,rSubRegion=Nothing, rRegionType=Documentation t nm,rChildren=[]}</span></span></span>
<span class="lineno">  263 </span>putKeywordDocs :: Flattenable a =&gt;Text -&gt;a -&gt; ValidatorS ()
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">putKeywordDocs = putDocs <span class="nottickedoff">KeywordD</span></span></span>
<span class="lineno">  265 </span>putTypeDoc :: Flattenable a =&gt;Text -&gt;a -&gt; ValidatorS ()
<span class="lineno">  266 </span><span class="decl"><span class="istickedoff">putTypeDoc = putDocs <span class="nottickedoff">TypeD</span></span></span> 
<span class="lineno">  267 </span>putAttrDoc :: Flattenable a =&gt;Text -&gt;a -&gt; ValidatorS ()
<span class="lineno">  268 </span><span class="decl"><span class="istickedoff">putAttrDoc = putDocs <span class="nottickedoff">AttributeD</span></span></span> 
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>--Infix symbol validation and tagging
<span class="lineno">  271 </span>isA ::  SToken -&gt; TagType -&gt; ValidatorS ()
<span class="lineno">  272 </span><span class="decl"><span class="istickedoff">isA a b= flagSToken a <span class="nottickedoff">b</span></span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>isA' ::  LToken -&gt; TagType -&gt; ValidatorS ()
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">isA' a b= validateSymbol a &gt;&gt; flagToken a <span class="nottickedoff">b</span></span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>are :: [LToken] -&gt; TagType -&gt; ValidatorS ()
<span class="lineno">  278 </span><span class="decl"><span class="istickedoff">are a b = mapM_ (`isA'` <span class="nottickedoff">b</span>) a</span></span>
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>flagToken :: LToken -&gt; TagType -&gt; ValidatorS ()
<span class="lineno">  281 </span><span class="decl"><span class="istickedoff">flagToken (RealToken s) c = flagSToken s <span class="nottickedoff">c</span></span>
<span class="lineno">  282 </span><span class="spaces"></span><span class="istickedoff">flagToken _ _ = return <span class="nottickedoff">()</span></span></span>
<span class="lineno">  283 </span>flagSToken :: SToken -&gt; TagType -&gt; ValidatorS ()
<span class="lineno">  284 </span><span class="decl"><span class="istickedoff">flagSToken (StrictToken _ t) c = modify (\x@ValidatorState{symbolCategories=sc}-&gt;x{symbolCategories= <span class="nottickedoff">M.insert t (TaggedToken c t) sc</span>})</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>tagWithType :: NameNode -&gt; Kind -&gt; ValidatorS ()
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">tagWithType (NameNode (NameNodeS lt)) (Kind ValueType ty) = flagSToken lt $ <span class="nottickedoff">case ty of</span></span>
<span class="lineno">  289 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeEnum _ -&gt; TtEnum</span></span>
<span class="lineno">  290 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeInt (TagEnum _) -&gt; TtEnumMember</span></span>
<span class="lineno">  291 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeInt (TagUnnamed _) -&gt; TtEnumMember</span></span>
<span class="lineno">  292 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeUnnamed _ -&gt; TtEnum</span></span>
<span class="lineno">  293 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeVariant _ -&gt; TtRecord</span></span>
<span class="lineno">  294 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeVariantMember {} -&gt; TtRecordMember</span></span>
<span class="lineno">  295 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeRecord _ -&gt; TtRecord</span></span>
<span class="lineno">  296 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeRecordMember {} -&gt; TtRecordMember</span></span>
<span class="lineno">  297 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeFunction _ _ -&gt; TtFunction</span></span>
<span class="lineno">  298 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeSequence _ -&gt; TtFunction</span></span>
<span class="lineno">  299 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">TypeRelation _ -&gt; TtFunction</span></span>
<span class="lineno">  300 </span><span class="spaces">   </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; TtVariable</span></span>
<span class="lineno">  301 </span><span class="spaces"></span><span class="istickedoff">tagWithType (NameNode (NameNodeS lt)) (Kind DomainType (TypeEnum{})) = <span class="nottickedoff">flagSToken lt TtEnum</span></span>
<span class="lineno">  302 </span><span class="spaces"></span><span class="istickedoff">tagWithType (NameNode (NameNodeS lt)) (Kind DomainType (TypeRecord{})) = <span class="nottickedoff">flagSToken lt TtRecord</span></span>
<span class="lineno">  303 </span><span class="spaces"></span><span class="istickedoff">tagWithType (NameNode (NameNodeS lt)) (Kind DomainType (TypeVariant{})) = <span class="nottickedoff">flagSToken lt TtRecord</span></span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff">tagWithType (NameNode (NameNodeS lt)) (Kind DomainType _) = flagSToken lt <span class="nottickedoff">TtDomain</span></span>
<span class="lineno">  305 </span><span class="spaces"></span><span class="istickedoff">tagWithType _ _ = <span class="nottickedoff">pure ()</span></span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>data ValidatorState = ValidatorState {
<span class="lineno">  309 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">typeChecking</span></span></span> :: Bool,
<span class="lineno">  310 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">regionInfo</span></span></span> :: [RegionInfo],
<span class="lineno">  311 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">symbolTable</span></span></span> :: SymbolTable,
<span class="lineno">  312 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">symbolCategories</span></span></span> ::Map ETok TaggedToken,
<span class="lineno">  313 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">currentContext</span></span></span> :: DiagnosticRegion
<span class="lineno">  314 </span>}
<span class="lineno">  315 </span>    deriving <span class="decl"><span class="nottickedoff">Show</span></span>
<span class="lineno">  316 </span>-- instance Default ValidatorState where
<span class="lineno">  317 </span>--     def = ValidatorState {
<span class="lineno">  318 </span>--         typeChecking = True,
<span class="lineno">  319 </span>--         regionInfo=[],
<span class="lineno">  320 </span>--         symbolCategories=M.empty,
<span class="lineno">  321 </span>--         symbolTable=M.empty
<span class="lineno">  322 </span>--         }
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>initialState :: Flattenable a =&gt; a -&gt; ValidatorState
<span class="lineno">  325 </span><span class="decl"><span class="istickedoff">initialState r = ValidatorState {</span>
<span class="lineno">  326 </span><span class="spaces">        </span><span class="istickedoff">typeChecking = <span class="nottickedoff">True</span>,</span>
<span class="lineno">  327 </span><span class="spaces">        </span><span class="istickedoff">regionInfo=<span class="nottickedoff">[]</span>,</span>
<span class="lineno">  328 </span><span class="spaces">        </span><span class="istickedoff">symbolCategories=<span class="nottickedoff">M.empty</span>,</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="istickedoff">symbolTable=M.empty,</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="istickedoff">currentContext=<span class="nottickedoff">symbolRegion r</span></span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="istickedoff">}</span></span>
<span class="lineno">  332 </span>type SymbolTable = (Map Text SymbolTableValue)
<span class="lineno">  333 </span>type SymbolTableValue = (DiagnosticRegion,Bool,Kind)
<span class="lineno">  334 </span>-- instance Show SymbolTableValue where
<span class="lineno">  335 </span>--     show (SType t) = show $ pretty t
<span class="lineno">  336 </span>--     show (SDomain d) = show $ pretty d 
<span class="lineno">  337 </span>newtype ValidatorT r w a = ValidatorT (StateT r (Writer [w]) a)
<span class="lineno">  338 </span>    deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Applicative</span></span></span></span></span></span></span></span></span></span> ,<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Functor</span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">MonadState r</span></span></span></span></span></span> ,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadWriter [w]</span></span></span></span></span></span></span></span>)
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>--synonym wrapped in maybe to allow errors to propagate
<span class="lineno">  342 </span>type Validator a = ValidatorT ValidatorState ValidatorDiagnostic (Maybe a)
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>--Non maybe version used in outward facing applications/ lists 
<span class="lineno">  345 </span>type ValidatorS a = ValidatorT ValidatorState ValidatorDiagnostic a
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>-- addEnumDefns ::  [Text] -&gt; SymbolTable -&gt; SymbolTable
<span class="lineno">  348 </span>-- addEnumDefns names (SymbolTable enums) = SymbolTable $ enums ++  map (\m -&gt; (m,&quot;Enum&quot;)) names
<span class="lineno">  349 </span>-- instance  MonadFail (ValidatorT ValidatorState ValidatorDiagnostic a) where
<span class="lineno">  350 </span>--     fail = return . fallback . T.pack
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>modifySymbolTable :: (SymbolTable -&gt; SymbolTable) -&gt; ValidatorS ()
<span class="lineno">  353 </span><span class="decl"><span class="istickedoff">modifySymbolTable f = modify (\x -&gt; x{symbolTable=f.symbolTable $ x})</span></span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>getSymbol :: Text -&gt; ValidatorS (Maybe SymbolTableValue)
<span class="lineno">  356 </span><span class="decl"><span class="istickedoff">getSymbol n = M.lookup n &lt;$&gt; getSymbolTable</span></span>
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>putSymbol :: (Name , SymbolTableValue) -&gt; ValidatorS Bool
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">putSymbol (Name name,t) = do</span>
<span class="lineno">  360 </span><span class="spaces">                    </span><span class="istickedoff">x &lt;- getSymbol name</span>
<span class="lineno">  361 </span><span class="spaces">                    </span><span class="istickedoff">modifySymbolTable (M.insert name t)</span>
<span class="lineno">  362 </span><span class="spaces">                    </span><span class="istickedoff">case x of</span>
<span class="lineno">  363 </span><span class="spaces">                      </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">False</span></span>
<span class="lineno">  364 </span><span class="spaces">                      </span><span class="istickedoff">Just _ -&gt; return <span class="nottickedoff">True</span></span>
<span class="lineno">  365 </span><span class="spaces"></span><span class="istickedoff">putSymbol _ = <span class="nottickedoff">return False</span></span></span> -- skip types for meta and machine vars
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>addRegion :: RegionInfo -&gt; ValidatorS ()
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">addRegion r = modify (\x-&gt;x{regionInfo=<span class="nottickedoff">r</span>:regionInfo x})</span></span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>makeEnumDomain :: Name -&gt; Maybe [Range Expression] -&gt; Domain () Expression
<span class="lineno">  372 </span><span class="decl"><span class="nottickedoff">makeEnumDomain n es = DomainEnum n es Nothing</span></span>
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>makeUnnamedDomain :: Name -&gt; Domain () ()
<span class="lineno">  375 </span><span class="decl"><span class="nottickedoff">makeUnnamedDomain n = DomainUnnamed n ()</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>getSymbolTable :: ValidatorS SymbolTable
<span class="lineno">  378 </span><span class="decl"><span class="istickedoff">getSymbolTable = symbolTable &lt;$&gt; get</span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>getContext :: ValidatorS DiagnosticRegion
<span class="lineno">  381 </span><span class="decl"><span class="istickedoff">getContext = currentContext &lt;$&gt; get</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>setContext :: DiagnosticRegion -&gt; ValidatorS ()
<span class="lineno">  384 </span><span class="decl"><span class="istickedoff">setContext r = modify (\p -&gt; p{currentContext = r})</span></span>
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>setContextFrom :: Flattenable a =&gt; a -&gt; ValidatorS ()
<span class="lineno">  387 </span><span class="decl"><span class="istickedoff">setContextFrom a = setContext $ symbolRegion a</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>-- strict :: Validator a -&gt; ValidatorS a
<span class="lineno">  390 </span>-- strict a = do res &lt;- a; return res
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>deState :: ((a,r),n) -&gt; (a,n,r)
<span class="lineno">  393 </span><span class="decl"><span class="istickedoff">deState ((a,r),n) = (a,n,<span class="nottickedoff">r</span>)</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>runValidator :: (ValidatorT r w a) -&gt; r -&gt; (a,[w],r)
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">runValidator (ValidatorT r) d = deState $ runWriter (runStateT r d)</span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>isSyntacticallyValid :: Flattenable a=&gt; (a-&gt;ValidatorS b) -&gt; a -&gt; Bool
<span class="lineno">  399 </span><span class="decl"><span class="nottickedoff">isSyntacticallyValid v s = case runValidator (v s) (initialState s){typeChecking=False} of </span>
<span class="lineno">  400 </span><span class="spaces">        </span><span class="nottickedoff">(_,vds,_) -&gt; not $ any isError vds</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>todoTypeAny :: Maybe a -&gt; Maybe (Typed a)
<span class="lineno">  403 </span><span class="decl"><span class="nottickedoff">todoTypeAny = typeAs TypeAny</span></span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>validateModel :: ProgramTree -&gt; ValidatorS Model
<span class="lineno">  408 </span><span class="decl"><span class="istickedoff">validateModel model = do</span>
<span class="lineno">  409 </span><span class="spaces">        </span><span class="istickedoff">langVersion &lt;- validateLanguageVersion $ langVersionInfo model</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">sts &lt;- validateProgramTree (statements  model)</span>
<span class="lineno">  411 </span><span class="spaces">        </span><span class="istickedoff">return $ Model (fromMaybe <span class="nottickedoff">def</span> langVersion) sts  def</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>
<span class="lineno">  414 </span>validateProgramTree :: [StatementNode] -&gt; ValidatorS [Statement]
<span class="lineno">  415 </span><span class="decl"><span class="istickedoff">validateProgramTree sts = do</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- validateArray validateStatement sts</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">return $ concat q</span></span>
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>validateLanguageVersion :: Maybe LangVersionNode -&gt; Validator LanguageVersion
<span class="lineno">  422 </span><span class="decl"><span class="istickedoff">validateLanguageVersion Nothing = return $ pure $ LanguageVersion &quot;Essence&quot; [1,3]</span>
<span class="lineno">  423 </span><span class="spaces"></span><span class="istickedoff">validateLanguageVersion (Just lv@(LangVersionNode l1 n v)) = do</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">lv</span></span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="istickedoff">name &lt;- validateIdentifier n</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff">checkLanguageName name</span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff">nums &lt;- catMaybes &lt;$&gt; validateSequence_ getNum v</span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="istickedoff">return . pure $</span>
<span class="lineno">  430 </span><span class="spaces">        </span><span class="istickedoff">LanguageVersion</span>
<span class="lineno">  431 </span><span class="spaces">            </span><span class="istickedoff">(Name $ name)</span>
<span class="lineno">  432 </span><span class="spaces">            </span><span class="istickedoff">(if <span class="tickonlyfalse">null nums</span> then <span class="nottickedoff">[1,3]</span> else nums)</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  434 </span><span class="spaces">        </span><span class="istickedoff">getNum :: SToken -&gt; Validator Int</span>
<span class="lineno">  435 </span><span class="spaces">        </span><span class="istickedoff">getNum c = do</span>
<span class="lineno">  436 </span><span class="spaces">            </span><span class="istickedoff">c' &lt;- validateSToken c</span>
<span class="lineno">  437 </span><span class="spaces">            </span><span class="istickedoff">case c' of</span>
<span class="lineno">  438 </span><span class="spaces">                </span><span class="istickedoff">(LIntLiteral x) -&gt; return . pure $ fromInteger x</span>
<span class="lineno">  439 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ c &lt;!&gt; InternalError</span></span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff">checkLanguageName (nm) | T.toLower nm == &quot;essence&quot;  = pure <span class="nottickedoff">()</span></span>
<span class="lineno">  441 </span><span class="spaces">                               </span><span class="istickedoff">| T.toLower nm == &quot;essence'&quot; = do</span>
<span class="lineno">  442 </span><span class="spaces">                                                    </span><span class="istickedoff">raiseError (symbolRegion lv /!\ UnclassifiedWarning &quot;Essence prime file detected, type checking is off&quot;)</span>
<span class="lineno">  443 </span><span class="spaces">                                                    </span><span class="istickedoff">modify (\s-&gt;s{typeChecking=False})</span>
<span class="lineno">  444 </span><span class="spaces">                               </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = (raiseError $ symbolRegion  n &lt;!&gt; SyntaxError &quot;Not a valid language name&quot;)</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>validateStatement :: StatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  448 </span><span class="decl"><span class="istickedoff">validateStatement (DeclarationStatement dsn) = validateDeclarationStatement dsn</span>
<span class="lineno">  449 </span><span class="spaces"></span><span class="istickedoff">validateStatement (BranchingStatement bsn) = validateBranchingStatement bsn</span>
<span class="lineno">  450 </span><span class="spaces"></span><span class="istickedoff">validateStatement (SuchThatStatement stsn) = validateSuchThatStatement stsn</span>
<span class="lineno">  451 </span><span class="spaces"></span><span class="istickedoff">validateStatement (WhereStatement wsn) = validateWhereStatement wsn</span>
<span class="lineno">  452 </span><span class="spaces"></span><span class="istickedoff">validateStatement (ObjectiveStatement osn) = validateObjectiveStatement osn</span>
<span class="lineno">  453 </span><span class="spaces"></span><span class="istickedoff">validateStatement (HeuristicStatement lt exp) = validateHeuristicStatement lt exp</span>
<span class="lineno">  454 </span><span class="spaces"></span><span class="istickedoff">validateStatement (UnexpectedToken lt) = return <span class="nottickedoff">[]</span> &lt;* (invalid $ lt &lt;!&gt; TokenError  lt)</span></span> --TODO address as part of skip token refactor
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>validateHeuristicStatement :: SToken -&gt; ExpressionNode -&gt; ValidatorS [Statement]
<span class="lineno">  457 </span><span class="decl"><span class="istickedoff">validateHeuristicStatement lt exp = do</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">let validHeuristics = [&quot;static&quot;, &quot;sdf&quot;, &quot;conflict&quot;, &quot;srf&quot;, &quot;ldf&quot;, &quot;wdeg&quot;, &quot;domoverwdeg&quot;]</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">h &lt;- case exp of</span>
<span class="lineno">  461 </span><span class="spaces">      </span><span class="istickedoff">IdentifierNode nn@(NameNodeS (StrictToken _ (ETok{lexeme=(LIdentifier nm)}))) -&gt; do</span>
<span class="lineno">  462 </span><span class="spaces">                    </span><span class="istickedoff">if nm `elem` validHeuristics then</span>
<span class="lineno">  463 </span><span class="spaces">                        </span><span class="istickedoff">return $ pure [SearchHeuristic  (Name nm)]</span>
<span class="lineno">  464 </span><span class="spaces">                    </span><span class="istickedoff">else</span>
<span class="lineno">  465 </span><span class="spaces">                        </span><span class="istickedoff">invalid $ symbolRegion nn &lt;!&gt; (SemanticError $ T.concat [&quot;Invalid heuristic &quot; , nm , &quot; Expected one of: &quot;, (pack $ show validHeuristics )])</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt;  <span class="nottickedoff">(invalid $ symbolRegion exp &lt;!&gt; SemanticError &quot;Only identifiers are allowed as heuristics&quot;)</span></span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">return $ fromMaybe <span class="nottickedoff">[]</span> h</span></span>
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>tCondition :: TypeCheck a
<span class="lineno">  471 </span><span class="decl"><span class="istickedoff">tCondition (Typed TypeAny _) = pure <span class="nottickedoff">()</span></span>
<span class="lineno">  472 </span><span class="spaces"></span><span class="istickedoff">tCondition (Typed TypeBool _) = pure <span class="nottickedoff">()</span></span>
<span class="lineno">  473 </span><span class="spaces"></span><span class="istickedoff">tCondition (Typed (TypeMatrix _ TypeBool) _) = <span class="nottickedoff">pure ()</span></span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="istickedoff">tCondition (Typed (TypeList TypeBool) _) = <span class="nottickedoff">pure ()</span></span>
<span class="lineno">  475 </span><span class="spaces"></span><span class="istickedoff">tCondition t = <span class="nottickedoff">contextTypeError $ ComplexTypeError &quot;Bool or [Bool]&quot; $ typeOf_ t</span></span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>validateWhereStatement :: WhereStatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  478 </span><span class="decl"><span class="istickedoff">validateWhereStatement w@(WhereStatementNode l1 exprs) = wrapRegion <span class="nottickedoff">w</span> <span class="nottickedoff">w</span> <span class="nottickedoff">SWhere</span> $ do</span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">ws &lt;-  Where &lt;$&gt; validateSequence_ (\x -&gt; do setContextFrom <span class="nottickedoff">x</span>; validateExpression x ?=&gt; tCondition) exprs</span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="istickedoff">return [ws]</span></span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>validateObjectiveStatement :: ObjectiveStatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  484 </span><span class="decl"><span class="istickedoff">validateObjectiveStatement o@(ObjectiveMin lt en) = wrapRegion <span class="nottickedoff">o</span> <span class="nottickedoff">o</span> <span class="nottickedoff">(SGoal &quot;Minimising&quot;)</span> $ do</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">exp &lt;- validateExpression en</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">return [Objective Minimising $ untype exp]</span>
<span class="lineno">  488 </span><span class="spaces"></span><span class="istickedoff">validateObjectiveStatement o@(ObjectiveMax lt en) =wrapRegion <span class="nottickedoff">o</span> <span class="nottickedoff">o</span> <span class="nottickedoff">(SGoal &quot;Maximising&quot;)</span> $ do</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  490 </span><span class="spaces">    </span><span class="istickedoff">exp &lt;- validateExpression en</span>
<span class="lineno">  491 </span><span class="spaces">    </span><span class="istickedoff">return  [Objective Maximising $ untype exp]</span></span>
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>validateSuchThatStatement :: SuchThatStatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  494 </span><span class="decl"><span class="istickedoff">validateSuchThatStatement s@(SuchThatStatementNode l1 l2 exprs) = wrapRegion <span class="nottickedoff">s</span> <span class="nottickedoff">s</span> <span class="nottickedoff">SSuchThat</span> $ do</span>
<span class="lineno">  495 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  496 </span><span class="spaces">    </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  497 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;such_that&quot;</span> <span class="nottickedoff">[flatten l1,flatten l2]</span></span>
<span class="lineno">  498 </span><span class="spaces">    </span><span class="istickedoff">exprs' &lt;- validateSequence validateExpression exprs</span>
<span class="lineno">  499 </span><span class="spaces">    </span><span class="istickedoff">bools &lt;- mapM (\(a,b)-&gt;do setContext <span class="nottickedoff">a</span>; return b ?=&gt; tCondition) exprs'</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">let bool_exprs = bools</span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">return [SuchThat  bool_exprs]</span></span>
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>validateBranchingStatement :: BranchingStatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  504 </span><span class="decl"><span class="istickedoff">validateBranchingStatement b@(BranchingStatementNode l1 l2 sts) = wrapRegion <span class="nottickedoff">b</span> <span class="nottickedoff">b</span> <span class="nottickedoff">SBranching</span> $ do</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  506 </span><span class="spaces">    </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;branchin_on&quot;</span> <span class="nottickedoff">[flatten l1,flatten l2]</span></span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="istickedoff">branchings &lt;-catMaybes &lt;$&gt; validateList_ (f2n validateBranchingParts) sts</span>
<span class="lineno">  509 </span><span class="spaces">    </span><span class="istickedoff">return [SearchOrder branchings]</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  511 </span><span class="spaces">        </span><span class="istickedoff">validateBranchingParts :: ExpressionNode -&gt; ValidatorS SearchOrder</span>
<span class="lineno">  512 </span><span class="spaces">        </span><span class="istickedoff">validateBranchingParts (IdentifierNode nn) =  do</span>
<span class="lineno">  513 </span><span class="spaces">            </span><span class="istickedoff">n &lt;- tagNameAs <span class="nottickedoff">TtVariable</span> nn</span>
<span class="lineno">  514 </span><span class="spaces">            </span><span class="istickedoff">return $ BranchingOn n</span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff">validateBranchingParts exp = do</span>
<span class="lineno">  516 </span><span class="spaces">            </span><span class="istickedoff">x &lt;- validateExpression exp ?=&gt; exactly TypeAny</span>
<span class="lineno">  517 </span><span class="spaces">            </span><span class="istickedoff">return $ Cut x</span></span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>validateDeclarationStatement :: DeclarationStatementNode -&gt; ValidatorS [Statement]
<span class="lineno">  520 </span><span class="decl"><span class="istickedoff">validateDeclarationStatement stmt = do</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="istickedoff">stmt' &lt;- case stmt of</span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">FindStatement l1 fs -&gt;  l1 `isA` <span class="nottickedoff">TtKeyword</span> &gt;&gt;putKeywordDocs <span class="nottickedoff">&quot;find&quot;</span> <span class="nottickedoff">l1</span> &gt;&gt; validateStatementSeq <span class="nottickedoff">SFind</span> validateFind fs</span>
<span class="lineno">  523 </span><span class="spaces">        </span><span class="istickedoff">GivenStatement l1 gs -&gt;  l1 `isA` <span class="nottickedoff">TtKeyword</span>  &gt;&gt;putKeywordDocs <span class="nottickedoff">&quot;given&quot;</span> <span class="nottickedoff">l1</span> &gt;&gt; validateStatementSeq <span class="nottickedoff">SGiven</span> validateGiven gs</span>
<span class="lineno">  524 </span><span class="spaces">        </span><span class="istickedoff">LettingStatement l1 ls -&gt;  l1 `isA` <span class="nottickedoff">TtKeyword</span>  &gt;&gt;putKeywordDocs <span class="nottickedoff">&quot;letting&quot;</span> <span class="nottickedoff">l1</span> &gt;&gt; validateStatementSeq <span class="nottickedoff">SLetting</span> validateLetting ls</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff">return  $ Declaration &lt;$&gt; stmt'</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  527 </span><span class="spaces">        </span><span class="istickedoff">validateStatementSeq s v l = wrapRegion <span class="nottickedoff">stmt</span> <span class="nottickedoff">stmt</span> <span class="nottickedoff">(s)</span> $ do</span>
<span class="lineno">  528 </span><span class="spaces">            </span><span class="istickedoff">decls &lt;- validateSequence_ v l</span>
<span class="lineno">  529 </span><span class="spaces">            </span><span class="istickedoff">when (null decls) $ <span class="nottickedoff">raiseError (symbolRegion stmt &lt;!&gt; SemanticError &quot;Declaration without any members&quot;)</span></span>
<span class="lineno">  530 </span><span class="spaces">            </span><span class="istickedoff">return $ concat decls</span></span>
<span class="lineno">  531 </span>
<span class="lineno">  532 </span>validateGiven :: GivenStatementNode -&gt; ValidatorS [Declaration]
<span class="lineno">  533 </span><span class="decl"><span class="istickedoff">validateGiven (GivenStatementNode idents l1 domain) =</span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  535 </span><span class="spaces">        </span><span class="istickedoff">checkSymbols [l1] -- Colon</span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff">names &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtVariable</span>) idents</span>
<span class="lineno">  537 </span><span class="spaces">        </span><span class="istickedoff">(dType, dom) &lt;- typeSplit &lt;$&gt; validateDomain domain</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">let memberType = getDomainMembers dType</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="istickedoff">let declarations = [<span class="nottickedoff">(mkDeclaration r n (simple memberType))</span> | (r, Name n) &lt;- names]</span>
<span class="lineno">  540 </span><span class="spaces">        </span><span class="istickedoff">mapM_ addRegion declarations</span>
<span class="lineno">  541 </span><span class="spaces">        </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x,(<span class="nottickedoff">r</span>,<span class="nottickedoff">False</span>,simple memberType)) ) names</span>
<span class="lineno">  542 </span><span class="spaces">        </span><span class="istickedoff">return  $ [ FindOrGiven Given nm dom|(_,nm) &lt;- names ]</span>
<span class="lineno">  543 </span><span class="spaces"></span><span class="istickedoff">validateGiven (GivenEnumNode se l1 l2 l3) =</span>
<span class="lineno">  544 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="istickedoff">[l1, l2, l3] `are` <span class="nottickedoff">TtKeyword</span> --new Type enum</span>
<span class="lineno">  546 </span><span class="spaces">        </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;new_type_enum&quot;</span> <span class="nottickedoff">[l1, l2, l3]</span></span>
<span class="lineno">  547 </span><span class="spaces">        </span><span class="istickedoff">names &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtEnum</span>) se</span>
<span class="lineno">  548 </span><span class="spaces">        </span><span class="istickedoff">let eType = Kind DomainType . TypeEnum</span>
<span class="lineno">  549 </span><span class="spaces">        </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x,(<span class="nottickedoff">r</span>,True,eType x) )) names</span>
<span class="lineno">  550 </span><span class="spaces">        </span><span class="istickedoff">return  $  [GivenDomainDefnEnum n | (_,n) &lt;- names]</span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>validateFind :: FindStatementNode -&gt; ValidatorS [Declaration]
<span class="lineno">  553 </span><span class="decl"><span class="istickedoff">validateFind (FindStatementNode names colon domain) = do</span>
<span class="lineno">  554 </span><span class="spaces">    </span><span class="istickedoff">checkSymbols [colon] --colon</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="istickedoff">names' &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtVariable</span>) names</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="istickedoff">(dType, dom) &lt;- typeSplit &lt;$&gt; validateDomain domain</span>
<span class="lineno">  557 </span><span class="spaces">    </span><span class="istickedoff">let memberType = getDomainMembers dType</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x,(<span class="nottickedoff">r</span>,False,simple memberType) )) names'</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">mapM_ addRegion [<span class="nottickedoff">mkDeclaration r n (simple memberType)</span> | (r, Name n) &lt;- names']</span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff">return  $ [ FindOrGiven Find nm dom|(_,nm) &lt;- names']</span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>validateLetting :: LettingStatementNode -&gt; ValidatorS [Declaration]
<span class="lineno">  563 </span>-- Letting [names] be
<span class="lineno">  564 </span><span class="decl"><span class="istickedoff">validateLetting (LettingStatementNode names l1 assign) = do</span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA'` <span class="nottickedoff">TtKeyword</span> --be</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">validateLettingAssignment names assign</span></span>
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>validateLettingAssignment :: Sequence NameNode -&gt; LettingAssignmentNode -&gt; ValidatorS [Declaration]
<span class="lineno">  569 </span><span class="decl"><span class="istickedoff">validateLettingAssignment names (LettingExpr en)  = do</span>
<span class="lineno">  570 </span><span class="spaces">    </span><span class="istickedoff">expr &lt;- validateExpression en</span>
<span class="lineno">  571 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">en</span></span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff">names' &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtVariable</span>) names</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">let (t,e) = typeSplit expr</span>
<span class="lineno">  574 </span><span class="spaces">    </span><span class="istickedoff">let declarations = [<span class="nottickedoff">mkDeclaration r n (simple t)</span> |(r, Name n) &lt;- names']</span>
<span class="lineno">  575 </span><span class="spaces">    </span><span class="istickedoff">mapM_ addRegion declarations</span>
<span class="lineno">  576 </span><span class="spaces">    </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x, (<span class="nottickedoff">r</span>,<span class="nottickedoff">False</span>,simple t) )) names'</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">return  $ [Letting n e | (_,n) &lt;- names']</span>
<span class="lineno">  578 </span><span class="spaces"></span><span class="istickedoff">validateLettingAssignment names (LettingDomain lt dn) = do</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;letting_domain&quot;</span> <span class="nottickedoff">[lt]</span></span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">(tDomain,domain) &lt;- typeSplit &lt;$&gt; validateDomain dn</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">names' &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtDomain</span>) names</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">let declarations = [ <span class="nottickedoff">mkDeclaration r n (Kind DomainType tDomain)</span> |(r, Name n) &lt;- names']</span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">mapM_ addRegion declarations</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x, (<span class="nottickedoff">r</span>,False,Kind DomainType tDomain))) names'</span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">return $ [Letting n  (Domain domain)| (_,n) &lt;- names']</span>
<span class="lineno">  587 </span><span class="spaces"></span><span class="istickedoff">validateLettingAssignment names (LettingEnum l1 l2 l3 enames) = do</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">[l1, l2, l3] `are` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno">  589 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;new_type_enum&quot;</span> <span class="nottickedoff">[l1,l2,l3]</span></span>
<span class="lineno">  590 </span><span class="spaces">    </span><span class="istickedoff">names' &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtEnum</span>) names</span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">memberNames &lt;- validateList (validateNameAs <span class="nottickedoff">TtEnumMember</span>) enames</span>
<span class="lineno">  592 </span><span class="spaces">    </span><span class="istickedoff">let members = map snd memberNames</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">-- let (members,memberDecls) = unzip . map (\(r,n)-&gt;(n,\t-&gt;mkDeclaration r n (Kind ValueType (TypeEnum t)))) $ memberNames</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="istickedoff">sequence_</span>
<span class="lineno">  595 </span><span class="spaces">        </span><span class="istickedoff">[</span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="istickedoff">wrapRegion' <span class="nottickedoff">(catRegions [(r,()),(symbolRegion enames,())])</span> <span class="nottickedoff">r</span> <span class="nottickedoff">(SEnum n)</span> $ do</span>
<span class="lineno">  597 </span><span class="spaces">                </span><span class="istickedoff">let nameMap = zip memberNames ([1..] :: [Int])</span>
<span class="lineno">  598 </span><span class="spaces">                </span><span class="istickedoff">let dType = Kind DomainType $ TypeEnum name</span>
<span class="lineno">  599 </span><span class="spaces">                </span><span class="istickedoff">let tVal = TypeInt $ TagEnum n</span>
<span class="lineno">  600 </span><span class="spaces">                </span><span class="istickedoff"></span>
<span class="lineno">  601 </span><span class="spaces">                </span><span class="istickedoff">putReference <span class="nottickedoff">r</span> <span class="nottickedoff">n</span> <span class="nottickedoff">dType</span> <span class="nottickedoff">r</span></span>
<span class="lineno">  602 </span><span class="spaces">                </span><span class="istickedoff">void $ putSymbol (Name n,(<span class="nottickedoff">r</span>,True,dType))</span>
<span class="lineno">  603 </span><span class="spaces">                </span><span class="istickedoff">mapM_ (</span>
<span class="lineno">  604 </span><span class="spaces">                    </span><span class="istickedoff">\((r',x),_) -&gt; do</span>
<span class="lineno">  605 </span><span class="spaces">                        </span><span class="istickedoff">let <span class="nottickedoff">n' = case x of Name nm -&gt; nm ; _ -&gt; &quot;&quot;</span></span>
<span class="lineno">  606 </span><span class="spaces">                        </span><span class="istickedoff">addRegion $ <span class="nottickedoff">mkDeclaration r' n' (simple $ TypeInt (TagEnum n))</span></span>
<span class="lineno">  607 </span><span class="spaces">                        </span><span class="istickedoff">putSymbol (x,(<span class="nottickedoff">r</span>,<span class="nottickedoff">False</span>,simple tVal))</span>
<span class="lineno">  608 </span><span class="spaces">                    </span><span class="istickedoff">) nameMap</span>
<span class="lineno">  609 </span><span class="spaces">            </span><span class="istickedoff">|(r, name@(Name n)) &lt;- names'</span>
<span class="lineno">  610 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">return $ [LettingDomainDefnEnum n members| (_,n) &lt;- names']</span>
<span class="lineno">  612 </span><span class="spaces"></span><span class="istickedoff">validateLettingAssignment names (LettingAnon l1 l2 l3 l4 szExp) = do</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">[l1, l2, l3, l4] `are` <span class="nottickedoff">TtKeyword</span> --TODO keywords</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;letting_anon&quot;</span> <span class="nottickedoff">[l1,l2,l3,l4]</span></span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">names' &lt;- validateSequence (validateNameAs <span class="nottickedoff">TtEnum</span>) names</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- do</span>
<span class="lineno">  617 </span><span class="spaces">                    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">szExp</span></span>
<span class="lineno">  618 </span><span class="spaces">                    </span><span class="istickedoff">validateExpression szExp ?=&gt; exactly tInt</span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="istickedoff">let d = Kind DomainType . TypeUnnamed</span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">mapM_ addRegion [<span class="nottickedoff">mkDeclaration r n (d $ Name n)</span>|(r,Name n)&lt;- names' ]</span>
<span class="lineno">  621 </span><span class="spaces">    </span><span class="istickedoff">mapM_ (\(r,x) -&gt; putSymbol (x,(<span class="nottickedoff">r</span>,False,d x))) names'</span>
<span class="lineno">  622 </span><span class="spaces">    </span><span class="istickedoff">return  $ [LettingDomainDefnUnnamed n size| (_,n) &lt;- names']</span></span>
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>invalid :: ValidatorDiagnostic -&gt; Validator a
<span class="lineno">  626 </span><span class="decl"><span class="istickedoff">invalid err = do</span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="istickedoff">raiseError err</span>
<span class="lineno">  628 </span><span class="spaces">    </span><span class="istickedoff">return <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>validateSToken :: SToken -&gt; ValidatorS Lexeme
<span class="lineno">  631 </span><span class="decl"><span class="istickedoff">validateSToken (StrictToken ss t) = do</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">checkSymbols (map <span class="nottickedoff">SkippedToken</span> ss)</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff">return $ lexeme t</span></span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>validateSymbol :: LToken -&gt; Validator Lexeme
<span class="lineno">  636 </span><span class="decl"><span class="istickedoff">validateSymbol s =</span>
<span class="lineno">  637 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="istickedoff">RealToken st -&gt; do</span>
<span class="lineno">  639 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">pure</span> &lt;$&gt; validateSToken st</span>
<span class="lineno">  640 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; invalid $ ValidatorDiagnostic (getRegion s) $ Error $ TokenError s</span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>-- [MissingTokenError ]
<span class="lineno">  643 </span>getValueType :: Kind -&gt; ValidatorS Type
<span class="lineno">  644 </span><span class="decl"><span class="istickedoff">getValueType (Kind ValueType t) = pure t</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="istickedoff">getValueType (Kind k _) = do</span>
<span class="lineno">  646 </span><span class="spaces">    </span><span class="istickedoff">contextTypeError $ KindError ValueType k</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">return TypeAny</span></span>
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>getDomainType :: Kind -&gt; ValidatorS Type
<span class="lineno">  650 </span><span class="decl"><span class="istickedoff">getDomainType (Kind DomainType t) = pure t</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="istickedoff">getDomainType (Kind k _) = do</span>
<span class="lineno">  652 </span><span class="spaces">    </span><span class="istickedoff">contextTypeError $ KindError DomainType k</span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="istickedoff">return TypeAny</span></span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>type TypedDomain = Typed (Domain () Expression)
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>type DomainValidator = Validator TypedDomain
<span class="lineno">  658 </span>
<span class="lineno">  659 </span>validateDomainWithRepr :: DomainNode -&gt; ValidatorS (Typed (Domain HasRepresentation Expression))
<span class="lineno">  660 </span><span class="decl"><span class="nottickedoff">validateDomainWithRepr dom = do</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="nottickedoff">(t,dom') &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno">  662 </span><span class="spaces">    </span><span class="nottickedoff">return . (Typed t) $ changeRepr NoRepresentation dom'</span></span>
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>validateDomain :: DomainNode -&gt; ValidatorS TypedDomain
<span class="lineno">  665 </span><span class="decl"><span class="istickedoff">validateDomain dm = case dm of</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">ParenDomainNode _ dom rt -&gt; do checkSymbols [rt] ; validateDomain dom</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="istickedoff">MetaVarDomain lt -&gt;  <span class="nottickedoff">do mv &lt;- validateMetaVar lt ; return . Typed TypeAny $ DomainMetaVar mv</span></span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">BoolDomainNode lt -&gt; (lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; (return . Typed TypeBool) DomainBool)</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff">RangedIntDomainNode l1 rs -&gt; do</span>
<span class="lineno">  670 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="istickedoff">validateRangedInt rs</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="istickedoff">RangedEnumNode nn ranges -&gt; validateEnumRange nn ranges</span>
<span class="lineno">  673 </span><span class="spaces">    </span><span class="istickedoff">ShortTupleDomainNode lst -&gt; validateTupleDomain lst</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">TupleDomainNode l1 doms -&gt; do</span>
<span class="lineno">  675 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  676 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;tuple&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  677 </span><span class="spaces">        </span><span class="istickedoff">validateTupleDomain doms</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="istickedoff">RecordDomainNode l1 ndom -&gt; do</span>
<span class="lineno">  679 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;record&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  681 </span><span class="spaces">        </span><span class="istickedoff">validateRecordDomain ndom</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="istickedoff">VariantDomainNode l1 ndom -&gt; do</span>
<span class="lineno">  683 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  684 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;variant&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="istickedoff">validateVariantDomain ndom</span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="istickedoff">MatrixDomainNode l1 m_ib idoms l2 dom -&gt; do</span>
<span class="lineno">  687 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span> </span>
<span class="lineno">  688 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;matrix&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  689 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  690 </span><span class="spaces">        </span><span class="istickedoff">validateIndexedByNode m_ib</span>
<span class="lineno">  691 </span><span class="spaces">        </span><span class="istickedoff">validateMatrixDomain idoms dom</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">SetDomainNode l1 attrs l2 dom -&gt; do</span>
<span class="lineno">  693 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span> </span>
<span class="lineno">  694 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;set&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  695 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  696 </span><span class="spaces">        </span><span class="istickedoff">validateSetDomain attrs dom</span>
<span class="lineno">  697 </span><span class="spaces">    </span><span class="istickedoff">MSetDomainNode l1 attrs l2 dom -&gt; do</span>
<span class="lineno">  698 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span> </span>
<span class="lineno">  699 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;mset&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  700 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  701 </span><span class="spaces">        </span><span class="istickedoff">validateMSetDomain attrs dom</span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="istickedoff">FunctionDomainNode l1 attrs dom1 l2 dom2 -&gt; do</span>
<span class="lineno">  703 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span> </span>
<span class="lineno">  704 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;function&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  705 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtOperator</span></span>
<span class="lineno">  706 </span><span class="spaces">        </span><span class="istickedoff">validateFunctionDomain attrs dom1 dom2</span>
<span class="lineno">  707 </span><span class="spaces">    </span><span class="istickedoff">SequenceDomainNode l1 attrs l2 dom -&gt; do</span>
<span class="lineno">  708 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  709 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;sequence&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  710 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  711 </span><span class="spaces">        </span><span class="istickedoff">validateSequenceDomain attrs dom</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="istickedoff">RelationDomainNode l1 attrs l2 doms -&gt; do</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  714 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;relation&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  715 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  716 </span><span class="spaces">        </span><span class="istickedoff">validateRelationDomain attrs doms</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">PartitionDomainNode l1 attrs l2 dom -&gt; do</span>
<span class="lineno">  718 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno">  719 </span><span class="spaces">        </span><span class="istickedoff">putTypeDoc <span class="nottickedoff">&quot;partition&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtSubKeyword</span></span>
<span class="lineno">  721 </span><span class="spaces">        </span><span class="istickedoff">validatePartitionDomain attrs dom</span>
<span class="lineno">  722 </span><span class="spaces">    </span><span class="istickedoff">MissingDomainNode lt -&gt; do raiseError $ lt &lt;!&gt; TokenError lt; return $ fallback <span class="nottickedoff">&quot;Missing Domain&quot;</span></span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  724 </span><span class="spaces">    </span><span class="istickedoff">validateRangedInt :: Maybe (ListNode RangeNode) -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff">validateRangedInt (Just (ListNode _ (Seq [SeqElem a _]) _)) = do</span>
<span class="lineno">  726 </span><span class="spaces">            </span><span class="istickedoff">d &lt;- case a of</span>
<span class="lineno">  727 </span><span class="spaces">              </span><span class="istickedoff">SingleRangeNode en -&gt; do</span>
<span class="lineno">  728 </span><span class="spaces">                </span><span class="istickedoff">(t,e) &lt;- typeSplit &lt;$&gt; validateExpression en</span>
<span class="lineno">  729 </span><span class="spaces">                </span><span class="istickedoff">case t of</span>
<span class="lineno">  730 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt TagInt -&gt; return $ DomainInt TagInt [RangeSingle e]</span>
<span class="lineno">  731 </span><span class="spaces">                    </span><span class="istickedoff">TypeMatrix _ _ -&gt; <span class="nottickedoff">return $ DomainIntE e</span></span>
<span class="lineno">  732 </span><span class="spaces">                    </span><span class="istickedoff">TypeList _ -&gt; return $ DomainIntE e</span>
<span class="lineno">  733 </span><span class="spaces">                    </span><span class="istickedoff">TypeSet _ -&gt; <span class="nottickedoff">return $ DomainIntE e</span></span>
<span class="lineno">  734 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(DomainIntE e) &lt;$ raiseTypeError (symbolRegion en &lt;!&gt; ComplexTypeError &quot;Set/List of int or Int&quot; t)</span></span>
<span class="lineno">  735 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno">  736 </span><span class="spaces">                </span><span class="istickedoff">r &lt;- validateRange tInt a</span>
<span class="lineno">  737 </span><span class="spaces">                </span><span class="istickedoff">return $ DomainInt TagInt [r]</span>
<span class="lineno">  738 </span><span class="spaces">            </span><span class="istickedoff">return $ Typed tInt d</span>
<span class="lineno">  739 </span><span class="spaces">    </span><span class="istickedoff">validateRangedInt (Just ranges) = do</span>
<span class="lineno">  740 </span><span class="spaces">        </span><span class="istickedoff">ranges' &lt;-  catMaybes &lt;$&gt; validateList_ (f2n (validateRange tInt)) ranges</span>
<span class="lineno">  741 </span><span class="spaces">        </span><span class="istickedoff">return . Typed tInt $ DomainInt TagInt ranges'</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">validateRangedInt Nothing = return . Typed tInt $ DomainInt TagInt []</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">validateEnumRange :: NameNodeS -&gt; Maybe (ListNode RangeNode) -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">validateEnumRange name@(NameNodeS n) ranges = do</span>
<span class="lineno">  745 </span><span class="spaces">        </span><span class="istickedoff">flagSToken n <span class="nottickedoff">TtEnum</span></span>
<span class="lineno">  746 </span><span class="spaces">        </span><span class="istickedoff">setContextFrom name</span>
<span class="lineno">  747 </span><span class="spaces">        </span><span class="istickedoff">name' &lt;- validateIdentifierS name</span>
<span class="lineno">  748 </span><span class="spaces">        </span><span class="istickedoff">_ &lt;- resolveReference (symbolRegion name,Name name')</span>
<span class="lineno">  749 </span><span class="spaces">        </span><span class="istickedoff">a &lt;- getSymbol name'</span>
<span class="lineno">  750 </span><span class="spaces">        </span><span class="istickedoff">case a of</span>
<span class="lineno">  751 </span><span class="spaces">            </span><span class="istickedoff">Just (_,True,t) -&gt; do</span>
<span class="lineno">  752 </span><span class="spaces">                </span><span class="istickedoff">t' &lt;- getDomainType t</span>
<span class="lineno">  753 </span><span class="spaces">                </span><span class="istickedoff">rs &lt;-case ranges of</span>
<span class="lineno">  754 </span><span class="spaces">                    </span><span class="istickedoff">Just rs -&gt; pure . catMaybes &lt;$&gt; validateList_ (f2n $ validateRange (getDomainMembers t')) rs</span>
<span class="lineno">  755 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  756 </span><span class="spaces">                </span><span class="istickedoff">return $ Typed  t' $ DomainEnum (Name name') rs Nothing</span>
<span class="lineno">  757 </span><span class="spaces">            </span><span class="istickedoff">Just (_,False,t) -&gt; do</span>
<span class="lineno">  758 </span><span class="spaces">                </span><span class="istickedoff">t' &lt;- getDomainType t</span>
<span class="lineno">  759 </span><span class="spaces">                </span><span class="istickedoff">case ranges of</span>
<span class="lineno">  760 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt; return . Typed t' $  DomainReference (Name name') Nothing</span>
<span class="lineno">  761 </span><span class="spaces">                    </span><span class="istickedoff">Just rs -&gt; do</span>
<span class="lineno">  762 </span><span class="spaces">                        </span><span class="istickedoff">void $ validateList_ (f2n (validateRange TypeAny)) rs</span>
<span class="lineno">  763 </span><span class="spaces">                        </span><span class="istickedoff">raiseError (symbolRegion  name &lt;!&gt; SemanticError &quot;range not supported on non enum ranges&quot;)</span>
<span class="lineno">  764 </span><span class="spaces">                        </span><span class="istickedoff">return . Typed t' $ <span class="nottickedoff">DomainReference (Name name') Nothing</span></span>
<span class="lineno">  765 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ fallback <span class="nottickedoff">&quot;unknown symbol&quot;</span></span>
<span class="lineno">  766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="istickedoff">validateTupleDomain :: ListNode DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="istickedoff">validateTupleDomain doms = do</span>
<span class="lineno">  769 </span><span class="spaces">        </span><span class="istickedoff">(ts,ds) &lt;- unzip . map typeSplit &lt;$&gt; validateList_ validateDomain doms</span>
<span class="lineno">  770 </span><span class="spaces">        </span><span class="istickedoff">return $ Typed (TypeTuple ts)  (DomainTuple  ds)</span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="istickedoff">validateRecordDomain :: ListNode NamedDomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  772 </span><span class="spaces">    </span><span class="istickedoff">validateRecordDomain namedDoms = do</span>
<span class="lineno">  773 </span><span class="spaces">                </span><span class="istickedoff">lst &lt;- validateList  (f2n validateNamedDomainInVariant) namedDoms</span>
<span class="lineno">  774 </span><span class="spaces">                </span><span class="istickedoff">let lst' = mapMaybe (\(r,m)-&gt;(\x-&gt;(<span class="nottickedoff">r</span>,x))&lt;$&gt;m) lst</span>
<span class="lineno">  775 </span><span class="spaces">                </span><span class="istickedoff">let (ts,ds) = unzip $ map (\(r,(x,typeSplit-&gt;(t,d)))-&gt;((x,t),(<span class="nottickedoff">r</span>,(x,d)))) lst'</span>
<span class="lineno">  776 </span><span class="spaces">                </span><span class="istickedoff">--push members</span>
<span class="lineno">  777 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">t n = Kind ValueType $ TypeRecordMember n ts</span></span>
<span class="lineno">  778 </span><span class="spaces">                </span><span class="istickedoff">mapM_ (\(r,(a,_))-&gt;putSymbol (a,(<span class="nottickedoff">r</span>,<span class="nottickedoff">False</span>,<span class="nottickedoff">t a</span>))) ds</span>
<span class="lineno">  779 </span><span class="spaces">                </span><span class="istickedoff">return $ Typed (TypeRecord ts) (DomainRecord (unregion &lt;$&gt; ds))</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="istickedoff">validateVariantDomain :: ListNode NamedDomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="istickedoff">validateVariantDomain namedDoms = do</span>
<span class="lineno">  782 </span><span class="spaces">                </span><span class="istickedoff">lst &lt;- validateList (f2n validateNamedDomainInVariant) namedDoms</span>
<span class="lineno">  783 </span><span class="spaces">                </span><span class="istickedoff">let lst' = mapMaybe (\(r,m)-&gt;(\x-&gt;(<span class="nottickedoff">r</span>,x))&lt;$&gt;m) lst</span>
<span class="lineno">  784 </span><span class="spaces">                </span><span class="istickedoff">let (ts,ds) = unzip $ map (\(r,(x,typeSplit-&gt;(t,d)))-&gt;((x,t),(<span class="nottickedoff">r</span>,(x,d)))) lst'</span>
<span class="lineno">  785 </span><span class="spaces">                </span><span class="istickedoff">--push members</span>
<span class="lineno">  786 </span><span class="spaces">                </span><span class="istickedoff">let t n = Kind ValueType $ TypeVariantMember  n <span class="nottickedoff">ts</span></span>
<span class="lineno">  787 </span><span class="spaces">                </span><span class="istickedoff">mapM_ (\(r,(a,_))-&gt;putSymbol (a,(<span class="nottickedoff">r</span>,<span class="nottickedoff">False</span>,t a))) ds</span>
<span class="lineno">  788 </span><span class="spaces">                </span><span class="istickedoff">return $ Typed (TypeVariant ts) (DomainVariant (unregion &lt;$&gt; ds))</span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="istickedoff">validateMatrixDomain :: ListNode DomainNode -&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  790 </span><span class="spaces">    </span><span class="istickedoff">validateMatrixDomain indexes dom = do</span>
<span class="lineno">  791 </span><span class="spaces">        </span><span class="istickedoff">idoms &lt;-  validateList_ validateDomain indexes</span>
<span class="lineno">  792 </span><span class="spaces">        </span><span class="istickedoff">dom' &lt;-  validateDomain dom</span>
<span class="lineno">  793 </span><span class="spaces">        </span><span class="istickedoff">return $ foldr acc dom' idoms</span>
<span class="lineno">  794 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  795 </span><span class="spaces">            </span><span class="istickedoff">acc :: TypedDomain -&gt; TypedDomain -&gt; TypedDomain</span>
<span class="lineno">  796 </span><span class="spaces">            </span><span class="istickedoff">acc (Typed t d) (Typed t' d') = Typed (TypeMatrix t t') (DomainMatrix d d')</span>
<span class="lineno">  797 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  799 </span><span class="spaces">    </span><span class="istickedoff">validateSetDomain :: Maybe (ListNode AttributeNode) -&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  800 </span><span class="spaces">    </span><span class="istickedoff">validateSetDomain attrs dom = do</span>
<span class="lineno">  801 </span><span class="spaces">        </span><span class="istickedoff">let repr = ()</span>
<span class="lineno">  802 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  803 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validateSetAttributes a</span>
<span class="lineno">  804 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return def</span>
<span class="lineno">  805 </span><span class="spaces">        </span><span class="istickedoff">(t,dom') &lt;- typeSplit &lt;$&gt;  validateDomain dom</span>
<span class="lineno">  806 </span><span class="spaces">        </span><span class="istickedoff">return . Typed (TypeSet t) $ DomainSet repr attrs' dom'</span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="istickedoff">validateMSetDomain :: Maybe (ListNode AttributeNode) -&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">validateMSetDomain attrs dom = do</span>
<span class="lineno">  810 </span><span class="spaces">        </span><span class="istickedoff">let repr = ()</span>
<span class="lineno">  811 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  812 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validateMSetAttributes a</span>
<span class="lineno">  813 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ def</span>
<span class="lineno">  814 </span><span class="spaces">        </span><span class="istickedoff">(t,dom') &lt;- typeSplit &lt;$&gt;  validateDomain dom</span>
<span class="lineno">  815 </span><span class="spaces">        </span><span class="istickedoff">return . Typed (TypeMSet  t) $ DomainMSet  repr  attrs' dom'</span>
<span class="lineno">  816 </span><span class="spaces">    </span><span class="istickedoff">validateFunctionDomain :: Maybe (ListNode AttributeNode) -&gt; DomainNode -&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  817 </span><span class="spaces">    </span><span class="istickedoff">validateFunctionDomain attrs dom1 dom2 = do</span>
<span class="lineno">  818 </span><span class="spaces">        </span><span class="istickedoff">let <span class="nottickedoff">_repr = Just ()</span> --placeholder if this gets implemented in future</span>
<span class="lineno">  819 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  820 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validateFuncAttributes a</span>
<span class="lineno">  821 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ def</span>
<span class="lineno">  822 </span><span class="spaces">        </span><span class="istickedoff">(t1,d1) &lt;- typeSplit &lt;$&gt; validateDomain dom1</span>
<span class="lineno">  823 </span><span class="spaces">        </span><span class="istickedoff">(t2,d2) &lt;- typeSplit &lt;$&gt; validateDomain dom2</span>
<span class="lineno">  824 </span><span class="spaces">        </span><span class="istickedoff">let dType = Typed $ TypeFunction t1 t2</span>
<span class="lineno">  825 </span><span class="spaces">        </span><span class="istickedoff">return . dType $ DomainFunction () attrs' d1 d2</span>
<span class="lineno">  826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  827 </span><span class="spaces">    </span><span class="istickedoff">-- attrs &lt;- validateAttributes</span>
<span class="lineno">  828 </span><span class="spaces">    </span><span class="istickedoff">validateSequenceDomain :: Maybe (ListNode AttributeNode) -&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  829 </span><span class="spaces">    </span><span class="istickedoff">validateSequenceDomain attrs dom = do</span>
<span class="lineno">  830 </span><span class="spaces">        </span><span class="istickedoff">let repr = ()</span>
<span class="lineno">  831 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  832 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validateSeqAttributes a</span>
<span class="lineno">  833 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ def</span>
<span class="lineno">  834 </span><span class="spaces">        </span><span class="istickedoff">(t,dom') &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno">  835 </span><span class="spaces">        </span><span class="istickedoff">return . Typed (TypeSequence t) $ DomainSequence  repr  attrs'  dom'</span>
<span class="lineno">  836 </span><span class="spaces">    </span><span class="istickedoff">validateRelationDomain ::Maybe (ListNode AttributeNode)-&gt; ListNode DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="istickedoff">validateRelationDomain attrs doms = do</span>
<span class="lineno">  838 </span><span class="spaces">        </span><span class="istickedoff">let repr =  ()</span>
<span class="lineno">  839 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  840 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validateRelationAttributes a</span>
<span class="lineno">  841 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $  def</span>
<span class="lineno">  842 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  843 </span><span class="spaces">        </span><span class="istickedoff">(ts,doms') &lt;- unzip . map typeSplit &lt;$&gt; validateList_ validateDomain doms</span>
<span class="lineno">  844 </span><span class="spaces">        </span><span class="istickedoff">return . Typed (TypeRelation ts) $ DomainRelation repr  attrs' doms'</span>
<span class="lineno">  845 </span><span class="spaces">    </span><span class="istickedoff">validatePartitionDomain :: Maybe (ListNode AttributeNode)-&gt; DomainNode -&gt; ValidatorS TypedDomain</span>
<span class="lineno">  846 </span><span class="spaces">    </span><span class="istickedoff">validatePartitionDomain attrs dom = do</span>
<span class="lineno">  847 </span><span class="spaces">        </span><span class="istickedoff">let repr = ()</span>
<span class="lineno">  848 </span><span class="spaces">        </span><span class="istickedoff">attrs' &lt;- case attrs of</span>
<span class="lineno">  849 </span><span class="spaces">            </span><span class="istickedoff">Just a -&gt;  validatePartitionAttributes a</span>
<span class="lineno">  850 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ def</span>
<span class="lineno">  851 </span><span class="spaces">        </span><span class="istickedoff">(t,dom') &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno">  852 </span><span class="spaces">        </span><span class="istickedoff">return . Typed  (TypePartition t) $ DomainPartition repr attrs' dom'</span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>validateIndexedByNode :: Maybe IndexedByNode -&gt; ValidatorS ()
<span class="lineno">  855 </span><span class="decl"><span class="istickedoff">validateIndexedByNode Nothing = return <span class="nottickedoff">()</span></span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="istickedoff">validateIndexedByNode (Just (IndexedByNode a b)) = [a,b] `are` <span class="nottickedoff">TtSubKeyword</span></span></span>
<span class="lineno">  857 </span>
<span class="lineno">  858 </span>todo :: Text -&gt; Validator a
<span class="lineno">  859 </span><span class="decl"><span class="nottickedoff">todo s = invalid $ ValidatorDiagnostic global $ Error $ InternalErrorS (append &quot;Not Implemented: &quot; s)</span></span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>validateSizeAttributes :: [(Lexeme,Maybe Expression)] -&gt; ValidatorS (SizeAttr Expression)
<span class="lineno">  862 </span><span class="decl"><span class="istickedoff">validateSizeAttributes attrs = do</span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="istickedoff">let sizeAttrs = [L_size,L_minSize,L_maxSize]</span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="istickedoff">let filtered = sort $ filter (\x -&gt; fst x `elem` sizeAttrs) attrs</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">case filtered of</span>
<span class="lineno">  866 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; return $  SizeAttr_None</span>
<span class="lineno">  867 </span><span class="spaces">      </span><span class="istickedoff">[(L_size,Just a)] -&gt; return $  (SizeAttr_Size a)</span>
<span class="lineno">  868 </span><span class="spaces">      </span><span class="istickedoff">[(L_minSize, Just a)] -&gt; return $  (SizeAttr_MinSize a)</span>
<span class="lineno">  869 </span><span class="spaces">      </span><span class="istickedoff">[(L_maxSize, Just a)] -&gt; return $  (SizeAttr_MaxSize a)</span>
<span class="lineno">  870 </span><span class="spaces">      </span><span class="istickedoff">[(L_minSize, Just a),(L_maxSize, Just b)] -&gt; return $ (SizeAttr_MinMaxSize a b)</span>
<span class="lineno">  871 </span><span class="spaces">      </span><span class="istickedoff">as -&gt; <span class="nottickedoff">return . def &lt;* contextError $ SemanticError $ pack $ &quot;Incompatible attributes size:&quot; ++ show as</span></span></span>
<span class="lineno">  872 </span>
<span class="lineno">  873 </span>validatePartSizeAttributes :: [(Lexeme,Maybe Expression)] -&gt; ValidatorS (SizeAttr Expression)
<span class="lineno">  874 </span><span class="decl"><span class="istickedoff">validatePartSizeAttributes attrs = do</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="istickedoff">let sizeAttrs = [L_partSize,L_minPartSize,L_maxPartSize]</span>
<span class="lineno">  876 </span><span class="spaces">    </span><span class="istickedoff">let filtered = sort $ filter (\x -&gt; fst x `elem` sizeAttrs) attrs</span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="istickedoff">case filtered of</span>
<span class="lineno">  878 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; return $  SizeAttr_None</span>
<span class="lineno">  879 </span><span class="spaces">      </span><span class="istickedoff">[(L_partSize,Just a)] -&gt; return $  (SizeAttr_Size a)</span>
<span class="lineno">  880 </span><span class="spaces">      </span><span class="istickedoff">[(L_minPartSize, Just a)] -&gt; return $  (SizeAttr_MinSize a)</span>
<span class="lineno">  881 </span><span class="spaces">      </span><span class="istickedoff">[(L_maxPartSize, Just a)] -&gt; return $  (SizeAttr_MaxSize a)</span>
<span class="lineno">  882 </span><span class="spaces">      </span><span class="istickedoff">[(L_minPartSize, Just a),(L_maxPartSize, Just b)] -&gt; return $  (SizeAttr_MinMaxSize a b)</span>
<span class="lineno">  883 </span><span class="spaces">      </span><span class="istickedoff">as -&gt; <span class="nottickedoff">return . def &lt;* contextError $ SemanticError $ pack $ &quot;Incompatible attributes partitionSize :&quot; ++ show as</span></span></span>
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>validateNumPartAttributes :: [(Lexeme,Maybe Expression)] -&gt; ValidatorS (SizeAttr Expression)
<span class="lineno">  886 </span><span class="decl"><span class="istickedoff">validateNumPartAttributes attrs = do</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="istickedoff">let sizeAttrs = [L_numParts,L_maxNumParts,L_minNumParts]</span>
<span class="lineno">  888 </span><span class="spaces">    </span><span class="istickedoff">let filtered = sort $ filter (\x -&gt; fst x `elem` sizeAttrs) attrs</span>
<span class="lineno">  889 </span><span class="spaces">    </span><span class="istickedoff">case filtered of</span>
<span class="lineno">  890 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; return $  SizeAttr_None</span>
<span class="lineno">  891 </span><span class="spaces">      </span><span class="istickedoff">[(L_numParts,Just a)] -&gt; return $  (SizeAttr_Size a)</span>
<span class="lineno">  892 </span><span class="spaces">      </span><span class="istickedoff">[(L_minNumParts, Just a)] -&gt; return $  (SizeAttr_MinSize a)</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="istickedoff">[(L_maxNumParts, Just a)] -&gt; return $  (SizeAttr_MaxSize a)</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="istickedoff">[(L_minNumParts, Just a),(L_maxNumParts, Just b)] -&gt; return $  (SizeAttr_MinMaxSize a b)</span>
<span class="lineno">  895 </span><span class="spaces">      </span><span class="istickedoff">as -&gt; <span class="nottickedoff">return . def &lt;* contextError $ SemanticError $ pack $ &quot;Incompatible attributes partitionSize :&quot; ++ show as</span></span></span>
<span class="lineno">  896 </span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>validateJectivityAttributes :: [(Lexeme,Maybe Expression)] -&gt; ValidatorS JectivityAttr
<span class="lineno">  899 </span><span class="decl"><span class="istickedoff">validateJectivityAttributes attrs = do</span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="istickedoff">let sizeAttrs = [L_injective,L_surjective,L_bijective]</span>
<span class="lineno">  901 </span><span class="spaces">    </span><span class="istickedoff">let filtered = sort $ filter (\x -&gt; fst x `elem` sizeAttrs) attrs</span>
<span class="lineno">  902 </span><span class="spaces">    </span><span class="istickedoff">case filtered of</span>
<span class="lineno">  903 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; return $  JectivityAttr_None</span>
<span class="lineno">  904 </span><span class="spaces">      </span><span class="istickedoff">[(L_injective,_)] -&gt; return $  JectivityAttr_Injective</span>
<span class="lineno">  905 </span><span class="spaces">      </span><span class="istickedoff">[(L_surjective, _)] -&gt; return $  JectivityAttr_Surjective</span>
<span class="lineno">  906 </span><span class="spaces">      </span><span class="istickedoff">[(L_bijective, _)] -&gt; return $  JectivityAttr_Bijective</span>
<span class="lineno">  907 </span><span class="spaces">      </span><span class="istickedoff">[(L_injective, _),(L_surjective, _)] -&gt; do</span>
<span class="lineno">  908 </span><span class="spaces">        </span><span class="istickedoff">contextInfo $ <span class="nottickedoff">UnclassifiedInfo &quot;Inj and Sur can be combined to bijective&quot;</span></span>
<span class="lineno">  909 </span><span class="spaces">        </span><span class="istickedoff">return $  JectivityAttr_Bijective</span>
<span class="lineno">  910 </span><span class="spaces">      </span><span class="istickedoff">as -&gt;<span class="nottickedoff">do</span></span>
<span class="lineno">  911 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">void . contextError $ SemanticError $ pack $ &quot;Incompatible attributes jectivity&quot; ++ show as</span></span>
<span class="lineno">  912 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return def</span></span></span>
<span class="lineno">  913 </span>
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>validateSetAttributes :: ListNode AttributeNode -&gt; ValidatorS (SetAttr Expression)
<span class="lineno">  916 </span><span class="decl"><span class="istickedoff">validateSetAttributes atts = do</span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">atts</span></span>
<span class="lineno">  918 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode setValidAttrs) atts</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateSizeAttributes attrs</span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">return $ SetAttr  size</span></span>
<span class="lineno">  921 </span>
<span class="lineno">  922 </span>
<span class="lineno">  923 </span>validateMSetAttributes :: ListNode AttributeNode -&gt; ValidatorS (MSetAttr Expression)
<span class="lineno">  924 </span><span class="decl"><span class="istickedoff">validateMSetAttributes atts = do</span>
<span class="lineno">  925 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">atts</span></span>
<span class="lineno">  926 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode msetValidAttrs) atts</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateSizeAttributes attrs</span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">occurs &lt;- validateOccursAttrs attrs</span>
<span class="lineno">  929 </span><span class="spaces">    </span><span class="istickedoff">return $ MSetAttr size  occurs</span>
<span class="lineno">  930 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  931 </span><span class="spaces">            </span><span class="istickedoff">validateOccursAttrs attrs = do</span>
<span class="lineno">  932 </span><span class="spaces">                </span><span class="istickedoff">let sizeAttrs = [L_minOccur,L_maxOccur]</span>
<span class="lineno">  933 </span><span class="spaces">                </span><span class="istickedoff">let filtered = sort $ filter (\x -&gt; fst x `elem` sizeAttrs) attrs</span>
<span class="lineno">  934 </span><span class="spaces">                </span><span class="istickedoff">case filtered of</span>
<span class="lineno">  935 </span><span class="spaces">                    </span><span class="istickedoff">[] -&gt; return $  OccurAttr_None</span>
<span class="lineno">  936 </span><span class="spaces">                    </span><span class="istickedoff">[(L_minOccur,Just a)] -&gt; return  (OccurAttr_MinOccur a)</span>
<span class="lineno">  937 </span><span class="spaces">                    </span><span class="istickedoff">[(L_maxOccur, Just a)] -&gt; return  (OccurAttr_MaxOccur a)</span>
<span class="lineno">  938 </span><span class="spaces">                    </span><span class="istickedoff">[(L_minOccur, Just a),(L_maxOccur, Just b)] -&gt; return $ (OccurAttr_MinMaxOccur a b)</span>
<span class="lineno">  939 </span><span class="spaces">                    </span><span class="istickedoff">as -&gt;<span class="nottickedoff">do void . contextError $ SemanticError $ pack $ &quot;Bad args to occurs&quot; ++ show as;return def</span></span></span>
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>
<span class="lineno">  942 </span>validateFuncAttributes :: ListNode AttributeNode -&gt; ValidatorS (FunctionAttr Expression)
<span class="lineno">  943 </span><span class="decl"><span class="istickedoff">validateFuncAttributes atts = do</span>
<span class="lineno">  944 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode funAttrs) atts</span>
<span class="lineno">  945 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateSizeAttributes attrs</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="istickedoff">parts &lt;- return $ if L_total `elem` map fst attrs then PartialityAttr_Total else PartialityAttr_Partial</span>
<span class="lineno">  947 </span><span class="spaces">    </span><span class="istickedoff">jectivity &lt;- validateJectivityAttributes attrs</span>
<span class="lineno">  948 </span><span class="spaces">    </span><span class="istickedoff">return $  (FunctionAttr  size  parts  jectivity)</span></span>
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>validateSeqAttributes :: ListNode AttributeNode -&gt; ValidatorS (SequenceAttr Expression)
<span class="lineno">  951 </span><span class="decl"><span class="istickedoff">validateSeqAttributes atts = do</span>
<span class="lineno">  952 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode seqAttrs) atts</span>
<span class="lineno">  953 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateSizeAttributes attrs</span>
<span class="lineno">  954 </span><span class="spaces">    </span><span class="istickedoff">jectivity &lt;- validateJectivityAttributes attrs</span>
<span class="lineno">  955 </span><span class="spaces">    </span><span class="istickedoff">return $ SequenceAttr size jectivity</span></span>
<span class="lineno">  956 </span>
<span class="lineno">  957 </span>
<span class="lineno">  958 </span>validateRelationAttributes :: ListNode AttributeNode -&gt; ValidatorS (RelationAttr Expression)
<span class="lineno">  959 </span><span class="decl"><span class="istickedoff">validateRelationAttributes atts = do</span>
<span class="lineno">  960 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">atts</span></span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode relAttrs) atts</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateSizeAttributes attrs</span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="istickedoff">others &lt;- catMaybes &lt;$&gt; validateArray validateBinaryRel (filter (\x -&gt; fst x `elem` map fst binRelAttrs) attrs)</span>
<span class="lineno">  964 </span><span class="spaces">    </span><span class="istickedoff">return $ RelationAttr size  (BinaryRelationAttrs $ S.fromList others )</span>
<span class="lineno">  965 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  966 </span><span class="spaces">            </span><span class="istickedoff">validateBinaryRel :: (Lexeme , Maybe Expression) -&gt; Validator BinaryRelationAttr</span>
<span class="lineno">  967 </span><span class="spaces">            </span><span class="istickedoff">validateBinaryRel (l,_) = do</span>
<span class="lineno">  968 </span><span class="spaces">                </span><span class="istickedoff">case lexemeToBinRel l of</span>
<span class="lineno">  969 </span><span class="spaces">                    </span><span class="istickedoff">Just b -&gt; return . pure $ b</span>
<span class="lineno">  970 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt;<span class="nottickedoff">contextError $ InternalErrorS $ pack $ &quot;Not found (bin rel) &quot; ++ show l</span></span></span>
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>validatePartitionAttributes :: ListNode AttributeNode -&gt; ValidatorS (PartitionAttr Expression)
<span class="lineno">  973 </span><span class="decl"><span class="istickedoff">validatePartitionAttributes atts = do</span>
<span class="lineno">  974 </span><span class="spaces">    </span><span class="istickedoff">attrs &lt;- catMaybes &lt;$&gt; validateList_ (validateAttributeNode partitionAttrs) atts</span>
<span class="lineno">  975 </span><span class="spaces">    </span><span class="istickedoff">--guard size attrs and complete as this is default</span>
<span class="lineno">  976 </span><span class="spaces">    </span><span class="istickedoff">size &lt;- validateNumPartAttributes attrs</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">partSize &lt;- validatePartSizeAttributes attrs</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="istickedoff">regular &lt;- return $ L_regular `elem` map fst attrs</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="istickedoff">return $ PartitionAttr size  partSize regular</span></span>
<span class="lineno">  980 </span>
<span class="lineno">  981 </span>validateAttributeNode :: Map Lexeme Bool -&gt; AttributeNode -&gt; Validator (Lexeme,Maybe Expression)
<span class="lineno">  982 </span><span class="decl"><span class="istickedoff">validateAttributeNode vs (NamedAttributeNode t Nothing) = do</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">flagSToken t <span class="nottickedoff">TtAttribute</span></span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="istickedoff">name &lt;- validateSToken t</span>
<span class="lineno">  985 </span><span class="spaces">    </span><span class="istickedoff">putAttrDoc <span class="nottickedoff">(T.pack $ show name)</span> <span class="nottickedoff">t</span></span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">case M.lookup name vs of</span>
<span class="lineno">  987 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">invalid $ t &lt;!&gt; CustomError &quot;Not a valid attribute in this context&quot;</span></span>
<span class="lineno">  988 </span><span class="spaces">      </span><span class="istickedoff">Just  True -&gt; <span class="nottickedoff">invalid $ t &lt;!&gt; CustomError &quot;Argument required&quot;</span></span>
<span class="lineno">  989 </span><span class="spaces">      </span><span class="istickedoff">Just False -&gt;  return . pure $ (name , <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  990 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  991 </span><span class="spaces"></span><span class="istickedoff">validateAttributeNode vs (NamedAttributeNode t (Just e)) = do</span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="istickedoff">flagSToken t <span class="nottickedoff">TtAttribute</span></span>
<span class="lineno">  993 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">e</span></span>
<span class="lineno">  994 </span><span class="spaces">    </span><span class="istickedoff">expr &lt;- validateExpression e ?=&gt; exactly tInt</span>
<span class="lineno">  995 </span><span class="spaces">    </span><span class="istickedoff">name &lt;- validateSToken t</span>
<span class="lineno">  996 </span><span class="spaces">    </span><span class="istickedoff">putAttrDoc <span class="nottickedoff">(T.pack $ show name)</span> <span class="nottickedoff">t</span></span>
<span class="lineno">  997 </span><span class="spaces">    </span><span class="istickedoff">case M.lookup name vs of</span>
<span class="lineno">  998 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">invalid $ t &lt;!&gt; CustomError &quot;Not a valid attribute in this context&quot;</span></span>
<span class="lineno">  999 </span><span class="spaces">      </span><span class="istickedoff">Just False -&gt; <span class="nottickedoff">invalid $ t &lt;!&gt; SemanticError &quot;attribute %name% does not take an argument&quot;</span></span>
<span class="lineno"> 1000 </span><span class="spaces">      </span><span class="istickedoff">Just True -&gt; return . pure $ (\x -&gt; (name,Just x)) expr</span></span>
<span class="lineno"> 1001 </span>
<span class="lineno"> 1002 </span>
<span class="lineno"> 1003 </span>validateNamedDomainInVariant :: NamedDomainNode -&gt; ValidatorS (Name, TypedDomain)
<span class="lineno"> 1004 </span><span class="decl"><span class="istickedoff">validateNamedDomainInVariant (NameDomainNode name m_dom) = do</span>
<span class="lineno"> 1005 </span><span class="spaces">    </span><span class="istickedoff">name' &lt;-  validateNameAs <span class="nottickedoff">TtRecordMember</span> name</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="istickedoff">domain' &lt;-case m_dom of</span>
<span class="lineno"> 1007 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt;  <span class="nottickedoff">do return . Typed tInt $ DomainInt TagInt [RangeSingle 0]</span></span>
<span class="lineno"> 1008 </span><span class="spaces">      </span><span class="istickedoff">Just (l,d) -&gt; do l `isA'` <span class="nottickedoff">TtOperator</span>; validateDomain d</span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">return $ (name' ,  domain')</span></span>
<span class="lineno"> 1010 </span>
<span class="lineno"> 1011 </span>validateNamedDomainInRecord :: NamedDomainNode -&gt; ValidatorS (Name, TypedDomain)
<span class="lineno"> 1012 </span><span class="decl"><span class="nottickedoff">validateNamedDomainInRecord (NameDomainNode name m_dom) = do</span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="nottickedoff">name' &lt;-  validateNameAs TtRecordMember name</span>
<span class="lineno"> 1014 </span><span class="spaces">    </span><span class="nottickedoff">domain' &lt;-case m_dom of</span>
<span class="lineno"> 1015 </span><span class="spaces">      </span><span class="nottickedoff">Just (l,d) -&gt;l `isA'` TtOperator &gt;&gt; validateDomain d</span>
<span class="lineno"> 1016 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1017 </span><span class="spaces">        </span><span class="nottickedoff">raiseError $ symbolRegion name &lt;!&gt; SemanticError &quot;Dataless not allowed in record&quot;</span>
<span class="lineno"> 1018 </span><span class="spaces">        </span><span class="nottickedoff">(return (fallback &quot;Dataless RecordMemeber&quot;))</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="nottickedoff">return $  (name', domain')</span></span>
<span class="lineno"> 1020 </span>
<span class="lineno"> 1021 </span>validateRange ::Type -&gt; RangeNode -&gt; ValidatorS (Range Expression)
<span class="lineno"> 1022 </span><span class="decl"><span class="istickedoff">validateRange t range = case range of</span>
<span class="lineno"> 1023 </span><span class="spaces">    </span><span class="istickedoff">SingleRangeNode en -&gt; do ex &lt;- validateExpression en ?=&gt; exactly t; return $ RangeSingle ex</span>
<span class="lineno"> 1024 </span><span class="spaces">    </span><span class="istickedoff">OpenRangeNode dots -&gt; do dots `isA` <span class="nottickedoff">TtOther &quot;Ellips&quot;</span> ; return  RangeOpen</span>
<span class="lineno"> 1025 </span><span class="spaces">    </span><span class="istickedoff">RightUnboundedRangeNode e1 dots -&gt; do dots `isA` <span class="nottickedoff">TtOther &quot;Ellips&quot;</span>; ex &lt;- validateExpression e1 ?=&gt; exactly t  ; return $ RangeLowerBounded ex</span>
<span class="lineno"> 1026 </span><span class="spaces">    </span><span class="istickedoff">LeftUnboundedRangeNode dots e1 -&gt; do dots `isA` <span class="nottickedoff">TtOther &quot;Ellips&quot;</span> ; ex &lt;- validateExpression e1 ?=&gt; exactly t  ; return $ RangeUpperBounded ex</span>
<span class="lineno"> 1027 </span><span class="spaces">    </span><span class="istickedoff">BoundedRangeNode e1 dots e2 -&gt; do</span>
<span class="lineno"> 1028 </span><span class="spaces">        </span><span class="istickedoff">dots `isA` <span class="nottickedoff">TtOther &quot;Ellips&quot;</span></span>
<span class="lineno"> 1029 </span><span class="spaces">        </span><span class="istickedoff">e1' &lt;- validateExpression e1 ?=&gt; exactly t</span>
<span class="lineno"> 1030 </span><span class="spaces">        </span><span class="istickedoff">e2' &lt;-  validateExpression e2 ?=&gt; exactly t</span>
<span class="lineno"> 1031 </span><span class="spaces">        </span><span class="istickedoff">return $  RangeBounded e1' e2'</span></span>
<span class="lineno"> 1032 </span>
<span class="lineno"> 1033 </span>validateArrowPair :: ArrowPairNode -&gt; Validator (RegionTagged (Typed Expression), RegionTagged (Typed Expression))
<span class="lineno"> 1034 </span><span class="decl"><span class="istickedoff">validateArrowPair (ArrowPairNode e1 s e2) = do</span>
<span class="lineno"> 1035 </span><span class="spaces">    </span><span class="istickedoff">s `isA'` <span class="nottickedoff">TtOperator</span></span>
<span class="lineno"> 1036 </span><span class="spaces">    </span><span class="istickedoff">e1' &lt;-  validateExpression e1</span>
<span class="lineno"> 1037 </span><span class="spaces">    </span><span class="istickedoff">e2' &lt;-  validateExpression e2</span>
<span class="lineno"> 1038 </span><span class="spaces">    </span><span class="istickedoff">return .pure $ (\a b-&gt;((<span class="nottickedoff">symbolRegion e1</span>,a),(<span class="nottickedoff">symbolRegion e2</span>,b))) e1' e2'</span></span>
<span class="lineno"> 1039 </span>
<span class="lineno"> 1040 </span>validateExpression :: ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1041 </span><span class="decl"><span class="istickedoff">validateExpression expr = do</span>
<span class="lineno"> 1042 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">expr</span></span>
<span class="lineno"> 1043 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- case expr of</span>
<span class="lineno"> 1044 </span><span class="spaces">            </span><span class="istickedoff">Literal ln -&gt; validateLiteral ln</span>
<span class="lineno"> 1045 </span><span class="spaces">            </span><span class="istickedoff">IdentifierNode nn -&gt; validateIdentifierExpr nn</span>
<span class="lineno"> 1046 </span><span class="spaces">            </span><span class="istickedoff">MetaVarExpr tok -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1047 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">x &lt;- validateMetaVar tok ;</span></span>
<span class="lineno"> 1048 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return $ Typed TypeAny $ ExpressionMetaVar x</span></span>
<span class="lineno"> 1049 </span><span class="spaces">            </span><span class="istickedoff">QuantificationExpr qen -&gt; validateQuantificationExpression qen</span>
<span class="lineno"> 1050 </span><span class="spaces">            </span><span class="istickedoff">OperatorExpressionNode oen -&gt; validateOperatorExpression oen</span>
<span class="lineno"> 1051 </span><span class="spaces">            </span><span class="istickedoff">DomainExpression dex -&gt; <span class="nottickedoff">validateDomainExpression dex</span></span>
<span class="lineno"> 1052 </span><span class="spaces">            </span><span class="istickedoff">ParenExpression (ParenExpressionNode l1 exp l2) -&gt; checkSymbols [l1,l2] &gt;&gt; validateExpression exp</span>
<span class="lineno"> 1053 </span><span class="spaces">            </span><span class="istickedoff">AbsExpression (ParenExpressionNode l1 exp l2) -&gt; do</span>
<span class="lineno"> 1054 </span><span class="spaces">                </span><span class="istickedoff">[l1,l2] `are` <span class="nottickedoff">TtOperator</span></span>
<span class="lineno"> 1055 </span><span class="spaces">                </span><span class="istickedoff">(kExp,exp') &lt;- validateFlexibleExpression exp</span>
<span class="lineno"> 1056 </span><span class="spaces">                </span><span class="istickedoff">typeCheckAbs kExp</span>
<span class="lineno"> 1057 </span><span class="spaces">                </span><span class="istickedoff">return . Typed tInt $ mkOp TwoBarOp  [exp']</span>
<span class="lineno"> 1058 </span><span class="spaces">            </span><span class="istickedoff">FunctionalApplicationNode lt ln -&gt; validateFunctionApplication  lt ln</span>
<span class="lineno"> 1059 </span><span class="spaces">            </span><span class="istickedoff">AttributeAsConstriant lt exprs -&gt; validateAttributeAsConstraint lt exprs</span>
<span class="lineno"> 1060 </span><span class="spaces">            </span><span class="istickedoff">SpecialCase  scn -&gt;  validateSpecialCase scn</span>
<span class="lineno"> 1061 </span><span class="spaces">            </span><span class="istickedoff">MissingExpressionNode lt -&gt; do raiseError (lt &lt;!&gt; TokenError lt) ; return (fallback <span class="nottickedoff">&quot;Missing expression&quot;</span>)</span>
<span class="lineno"> 1062 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">expr</span></span>
<span class="lineno"> 1063 </span><span class="spaces">    </span><span class="istickedoff">return res</span>
<span class="lineno"> 1064 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1065 </span><span class="spaces">        </span><span class="istickedoff">typeCheckAbs :: Kind -&gt; ValidatorS ()</span>
<span class="lineno"> 1066 </span><span class="spaces">        </span><span class="istickedoff">typeCheckAbs (Kind DomainType _) = pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1067 </span><span class="spaces">        </span><span class="istickedoff">typeCheckAbs (Kind ValueType t) = case t of</span>
<span class="lineno"> 1068 </span><span class="spaces">                    </span><span class="istickedoff">TypeAny       -&gt; <span class="nottickedoff">return ()</span></span>
<span class="lineno"> 1069 </span><span class="spaces">                    </span><span class="istickedoff">TypeInt _       -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1070 </span><span class="spaces">                    </span><span class="istickedoff">TypeList{}      -&gt; <span class="nottickedoff">return ()</span></span>
<span class="lineno"> 1071 </span><span class="spaces">                    </span><span class="istickedoff">TypeSet{}       -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1072 </span><span class="spaces">                    </span><span class="istickedoff">TypeMSet{}      -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1073 </span><span class="spaces">                    </span><span class="istickedoff">TypeFunction{}  -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1074 </span><span class="spaces">                    </span><span class="istickedoff">TypeSequence{}  -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1075 </span><span class="spaces">                    </span><span class="istickedoff">TypeRelation{}  -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1076 </span><span class="spaces">                    </span><span class="istickedoff">TypePartition{} -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1077 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">contextTypeError $ ComplexTypeError &quot;Int or collection&quot; t</span></span></span>
<span class="lineno"> 1078 </span>
<span class="lineno"> 1079 </span>validateFlexibleExpression :: ExpressionNode -&gt; ValidatorS (Kind,Expression)
<span class="lineno"> 1080 </span><span class="decl"><span class="istickedoff">validateFlexibleExpression (IdentifierNode name) = do</span>
<span class="lineno"> 1081 </span><span class="spaces">    </span><span class="istickedoff">n &lt;- validateIdentifierS name</span>
<span class="lineno"> 1082 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">name</span></span>
<span class="lineno"> 1083 </span><span class="spaces">    </span><span class="istickedoff">t &lt;- resolveReference (<span class="nottickedoff">symbolRegion name</span>,Name n)</span>
<span class="lineno"> 1084 </span><span class="spaces">    </span><span class="istickedoff">tagWithType (NameNode name) t</span>
<span class="lineno"> 1085 </span><span class="spaces">    </span><span class="istickedoff">return (t,Reference (Name n) Nothing)</span>
<span class="lineno"> 1086 </span><span class="spaces"></span><span class="istickedoff">validateFlexibleExpression (DomainExpression den) = do</span>
<span class="lineno"> 1087 </span><span class="spaces">    </span><span class="istickedoff">(dType,d) &lt;- typeSplit &lt;$&gt; validateDomainExpression den</span>
<span class="lineno"> 1088 </span><span class="spaces">    </span><span class="istickedoff">return (Kind DomainType dType,d)</span>
<span class="lineno"> 1089 </span><span class="spaces"></span><span class="istickedoff">validateFlexibleExpression en = do</span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">(t,expr) &lt;- typeSplit &lt;$&gt; validateExpression en</span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">return (simple t,expr)</span></span>
<span class="lineno"> 1092 </span>
<span class="lineno"> 1093 </span>validateAttributeAsConstraint :: SToken -&gt; ListNode ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1094 </span><span class="decl"><span class="istickedoff">validateAttributeAsConstraint l1 exprs = do</span>
<span class="lineno"> 1095 </span><span class="spaces">    </span><span class="istickedoff">es &lt;- map untype &lt;$&gt; validateList_ validateExpression exprs</span>
<span class="lineno"> 1096 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno"> 1097 </span><span class="spaces">        </span><span class="istickedoff">flagSToken l1 <span class="nottickedoff">TtAAC</span></span>
<span class="lineno"> 1098 </span><span class="spaces">        </span><span class="istickedoff">lx &lt;- validateSToken l1</span>
<span class="lineno"> 1099 </span><span class="spaces">        </span><span class="istickedoff">let n = lookup (Name (lexemeText lx)) allSupportedAttributes</span>
<span class="lineno"> 1100 </span><span class="spaces">        </span><span class="istickedoff">r &lt;- case (n,es) of</span>
<span class="lineno"> 1101 </span><span class="spaces">          </span><span class="istickedoff">(Just 1 , [e,v]) -&gt; return . pure . Typed TypeBool  $ aacBuilder e lx (Just v)</span>
<span class="lineno"> 1102 </span><span class="spaces">          </span><span class="istickedoff">(Just 1 , _) -&gt; <span class="nottickedoff">invalid $  l1 &lt;!&gt; SemanticError ( pack $ &quot;Expected 2 args to &quot; ++ (show lx)  ++ &quot;got&quot; ++ (show $ length es))</span></span>
<span class="lineno"> 1103 </span><span class="spaces">          </span><span class="istickedoff">(Just 0 , [e]) -&gt; return . pure . Typed TypeBool $ aacBuilder e lx Nothing</span>
<span class="lineno"> 1104 </span><span class="spaces">          </span><span class="istickedoff">(Just 0 , _) -&gt; <span class="nottickedoff">invalid $ l1 &lt;!&gt; SemanticError ( pack $ &quot;Expected 1 arg to &quot; ++ (show lx)  ++ &quot;got&quot; ++ (show $ length es))</span></span>
<span class="lineno"> 1105 </span><span class="spaces">          </span><span class="istickedoff">(_,_) -&gt; <span class="nottickedoff">invalid $ l1 &lt;!&gt; InternalErrorS &quot;Bad AAC&quot;</span></span>
<span class="lineno"> 1106 </span><span class="spaces">        </span><span class="istickedoff">return $ fromMaybe <span class="nottickedoff">(fallback &quot;bad AAC&quot;)</span> r</span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1108 </span><span class="spaces">        </span><span class="istickedoff">aacBuilder e lx y= Op $ MkOpAttributeAsConstraint $ OpAttributeAsConstraint e (fromString (lexemeFace lx)) y</span></span>
<span class="lineno"> 1109 </span>
<span class="lineno"> 1110 </span>validateSpecialCase :: SpecialCaseNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1111 </span><span class="decl"><span class="istickedoff">validateSpecialCase (ExprWithDecls l1 ex l2 sts l3) = do</span>
<span class="lineno"> 1112 </span><span class="spaces">    </span><span class="istickedoff">mapM_ validateSToken [l1,l2,l3]</span>
<span class="lineno"> 1113 </span><span class="spaces">    </span><span class="istickedoff">scoped $ do conds &lt;- validateProgramTree sts</span>
<span class="lineno"> 1114 </span><span class="spaces">                </span><span class="istickedoff">let decls =</span>
<span class="lineno"> 1115 </span><span class="spaces">                        </span><span class="istickedoff">[ Declaration (FindOrGiven LocalFind nm dom)</span>
<span class="lineno"> 1116 </span><span class="spaces">                        </span><span class="istickedoff">| Declaration (FindOrGiven Find nm dom) &lt;- conds ]</span>
<span class="lineno"> 1117 </span><span class="spaces">                </span><span class="istickedoff">let cons = concat</span>
<span class="lineno"> 1118 </span><span class="spaces">                        </span><span class="istickedoff">[ xs</span>
<span class="lineno"> 1119 </span><span class="spaces">                        </span><span class="istickedoff">| SuchThat xs &lt;- conds</span>
<span class="lineno"> 1120 </span><span class="spaces">                        </span><span class="istickedoff">]</span>
<span class="lineno"> 1121 </span><span class="spaces">                </span><span class="istickedoff">let locals = if null decls</span>
<span class="lineno"> 1122 </span><span class="spaces">                                </span><span class="istickedoff">then DefinednessConstraints cons</span>
<span class="lineno"> 1123 </span><span class="spaces">                                </span><span class="istickedoff">else AuxiliaryVars (decls ++ [SuchThat cons])</span>
<span class="lineno"> 1124 </span><span class="spaces">                </span><span class="istickedoff">(t,expr) &lt;- typeSplit &lt;$&gt; validateExpression ex</span>
<span class="lineno"> 1125 </span><span class="spaces">                </span><span class="istickedoff">return . Typed t $ WithLocals  expr  locals</span></span>
<span class="lineno"> 1126 </span>
<span class="lineno"> 1127 </span>translateQnName :: Lexeme -&gt; OpType
<span class="lineno"> 1128 </span><span class="decl"><span class="istickedoff">translateQnName qnName = case qnName of</span>
<span class="lineno"> 1129 </span><span class="spaces">    </span><span class="istickedoff">L_ForAll -&gt; FunctionOp L_fAnd</span>
<span class="lineno"> 1130 </span><span class="spaces">    </span><span class="istickedoff">L_Exists -&gt; FunctionOp L_fOr</span>
<span class="lineno"> 1131 </span><span class="spaces">    </span><span class="istickedoff">L_Sum -&gt; FunctionOp L_Sum</span>
<span class="lineno"> 1132 </span><span class="spaces">    </span><span class="istickedoff">L_Product -&gt; <span class="nottickedoff">FunctionOp L_Product</span></span>
<span class="lineno"> 1133 </span><span class="spaces">    </span><span class="istickedoff">_        -&gt; <span class="nottickedoff">FunctionOp qnName</span></span></span>
<span class="lineno"> 1134 </span>
<span class="lineno"> 1135 </span>validateQuantificationExpression :: QuantificationExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1136 </span><span class="decl"><span class="istickedoff">validateQuantificationExpression q@(QuantificationExpressionNode name pats over m_guard dot expr) =</span>
<span class="lineno"> 1137 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno"> 1138 </span><span class="spaces">        </span><span class="istickedoff">setContextFrom <span class="nottickedoff">q</span></span>
<span class="lineno"> 1139 </span><span class="spaces">        </span><span class="istickedoff">dot `isA'` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1140 </span><span class="spaces">        </span><span class="istickedoff">scoped $ do</span>
<span class="lineno"> 1141 </span><span class="spaces">            </span><span class="istickedoff">flagSToken name <span class="nottickedoff">TtQuantifier</span></span>
<span class="lineno"> 1142 </span><span class="spaces">            </span><span class="istickedoff">name' &lt;-  validateSToken name</span>
<span class="lineno"> 1143 </span><span class="spaces">            </span><span class="istickedoff">(over',genDec) &lt;-  holdDeclarations $ wrapRegion <span class="nottickedoff">pats</span> <span class="nottickedoff">pats</span> <span class="nottickedoff">SGen</span> $ validateQuantificationOver pats over</span>
<span class="lineno"> 1144 </span><span class="spaces">            </span><span class="istickedoff">(g',gDec) &lt;-case m_guard of</span>
<span class="lineno"> 1145 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; return ([],[])</span>
<span class="lineno"> 1146 </span><span class="spaces">              </span><span class="istickedoff">Just qg -&gt;  holdDeclarations $ </span>
<span class="lineno"> 1147 </span><span class="spaces">                          </span><span class="istickedoff">wrapRegion <span class="nottickedoff">qg</span> <span class="nottickedoff">qg</span> <span class="nottickedoff">SGuard</span> $ </span>
<span class="lineno"> 1148 </span><span class="spaces">                          </span><span class="istickedoff">validateQuantificationGuard m_guard</span>
<span class="lineno"> 1149 </span><span class="spaces">            </span><span class="istickedoff">setContextFrom <span class="nottickedoff">expr</span></span>
<span class="lineno"> 1150 </span><span class="spaces">            </span><span class="istickedoff">let (iType,rType) = case name' of</span>
<span class="lineno"> 1151 </span><span class="spaces">                    </span><span class="istickedoff">L_ForAll -&gt; (tCondition,TypeBool)</span>
<span class="lineno"> 1152 </span><span class="spaces">                    </span><span class="istickedoff">L_Exists -&gt;(tCondition,TypeBool)</span>
<span class="lineno"> 1153 </span><span class="spaces">                    </span><span class="istickedoff">L_Sum -&gt; (exactly tInt,tInt)</span>
<span class="lineno"> 1154 </span><span class="spaces">                    </span><span class="istickedoff">L_Product -&gt; <span class="nottickedoff">(exactly tInt,tInt)</span></span>
<span class="lineno"> 1155 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug $ pretty (&quot;Unkown quantifier &quot; ++ show name')</span></span>
<span class="lineno"> 1156 </span><span class="spaces">            </span><span class="istickedoff">(body,bDecl) &lt;- holdDeclarations </span>
<span class="lineno"> 1157 </span><span class="spaces">                            </span><span class="istickedoff">$ wrapRegion <span class="nottickedoff">expr</span> <span class="nottickedoff">expr</span> <span class="nottickedoff">SBody</span> </span>
<span class="lineno"> 1158 </span><span class="spaces">                            </span><span class="istickedoff">$ validateExpression expr ?=&gt; iType</span>
<span class="lineno"> 1159 </span><span class="spaces">            </span><span class="istickedoff">let qBody =  Comprehension body  (over'++g')</span>
<span class="lineno"> 1160 </span><span class="spaces">            </span><span class="istickedoff">let result = Typed rType (mkOp (translateQnName name')  [qBody])</span>
<span class="lineno"> 1161 </span><span class="spaces">            </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">(T.pack $ show name')</span> <span class="nottickedoff">name</span></span>
<span class="lineno"> 1162 </span><span class="spaces">            </span><span class="istickedoff"></span>
<span class="lineno"> 1163 </span><span class="spaces">            </span><span class="istickedoff">wrapRegion <span class="nottickedoff">q</span> <span class="nottickedoff">q</span> <span class="nottickedoff">(SQuantification (lexemeText  name') (simple rType))</span> (mapM_ addRegion (gDec++genDec++bDecl))</span>
<span class="lineno"> 1164 </span><span class="spaces">            </span><span class="istickedoff">return result</span>
<span class="lineno"> 1165 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1166 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationGuard :: Maybe QuanticationGuard -&gt; ValidatorS [GeneratorOrCondition]</span>
<span class="lineno"> 1167 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationGuard Nothing = <span class="nottickedoff">return []</span></span>
<span class="lineno"> 1168 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationGuard (Just (QuanticationGuard l1 exp) ) = do</span>
<span class="lineno"> 1169 </span><span class="spaces">            </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtOther &quot;Comma&quot;</span></span>
<span class="lineno"> 1170 </span><span class="spaces">            </span><span class="istickedoff">expr' &lt;- validateExpression exp ?=&gt; exactly TypeBool</span>
<span class="lineno"> 1171 </span><span class="spaces">            </span><span class="istickedoff">return $ [Condition expr']</span>
<span class="lineno"> 1172 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationOver :: Sequence AbstractPatternNode -&gt; QuantificationOverNode -&gt; ValidatorS [GeneratorOrCondition]</span>
<span class="lineno"> 1173 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationOver lpats ( QuantifiedSubsetOfNode lt en ) = do</span>
<span class="lineno"> 1174 </span><span class="spaces">            </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1175 </span><span class="spaces">            </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;powerset_projection&quot;</span> <span class="nottickedoff">lt</span></span>
<span class="lineno"> 1176 </span><span class="spaces">            </span><span class="istickedoff">ps &lt;- sequenceElems lpats</span>
<span class="lineno"> 1177 </span><span class="spaces">            </span><span class="istickedoff">exp &lt;- validateExpression en</span>
<span class="lineno"> 1178 </span><span class="spaces">            </span><span class="istickedoff">let (t,e) = typeSplit exp</span>
<span class="lineno"> 1179 </span><span class="spaces">            </span><span class="istickedoff">void $ unifyTypesFailing (TypeSet TypeAny) (<span class="nottickedoff">symbolRegion en</span>,exp)</span>
<span class="lineno"> 1180 </span><span class="spaces">            </span><span class="istickedoff">let pt = t</span>
<span class="lineno"> 1181 </span><span class="spaces">            </span><span class="istickedoff">apats &lt;- unifyPatterns pt ps</span>
<span class="lineno"> 1182 </span><span class="spaces">            </span><span class="istickedoff">return [Generator $ GenInExpr pat (Op $ MkOpPowerSet $ OpPowerSet e) | pat &lt;- apats]</span>
<span class="lineno"> 1183 </span><span class="spaces">        </span><span class="istickedoff">-- x in exp</span>
<span class="lineno"> 1184 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationOver lpats ( QuantifiedMemberOfNode lt en ) = do</span>
<span class="lineno"> 1185 </span><span class="spaces">            </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1186 </span><span class="spaces">            </span><span class="istickedoff">ps &lt;- sequenceElems lpats</span>
<span class="lineno"> 1187 </span><span class="spaces">            </span><span class="istickedoff">exp &lt;- validateExpression en</span>
<span class="lineno"> 1188 </span><span class="spaces">            </span><span class="istickedoff">let (t,e) = typeSplit exp</span>
<span class="lineno"> 1189 </span><span class="spaces">            </span><span class="istickedoff">pt &lt;- projectionType <span class="nottickedoff">(symbolRegion en)</span> t</span>
<span class="lineno"> 1190 </span><span class="spaces">            </span><span class="istickedoff">apats &lt;- unifyPatterns pt ps</span>
<span class="lineno"> 1191 </span><span class="spaces">            </span><span class="istickedoff">return [Generator $ GenInExpr pat e|pat &lt;- apats]</span>
<span class="lineno"> 1192 </span><span class="spaces">        </span><span class="istickedoff">-- x : domain</span>
<span class="lineno"> 1193 </span><span class="spaces">        </span><span class="istickedoff">validateQuantificationOver lpats ( QuantifiedDomainNode (OverDomainNode l1 dom) ) = do</span>
<span class="lineno"> 1194 </span><span class="spaces">            </span><span class="istickedoff">l1 `isA'` <span class="nottickedoff">TtOther &quot;Colon in comprehension&quot;</span></span>
<span class="lineno"> 1195 </span><span class="spaces">            </span><span class="istickedoff">ps &lt;- sequenceElems lpats</span>
<span class="lineno"> 1196 </span><span class="spaces">            </span><span class="istickedoff">(dType,dom') &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno"> 1197 </span><span class="spaces">            </span><span class="istickedoff">pt &lt;- projectionTypeDomain <span class="nottickedoff">(symbolRegion dom)</span> dType</span>
<span class="lineno"> 1198 </span><span class="spaces">            </span><span class="istickedoff">apats &lt;- unifyPatterns pt ps</span>
<span class="lineno"> 1199 </span><span class="spaces">            </span><span class="istickedoff">return [ Generator $ GenDomainNoRepr pat dom'| pat &lt;- apats]</span></span>
<span class="lineno"> 1200 </span>
<span class="lineno"> 1201 </span>
<span class="lineno"> 1202 </span>
<span class="lineno"> 1203 </span>validateMetaVar :: SToken -&gt; ValidatorS String
<span class="lineno"> 1204 </span><span class="decl"><span class="nottickedoff">validateMetaVar tok = do</span>
<span class="lineno"> 1205 </span><span class="spaces">    </span><span class="nottickedoff">lx &lt;- validateSToken tok</span>
<span class="lineno"> 1206 </span><span class="spaces">    </span><span class="nottickedoff">case lx of</span>
<span class="lineno"> 1207 </span><span class="spaces">        </span><span class="nottickedoff">LMetaVar s -&gt; return $ unpack s</span>
<span class="lineno"> 1208 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; bug $ &quot;Bad MetaVar&quot; &lt;+&gt; pretty (show lx)</span></span>
<span class="lineno"> 1209 </span>
<span class="lineno"> 1210 </span>validateDomainExpression :: DomainExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1211 </span><span class="decl"><span class="istickedoff">validateDomainExpression (DomainExpressionNode  l1 dom l2) = do</span>
<span class="lineno"> 1212 </span><span class="spaces">    </span><span class="istickedoff">[l1,l2]  `are` <span class="nottickedoff">TtOther &quot;Backtick&quot;</span></span>
<span class="lineno"> 1213 </span><span class="spaces">    </span><span class="istickedoff">(tdom,dom') &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno"> 1214 </span><span class="spaces">    </span><span class="istickedoff">return . Typed tdom $ Domain  dom'</span></span>
<span class="lineno"> 1215 </span>
<span class="lineno"> 1216 </span>validateFunctionApplication :: SToken -&gt; ListNode ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1217 </span><span class="decl"><span class="istickedoff">validateFunctionApplication name args = do</span>
<span class="lineno"> 1218 </span><span class="spaces">    </span><span class="istickedoff">args' &lt;-  validateList validateFlexibleExpression args</span>
<span class="lineno"> 1219 </span><span class="spaces">    </span><span class="istickedoff">flagSToken name <span class="nottickedoff">TtFunction</span></span>
<span class="lineno"> 1220 </span><span class="spaces">    </span><span class="istickedoff">name' &lt;-  validateSToken name</span>
<span class="lineno"> 1221 </span><span class="spaces">    </span><span class="istickedoff">putDocs <span class="nottickedoff">FunctionD</span> <span class="nottickedoff">(lexemeText name')</span> <span class="nottickedoff">name</span></span>
<span class="lineno"> 1222 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">args</span></span>
<span class="lineno"> 1223 </span><span class="spaces">    </span><span class="istickedoff">validateFuncOp name' args'</span></span>
<span class="lineno"> 1224 </span>
<span class="lineno"> 1225 </span>
<span class="lineno"> 1226 </span>
<span class="lineno"> 1227 </span>validateIdentifierExpr :: NameNodeS -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1228 </span><span class="decl"><span class="istickedoff">validateIdentifierExpr name = do</span>
<span class="lineno"> 1229 </span><span class="spaces">    </span><span class="istickedoff">n &lt;- validateIdentifierS name</span>
<span class="lineno"> 1230 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom name</span>
<span class="lineno"> 1231 </span><span class="spaces">    </span><span class="istickedoff">t &lt;- resolveReference (symbolRegion name,Name n)</span>
<span class="lineno"> 1232 </span><span class="spaces">    </span><span class="istickedoff">tagWithType (NameNode name) t</span>
<span class="lineno"> 1233 </span><span class="spaces">    </span><span class="istickedoff">t' &lt;- getValueType t</span>
<span class="lineno"> 1234 </span><span class="spaces">    </span><span class="istickedoff">return . Typed t' $ Reference (Name n) Nothing</span></span>
<span class="lineno"> 1235 </span>
<span class="lineno"> 1236 </span>validateOperatorExpression :: OperatorExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1237 </span><span class="decl"><span class="istickedoff">validateOperatorExpression (PrefixOpNode lt expr) = do</span>
<span class="lineno"> 1238 </span><span class="spaces">    </span><span class="istickedoff">flagSToken lt <span class="nottickedoff">TtOperator</span></span>
<span class="lineno"> 1239 </span><span class="spaces">    </span><span class="istickedoff">op &lt;-  validateSToken lt</span>
<span class="lineno"> 1240 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">expr</span></span>
<span class="lineno"> 1241 </span><span class="spaces">    </span><span class="istickedoff">let refT = case op of</span>
<span class="lineno"> 1242 </span><span class="spaces">            </span><span class="istickedoff">L_Minus -&gt; tInt</span>
<span class="lineno"> 1243 </span><span class="spaces">            </span><span class="istickedoff">L_ExclamationMark -&gt; TypeBool</span>
<span class="lineno"> 1244 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug . pretty $ &quot;Unknown prefix op &quot; ++ show op</span></span>
<span class="lineno"> 1245 </span><span class="spaces">    </span><span class="istickedoff">putDocs <span class="nottickedoff">OperatorD</span> <span class="nottickedoff">(T.pack $ &quot;pre_&quot;++show op)</span> <span class="nottickedoff">lt</span></span>
<span class="lineno"> 1246 </span><span class="spaces">    </span><span class="istickedoff">expr' &lt;-  validateExpression expr ?=&gt; exactly refT</span>
<span class="lineno"> 1247 </span><span class="spaces">    </span><span class="istickedoff">return . Typed refT $ mkOp (PrefixOp op) [expr']</span>
<span class="lineno"> 1248 </span><span class="spaces">    </span><span class="istickedoff">--lookup symbol</span>
<span class="lineno"> 1249 </span><span class="spaces"></span><span class="istickedoff">validateOperatorExpression (BinaryOpNode lexp op rexp) = do</span>
<span class="lineno"> 1250 </span><span class="spaces">    </span><span class="istickedoff">(lType,lExpr) &lt;- validateFlexibleExpression lexp</span>
<span class="lineno"> 1251 </span><span class="spaces">    </span><span class="istickedoff">(rType,rExpr) &lt;- validateFlexibleExpression rexp</span>
<span class="lineno"> 1252 </span><span class="spaces">    </span><span class="istickedoff">flagSToken op <span class="nottickedoff">TtOperator</span></span>
<span class="lineno"> 1253 </span><span class="spaces">    </span><span class="istickedoff">op' &lt;-  validateSToken op</span>
<span class="lineno"> 1254 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1255 </span><span class="spaces">    </span><span class="istickedoff">let resultValidator = binOpType op'</span>
<span class="lineno"> 1256 </span><span class="spaces">    </span><span class="istickedoff">resultType &lt;- resultValidator (symbolRegion lexp,lType) (symbolRegion rexp,rType)</span>
<span class="lineno"> 1257 </span><span class="spaces">    </span><span class="istickedoff">addRegion <span class="nottickedoff">(RegionInfo {</span></span>
<span class="lineno"> 1258 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">rRegion=symbolRegion op,</span></span>
<span class="lineno"> 1259 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">rSubRegion=Nothing,</span></span>
<span class="lineno"> 1260 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">rRegionType=Documentation OperatorD (T.pack $ show op'),</span></span>
<span class="lineno"> 1261 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">rChildren=[]})</span></span>
<span class="lineno"> 1262 </span><span class="spaces">    </span><span class="istickedoff">return . Typed resultType  $ mkBinOp ( pack $ lexemeFace op') (lExpr) (rExpr)</span>
<span class="lineno"> 1263 </span><span class="spaces"></span><span class="istickedoff">validateOperatorExpression (PostfixOpNode expr pon) = do</span>
<span class="lineno"> 1264 </span><span class="spaces">    </span><span class="istickedoff">postFixOp &lt;-  validatePostfixOp pon</span>
<span class="lineno"> 1265 </span><span class="spaces">    </span><span class="istickedoff">postFixOp expr</span></span>
<span class="lineno"> 1266 </span>
<span class="lineno"> 1267 </span>validatePostfixOp :: PostfixOpNode -&gt; ValidatorS (ExpressionNode -&gt; ValidatorS (Typed Expression))
<span class="lineno"> 1268 </span><span class="decl"><span class="istickedoff">validatePostfixOp (OpFactorial lt) = do</span>
<span class="lineno"> 1269 </span><span class="spaces">        </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtOperator</span></span>
<span class="lineno"> 1270 </span><span class="spaces">        </span><span class="istickedoff">putDocs <span class="nottickedoff">OperatorD</span> <span class="nottickedoff">&quot;post_factorial&quot;</span> <span class="nottickedoff">lt</span></span>
<span class="lineno"> 1271 </span><span class="spaces">        </span><span class="istickedoff">setContextFrom <span class="nottickedoff">lt</span></span>
<span class="lineno"> 1272 </span><span class="spaces">        </span><span class="istickedoff">return  $ \exp -&gt; do</span>
<span class="lineno"> 1273 </span><span class="spaces">            </span><span class="istickedoff">v &lt;- validateExpression exp ?=&gt; exactly tInt</span>
<span class="lineno"> 1274 </span><span class="spaces">            </span><span class="istickedoff">return $ Typed tInt $ mkOp FactorialOp [v]</span>
<span class="lineno"> 1275 </span><span class="spaces"></span><span class="istickedoff">validatePostfixOp (ApplicationNode args) = do</span>
<span class="lineno"> 1276 </span><span class="spaces">        </span><span class="istickedoff">return $ \exp -&gt; do</span>
<span class="lineno"> 1277 </span><span class="spaces">            </span><span class="istickedoff">let <span class="nottickedoff">reg = symbolRegion exp</span></span>
<span class="lineno"> 1278 </span><span class="spaces">            </span><span class="istickedoff">(t,e) &lt;- typeSplit &lt;$&gt; validateExpression exp</span>
<span class="lineno"> 1279 </span><span class="spaces">            </span><span class="istickedoff">case t of</span>
<span class="lineno"> 1280 </span><span class="spaces">                </span><span class="istickedoff">TypeFunction _ _ -&gt; do</span>
<span class="lineno"> 1281 </span><span class="spaces">                    </span><span class="istickedoff">args' &lt;- validateList (validateExpression&gt;=&gt; \(Typed t' e')-&gt;return (simple t',e')) args</span>
<span class="lineno"> 1282 </span><span class="spaces">                    </span><span class="istickedoff">validateFuncOp L_image ((<span class="nottickedoff">reg</span>,(simple t, e)):args')</span>
<span class="lineno"> 1283 </span><span class="spaces">                </span><span class="istickedoff">TypeSequence _ -&gt; do</span>
<span class="lineno"> 1284 </span><span class="spaces">                    </span><span class="istickedoff">args' &lt;- validateList (validateExpression&gt;=&gt; \(Typed t' e')-&gt;return (simple t',e')) args</span>
<span class="lineno"> 1285 </span><span class="spaces">                    </span><span class="istickedoff">validateFuncOp L_image ((<span class="nottickedoff">reg</span>,(simple t, e)):args')</span>
<span class="lineno"> 1286 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1287 </span><span class="spaces">                    </span><span class="istickedoff">as &lt;- catMaybes &lt;$&gt; listElems args</span>
<span class="lineno"> 1288 </span><span class="spaces">                    </span><span class="istickedoff">args' &lt;- mapM validateProjectionArgs as</span>
<span class="lineno"> 1289 </span><span class="spaces">                    </span><span class="istickedoff">let ys = args'-- [if underscore == v then Nothing else Just (r,Typed t v)| x@(r,(Kind ValueType t,v)) &lt;- args']</span>
<span class="lineno"> 1290 </span><span class="spaces">                    </span><span class="istickedoff">iType &lt;- case t of</span>
<span class="lineno"> 1291 </span><span class="spaces">                        </span><span class="istickedoff">TypeRelation ts -&gt; <span class="nottickedoff">checkProjectionArgs ts ys</span></span>
<span class="lineno"> 1292 </span><span class="spaces">                        </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1293 </span><span class="spaces">                                </span><span class="istickedoff">raiseTypeError $ <span class="nottickedoff">symbolRegion exp &lt;!&gt; ComplexTypeError &quot;Relation or function&quot; t</span></span>
<span class="lineno"> 1294 </span><span class="spaces">                                </span><span class="istickedoff">let <span class="nottickedoff">ts = map (maybe TypeAny (typeOf_ . snd)) ys</span></span>
<span class="lineno"> 1295 </span><span class="spaces">                                </span><span class="istickedoff">return  $ <span class="nottickedoff">TypeRelation $ ts</span></span>
<span class="lineno"> 1296 </span><span class="spaces">                    </span><span class="istickedoff">let <span class="nottickedoff">op = Op $ MkOpRelationProj $ OpRelationProj e (map (untype . snd &lt;$&gt;)  ys)</span></span>
<span class="lineno"> 1297 </span><span class="spaces">                    </span><span class="istickedoff">let resType = if <span class="tickonlyfalse">any null ys</span> then <span class="nottickedoff">iType</span> else TypeBool</span>
<span class="lineno"> 1298 </span><span class="spaces">                    </span><span class="istickedoff">return . Typed resType $ <span class="nottickedoff">op</span></span>
<span class="lineno"> 1299 </span><span class="spaces">            </span><span class="istickedoff">where</span>
<span class="lineno"> 1300 </span><span class="spaces">                </span><span class="istickedoff">validateProjectionArgs :: ExpressionNode -&gt; ValidatorS (Maybe (RegionTagged (Typed Expression)))</span>
<span class="lineno"> 1301 </span><span class="spaces">                </span><span class="istickedoff">validateProjectionArgs (IdentifierNode (NameNodeS ((StrictToken _ (lexeme-&gt;l))))) | <span class="tickonlyfalse">l == LIdentifier &quot;_&quot;</span> = <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 1302 </span><span class="spaces">                </span><span class="istickedoff">validateProjectionArgs e = validateExpression e &gt;&gt;= \x -&gt; return . pure $ <span class="nottickedoff">(symbolRegion e , x)</span></span>
<span class="lineno"> 1303 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1304 </span><span class="spaces">                </span><span class="istickedoff">checkProjectionArgs :: [Type] -&gt; [Maybe (RegionTagged (Typed Expression))] -&gt; ValidatorS Type</span>
<span class="lineno"> 1305 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">checkProjectionArgs ref bind= do</span></span>
<span class="lineno"> 1306 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">unless (length ref == length bind) $</span></span>
<span class="lineno"> 1307 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion args &lt;!&gt; SemanticError &quot;Member size mismatch for relation&quot;</span></span>
<span class="lineno"> 1308 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let pairs = zip ref bind</span></span>
<span class="lineno"> 1309 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let (free,bound) = partition (null.snd) pairs</span></span>
<span class="lineno"> 1310 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">mapM_ (\(t,x)-&gt; case x of</span></span>
<span class="lineno"> 1311 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; pure ()</span></span>
<span class="lineno"> 1312 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Just v -&gt; void $ unifyTypes t v</span></span>
<span class="lineno"> 1313 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">) bound</span></span>
<span class="lineno"> 1314 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let freeTypes = map fst free</span></span>
<span class="lineno"> 1315 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">return $ if null freeTypes then TypeBool else TypeRelation freeTypes</span></span>
<span class="lineno"> 1316 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1317 </span><span class="spaces"></span><span class="istickedoff">validatePostfixOp (IndexedNode ln) = do</span>
<span class="lineno"> 1318 </span><span class="spaces">        </span><span class="istickedoff">res &lt;- catMaybes &lt;$&gt; listElems ln</span>
<span class="lineno"> 1319 </span><span class="spaces">        </span><span class="istickedoff">return $ \exp -&gt; do</span>
<span class="lineno"> 1320 </span><span class="spaces">            </span><span class="istickedoff">e &lt;- validateExpression exp</span>
<span class="lineno"> 1321 </span><span class="spaces">            </span><span class="istickedoff">foldM validateIndexingOrSlicing e res</span>
<span class="lineno"> 1322 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1324 </span><span class="spaces"></span><span class="istickedoff">validatePostfixOp (ExplicitDomain l1 l2 dom l3) = do</span>
<span class="lineno"> 1325 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtOther &quot;Colon in expr&quot;</span></span>
<span class="lineno"> 1326 </span><span class="spaces">    </span><span class="istickedoff">l2 `isA` <span class="nottickedoff">TtOther &quot;BackTick&quot;</span></span>
<span class="lineno"> 1327 </span><span class="spaces">    </span><span class="istickedoff">l3 `isA'` <span class="nottickedoff">TtOther &quot;BackTick&quot;</span></span>
<span class="lineno"> 1328 </span><span class="spaces">    </span><span class="istickedoff">(getDomainMembers-&gt;t,_) &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno"> 1329 </span><span class="spaces">    </span><span class="istickedoff">return $ \exp -&gt; do</span>
<span class="lineno"> 1330 </span><span class="spaces">        </span><span class="istickedoff">e &lt;- validateExpression exp ?=&gt; exactly t</span>
<span class="lineno"> 1331 </span><span class="spaces">        </span><span class="istickedoff">return . Typed t $ D.Typed e t</span></span>
<span class="lineno"> 1332 </span>
<span class="lineno"> 1333 </span>
<span class="lineno"> 1334 </span>validateIndexingOrSlicing :: Typed Expression -&gt; RangeNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1335 </span><span class="decl"><span class="istickedoff">validateIndexingOrSlicing (Typed t exp) (SingleRangeNode r) = do</span>
<span class="lineno"> 1336 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">r</span></span>
<span class="lineno"> 1337 </span><span class="spaces">    </span><span class="istickedoff">(vType,e) &lt;- case t of</span>
<span class="lineno"> 1338 </span><span class="spaces">        </span><span class="istickedoff">TypeRecord ts -&gt; validateRecordMemberIndex (ts) r</span>
<span class="lineno"> 1339 </span><span class="spaces">        </span><span class="istickedoff">TypeVariant ts-&gt; validateRecordMemberIndex (ts) r</span>
<span class="lineno"> 1340 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1341 </span><span class="spaces">            </span><span class="istickedoff">t' &lt;- getIndexingType t</span>
<span class="lineno"> 1342 </span><span class="spaces">            </span><span class="istickedoff">e &lt;- validateExpression r ?=&gt; exactly t'</span>
<span class="lineno"> 1343 </span><span class="spaces">            </span><span class="istickedoff">setContextFrom r</span>
<span class="lineno"> 1344 </span><span class="spaces">            </span><span class="istickedoff">vType &lt;- getIndexedType t (Typed <span class="nottickedoff">t'</span> e)</span>
<span class="lineno"> 1345 </span><span class="spaces">            </span><span class="istickedoff">return (vType,e)</span>
<span class="lineno"> 1346 </span><span class="spaces">    </span><span class="istickedoff">return . Typed vType $ Op $ MkOpIndexing (OpIndexing exp e)</span>
<span class="lineno"> 1347 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1348 </span><span class="spaces"></span><span class="istickedoff">validateIndexingOrSlicing exp range = do</span>
<span class="lineno"> 1349 </span><span class="spaces">    </span><span class="istickedoff">let (mType,m) = typeSplit exp</span>
<span class="lineno"> 1350 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">range</span></span>
<span class="lineno"> 1351 </span><span class="spaces">    </span><span class="istickedoff">sType &lt;- getSlicingType mType</span>
<span class="lineno"> 1352 </span><span class="spaces">    </span><span class="istickedoff">r' &lt;- validateRange <span class="nottickedoff">sType</span> range</span>
<span class="lineno"> 1353 </span><span class="spaces">    </span><span class="istickedoff">let (i,j) =case r' of</span>
<span class="lineno"> 1354 </span><span class="spaces">            </span><span class="istickedoff">RangeOpen -&gt; (Nothing,Nothing)</span>
<span class="lineno"> 1355 </span><span class="spaces">            </span><span class="istickedoff">RangeLowerBounded ex -&gt;  <span class="nottickedoff">(Just ex,Nothing)</span></span>
<span class="lineno"> 1356 </span><span class="spaces">            </span><span class="istickedoff">RangeUpperBounded ex -&gt;  <span class="nottickedoff">(Nothing,Just ex)</span></span>
<span class="lineno"> 1357 </span><span class="spaces">            </span><span class="istickedoff">RangeBounded exl exr -&gt;  <span class="nottickedoff">(Just exl,Just exr)</span></span>
<span class="lineno"> 1358 </span><span class="spaces">            </span><span class="istickedoff">RangeSingle ex -&gt;  <span class="nottickedoff">(Just ex,Just ex)</span> -- This never gets hit in a well formed program</span>
<span class="lineno"> 1359 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed mType $ Op $ MkOpSlicing (OpSlicing m i j)</span></span>
<span class="lineno"> 1360 </span>
<span class="lineno"> 1361 </span>validateRecordMemberIndex :: [(Name,Type)] -&gt; ExpressionNode -&gt; ValidatorS (Type,Expression)
<span class="lineno"> 1362 </span><span class="decl"><span class="istickedoff">validateRecordMemberIndex ns (IdentifierNode nn) = do</span>
<span class="lineno"> 1363 </span><span class="spaces">    </span><span class="istickedoff">n &lt;- tagNameAs <span class="nottickedoff">TtRecordMember</span> nn</span>
<span class="lineno"> 1364 </span><span class="spaces">    </span><span class="istickedoff">let t = lookup n ns</span>
<span class="lineno"> 1365 </span><span class="spaces">    </span><span class="istickedoff">ty &lt;- case t of</span>
<span class="lineno"> 1366 </span><span class="spaces">      </span><span class="istickedoff">Just ty -&gt; return ty</span>
<span class="lineno"> 1367 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1368 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion nn &lt;!&gt; WithReplacements</span></span>
<span class="lineno"> 1369 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(SemanticError &quot;Expected member of record/variant &quot;)</span></span>
<span class="lineno"> 1370 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[x | (Name x,_) &lt;- ns]</span></span>
<span class="lineno"> 1371 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return TypeAny</span></span>
<span class="lineno"> 1372 </span><span class="spaces">    </span><span class="istickedoff">return $ (ty,Reference n Nothing)</span>
<span class="lineno"> 1373 </span><span class="spaces"></span><span class="istickedoff">validateRecordMemberIndex ns (MissingExpressionNode nn) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion nn &lt;!&gt;</span></span>
<span class="lineno"> 1375 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">WithReplacements</span></span>
<span class="lineno"> 1376 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(SemanticError &quot;Expected member of record/variant &quot;)</span></span>
<span class="lineno"> 1377 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[x | (Name x,_) &lt;- ns]</span></span>
<span class="lineno"> 1378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return (TypeAny,fallback &quot;bad Index&quot;)</span></span>
<span class="lineno"> 1379 </span><span class="spaces"></span><span class="istickedoff">validateRecordMemberIndex ns en = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">g &lt;- validateExpression en</span></span>
<span class="lineno"> 1381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">let msg = T.concat</span></span>
<span class="lineno"> 1382 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[</span></span>
<span class="lineno"> 1383 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected one of &quot;,</span></span>
<span class="lineno"> 1384 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">T.intercalate &quot;,&quot; [x | (Name x,_) &lt;- ns],</span></span>
<span class="lineno"> 1385 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot; &quot;</span></span>
<span class="lineno"> 1386 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseTypeError $ symbolRegion en &lt;!&gt; ComplexTypeError msg (typeOf_ g)</span></span>
<span class="lineno"> 1388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return (TypeAny,untype g)</span></span></span>
<span class="lineno"> 1389 </span>
<span class="lineno"> 1390 </span>
<span class="lineno"> 1391 </span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>getSlicingType :: Type -&gt; ValidatorS Type
<span class="lineno"> 1394 </span><span class="decl"><span class="istickedoff">getSlicingType TypeAny = return $ <span class="nottickedoff">TypeAny</span></span>
<span class="lineno"> 1395 </span><span class="spaces"></span><span class="istickedoff">getSlicingType (TypeMatrix i _) = return <span class="nottickedoff">i</span></span>
<span class="lineno"> 1396 </span><span class="spaces"></span><span class="istickedoff">getSlicingType (TypeSequence _) = <span class="nottickedoff">return tInt</span></span>
<span class="lineno"> 1397 </span><span class="spaces"></span><span class="istickedoff">getSlicingType t = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">contextTypeError (CustomError . pack $ &quot;Type &quot; ++ (show $ pretty t) ++ &quot; does not support slicing&quot;)</span></span>
<span class="lineno"> 1399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return TypeAny</span></span></span>
<span class="lineno"> 1400 </span>
<span class="lineno"> 1401 </span>getIndexingType :: Type -&gt; ValidatorS Type
<span class="lineno"> 1402 </span><span class="decl"><span class="istickedoff">getIndexingType TypeAny = return $ TypeAny</span>
<span class="lineno"> 1403 </span><span class="spaces"></span><span class="istickedoff">getIndexingType (TypeMatrix i _) = return $ getDomainMembers i</span>
<span class="lineno"> 1404 </span><span class="spaces"></span><span class="istickedoff">getIndexingType (TypeSequence _) = <span class="nottickedoff">return tInt</span></span>
<span class="lineno"> 1405 </span><span class="spaces"></span><span class="istickedoff">getIndexingType (TypeList _) = return tInt</span>
<span class="lineno"> 1406 </span><span class="spaces"></span><span class="istickedoff">getIndexingType (TypeTuple _) = return tInt</span>
<span class="lineno"> 1407 </span><span class="spaces"></span><span class="istickedoff">getIndexingType t = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1408 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">contextTypeError (CustomError . pack $ &quot;Type &quot; ++ show (pretty t) ++ &quot; does not support indexing&quot;)</span></span>
<span class="lineno"> 1409 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return TypeAny</span></span></span>
<span class="lineno"> 1410 </span>
<span class="lineno"> 1411 </span>getIndexedType :: Type -&gt; Typed Expression -&gt; ValidatorS Type
<span class="lineno"> 1412 </span><span class="decl"><span class="istickedoff">getIndexedType (TypeMatrix _ ms) _  = return ms</span>
<span class="lineno"> 1413 </span><span class="spaces"></span><span class="istickedoff">getIndexedType (TypeSequence t) _   = <span class="nottickedoff">return t</span></span>
<span class="lineno"> 1414 </span><span class="spaces"></span><span class="istickedoff">getIndexedType (TypeTuple ts) ex      = do</span>
<span class="lineno"> 1415 </span><span class="spaces">    </span><span class="istickedoff">case intOut <span class="nottickedoff">&quot;Index&quot;</span> (untype ex) of</span>
<span class="lineno"> 1416 </span><span class="spaces">        </span><span class="istickedoff">Left _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1417 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">contextTypeError (CustomError &quot;Non constant value indexing tuple&quot;)</span></span>
<span class="lineno"> 1418 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return TypeAny</span></span>
<span class="lineno"> 1419 </span><span class="spaces">        </span><span class="istickedoff">Right v | v &lt;= 0 || v &gt; toInteger ( length ts) -&gt; do</span>
<span class="lineno"> 1420 </span><span class="spaces">            </span><span class="istickedoff">contextTypeError . CustomError . pack $ &quot;Tuple index &quot;++ show v ++ &quot; out of bounds&quot; </span>
<span class="lineno"> 1421 </span><span class="spaces">            </span><span class="istickedoff">return TypeAny</span>
<span class="lineno"> 1422 </span><span class="spaces">        </span><span class="istickedoff">Right v -&gt; return $ ts `at` (fromInteger v -1)</span>
<span class="lineno"> 1423 </span><span class="spaces"></span><span class="istickedoff">getIndexedType (TypeRecord _) (Typed _ _)   = <span class="nottickedoff">bug &quot;Index type called on record, should be handled by special case&quot;</span></span>
<span class="lineno"> 1424 </span><span class="spaces"></span><span class="istickedoff">getIndexedType (TypeVariant _) _  =  <span class="nottickedoff">bug &quot;Index type called on variant, should be handled by special case&quot;</span></span>
<span class="lineno"> 1425 </span><span class="spaces"></span><span class="istickedoff">getIndexedType _ _ = return TypeAny</span></span>
<span class="lineno"> 1426 </span>
<span class="lineno"> 1427 </span>validateLiteral :: LiteralNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1428 </span><span class="decl"><span class="istickedoff">validateLiteral litNode = case litNode of</span>
<span class="lineno"> 1429 </span><span class="spaces">    </span><span class="istickedoff">IntLiteral lt -&gt; validateIntLiteral lt &gt;&gt;= \x -&gt; return $ Typed tInt $ Constant  x</span>
<span class="lineno"> 1430 </span><span class="spaces">    </span><span class="istickedoff">BoolLiteral lt -&gt; validateBoolLiteral lt &gt;&gt;= \x -&gt; return $ Typed TypeBool $ Constant  x</span>
<span class="lineno"> 1431 </span><span class="spaces">    </span><span class="istickedoff">MatrixLiteral mln -&gt; validateMatrixLiteral mln</span>
<span class="lineno"> 1432 </span><span class="spaces">    </span><span class="istickedoff">TupleLiteralNode (LongTuple lt xs) -&gt;  do</span>
<span class="lineno"> 1433 </span><span class="spaces">        </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtType</span></span>
<span class="lineno"> 1434 </span><span class="spaces">        </span><span class="istickedoff">validateLiteral (TupleLiteralNodeShort (ShortTuple xs))</span>
<span class="lineno"> 1435 </span><span class="spaces">    </span><span class="istickedoff">TupleLiteralNodeShort (ShortTuple xs) -&gt; do</span>
<span class="lineno"> 1436 </span><span class="spaces">        </span><span class="istickedoff">es &lt;- validateExprList_ xs</span>
<span class="lineno"> 1437 </span><span class="spaces">        </span><span class="istickedoff">makeTupleLiteral es</span>
<span class="lineno"> 1438 </span><span class="spaces">    </span><span class="istickedoff">RecordLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateRecordLiteral ln</span>
<span class="lineno"> 1439 </span><span class="spaces">    </span><span class="istickedoff">VariantLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateVariantLiteral ln</span>
<span class="lineno"> 1440 </span><span class="spaces">    </span><span class="istickedoff">SetLiteral ls -&gt; validateSetLiteral ls</span>
<span class="lineno"> 1441 </span><span class="spaces">    </span><span class="istickedoff">MSetLiteral lt ls -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateMSetLiteral ls</span>
<span class="lineno"> 1442 </span><span class="spaces">    </span><span class="istickedoff">FunctionLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateFunctionLiteral ln</span>
<span class="lineno"> 1443 </span><span class="spaces">    </span><span class="istickedoff">SequenceLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateSequenceLiteral ln</span>
<span class="lineno"> 1444 </span><span class="spaces">    </span><span class="istickedoff">RelationLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateRelationLiteral ln</span>
<span class="lineno"> 1445 </span><span class="spaces">    </span><span class="istickedoff">PartitionLiteral lt ln -&gt; lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validatePartitionLiteral ln</span></span>
<span class="lineno"> 1446 </span>
<span class="lineno"> 1447 </span>validateSequenceLiteral :: ListNode ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1448 </span><span class="decl"><span class="istickedoff">validateSequenceLiteral x = do</span>
<span class="lineno"> 1449 </span><span class="spaces">    </span><span class="istickedoff">(t,ss) &lt;- typeSplit &lt;$&gt; ( sameType =&lt;&lt; validateExprList x)</span>
<span class="lineno"> 1450 </span><span class="spaces">    </span><span class="istickedoff">let lType = TypeSequence t</span>
<span class="lineno"> 1451 </span><span class="spaces">    </span><span class="istickedoff">return . Typed  lType $  mkAbstractLiteral  $ AbsLitSequence ss</span></span>
<span class="lineno"> 1452 </span>
<span class="lineno"> 1453 </span>
<span class="lineno"> 1454 </span>validateRelationLiteral :: ListNode RelationElemNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1455 </span><span class="decl"><span class="istickedoff">validateRelationLiteral ln = do</span>
<span class="lineno"> 1456 </span><span class="spaces">    </span><span class="istickedoff">ms &lt;- validateList validateRelationMember ln</span>
<span class="lineno"> 1457 </span><span class="spaces">    </span><span class="istickedoff">(t,xs) &lt;- typeSplit &lt;$&gt; sameType ms</span>
<span class="lineno"> 1458 </span><span class="spaces">    </span><span class="istickedoff">setContextFrom <span class="nottickedoff">ln</span></span>
<span class="lineno"> 1459 </span><span class="spaces">    </span><span class="istickedoff">return . Typed t  $ mkAbstractLiteral $ AbsLitRelation xs</span>
<span class="lineno"> 1460 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1461 </span><span class="spaces">        </span><span class="istickedoff">validateRelationMember :: RelationElemNode -&gt; ValidatorS (Typed [Expression])</span>
<span class="lineno"> 1462 </span><span class="spaces">        </span><span class="istickedoff">validateRelationMember x = case x of</span>
<span class="lineno"> 1463 </span><span class="spaces">          </span><span class="istickedoff">RelationElemNodeLabeled (LongTuple lt xs) -&gt;  lt `isA` <span class="nottickedoff">TtType</span> &gt;&gt; validateRelationMember (RelationElemNodeShort $ ShortTuple xs)</span>
<span class="lineno"> 1464 </span><span class="spaces">          </span><span class="istickedoff">RelationElemNodeShort (ShortTuple xs) -&gt; do</span>
<span class="lineno"> 1465 </span><span class="spaces">            </span><span class="istickedoff">es &lt;- validateExprList_ xs</span>
<span class="lineno"> 1466 </span><span class="spaces">            </span><span class="istickedoff">let (ts,vs) = unzip $ typeSplit &lt;$&gt; es</span>
<span class="lineno"> 1467 </span><span class="spaces">            </span><span class="istickedoff">return $ Typed (TypeRelation ts) vs</span></span>
<span class="lineno"> 1468 </span>
<span class="lineno"> 1469 </span>
<span class="lineno"> 1470 </span>validatePartitionLiteral :: ListNode PartitionElemNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1471 </span><span class="decl"><span class="istickedoff">validatePartitionLiteral ln = do</span>
<span class="lineno"> 1472 </span><span class="spaces">    </span><span class="istickedoff">members &lt;- validateList validatePartitionElem ln</span>
<span class="lineno"> 1473 </span><span class="spaces">    </span><span class="istickedoff">(t,xs) &lt;- typeSplit &lt;$&gt; sameType members</span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="istickedoff">let eType = TypePartition t</span>
<span class="lineno"> 1475 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed eType (mkAbstractLiteral $ AbsLitPartition xs)</span>
<span class="lineno"> 1476 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1477 </span><span class="spaces">        </span><span class="istickedoff">validatePartitionElem :: PartitionElemNode -&gt; ValidatorS (Typed [Expression])</span>
<span class="lineno"> 1478 </span><span class="spaces">        </span><span class="istickedoff">validatePartitionElem (PartitionElemNode exprs) = do</span>
<span class="lineno"> 1479 </span><span class="spaces">            </span><span class="istickedoff">xs &lt;- validateExprList exprs</span>
<span class="lineno"> 1480 </span><span class="spaces">            </span><span class="istickedoff">sameType xs</span></span>
<span class="lineno"> 1481 </span>
<span class="lineno"> 1482 </span>
<span class="lineno"> 1483 </span>validateRecordLiteral :: ListNode RecordMemberNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1484 </span><span class="decl"><span class="istickedoff">validateRecordLiteral ln = do</span>
<span class="lineno"> 1485 </span><span class="spaces">    </span><span class="istickedoff">members &lt;- catMaybes &lt;$&gt; listElems ln</span>
<span class="lineno"> 1486 </span><span class="spaces">    </span><span class="istickedoff">case members of</span>
<span class="lineno"> 1487 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">return $ Typed (TypeRecord []) (mk [])</span>--REVIEW: should empty records be allowed?</span>
<span class="lineno"> 1488 </span><span class="spaces">        </span><span class="istickedoff">xs -&gt; do</span>
<span class="lineno"> 1489 </span><span class="spaces">            </span><span class="istickedoff">(ns,unzip . map typeSplit-&gt;(ts,es)) &lt;- mapAndUnzipM validateRecordMember xs</span>
<span class="lineno"> 1490 </span><span class="spaces">            </span><span class="istickedoff">let t =TypeRecord $ zip ns ts</span>
<span class="lineno"> 1491 </span><span class="spaces">            </span><span class="istickedoff">return $ Typed t $ mk (zip ns es)</span>
<span class="lineno"> 1492 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1493 </span><span class="spaces">        </span><span class="istickedoff">mk = mkAbstractLiteral . AbsLitRecord</span></span>
<span class="lineno"> 1494 </span>validateVariantLiteral :: ListNode RecordMemberNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1495 </span><span class="decl"><span class="istickedoff">validateVariantLiteral ln = do</span>
<span class="lineno"> 1496 </span><span class="spaces">    </span><span class="istickedoff">members &lt;- catMaybes &lt;$&gt; validateList_ (f2n validateRecordMember) ln</span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- case members of</span>
<span class="lineno"> 1498 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">invalid $ symbolRegion ln &lt;!&gt; SemanticError &quot;Variants must contain exactly one member&quot;</span></span>
<span class="lineno"> 1499 </span><span class="spaces">      </span><span class="istickedoff">[(n,Typed t v)]-&gt; return . pure . Typed (TypeVariant [(n,t)]) $ AbstractLiteral $ AbsLitVariant Nothing n v</span>
<span class="lineno"> 1500 </span><span class="spaces">      </span><span class="istickedoff">_:_ -&gt; <span class="nottickedoff">invalid $ symbolRegion ln &lt;!&gt; SyntaxError &quot;Variants must contain exactly one member&quot;</span> --tag subsequent members as unexpected </span>
<span class="lineno"> 1501 </span><span class="spaces">    </span><span class="istickedoff">return $ fromMaybe <span class="nottickedoff">(fallback &quot;bad variant&quot;)</span> res</span></span>
<span class="lineno"> 1502 </span>
<span class="lineno"> 1503 </span>
<span class="lineno"> 1504 </span>validateRecordMember :: RecordMemberNode -&gt; ValidatorS (Name,Typed Expression)
<span class="lineno"> 1505 </span><span class="decl"><span class="istickedoff">validateRecordMember (RecordMemberNode name lEq expr) = do</span>
<span class="lineno"> 1506 </span><span class="spaces">    </span><span class="istickedoff">lEq `isA'` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1507 </span><span class="spaces">    </span><span class="istickedoff">name' &lt;-  validateName name</span>
<span class="lineno"> 1508 </span><span class="spaces">    </span><span class="istickedoff">expr' &lt;-  validateExpression expr</span>
<span class="lineno"> 1509 </span><span class="spaces">    </span><span class="istickedoff">return ( name' , expr')</span></span>
<span class="lineno"> 1510 </span>
<span class="lineno"> 1511 </span>validateFunctionLiteral :: ListNode ArrowPairNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1512 </span><span class="decl"><span class="istickedoff">validateFunctionLiteral ln = do</span>
<span class="lineno"> 1513 </span><span class="spaces">    </span><span class="istickedoff">pairs &lt;- catMaybes &lt;$&gt; validateList_ validateArrowPair ln</span>
<span class="lineno"> 1514 </span><span class="spaces">    </span><span class="istickedoff">let (pl,pr) = unzip pairs</span>
<span class="lineno"> 1515 </span><span class="spaces">    </span><span class="istickedoff">(lhType,ls) &lt;- typeSplit &lt;$&gt; sameType pl</span>
<span class="lineno"> 1516 </span><span class="spaces">    </span><span class="istickedoff">(rhType,rs) &lt;- typeSplit &lt;$&gt; sameType pr</span>
<span class="lineno"> 1517 </span><span class="spaces">    </span><span class="istickedoff">let fType = TypeFunction lhType rhType</span>
<span class="lineno"> 1518 </span><span class="spaces">    </span><span class="istickedoff">return . Typed fType  $ mkAbstractLiteral $ AbsLitFunction $ zip ls rs</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>validateSetLiteral :: ListNode ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1521 </span><span class="decl"><span class="istickedoff">validateSetLiteral ls = do</span>
<span class="lineno"> 1522 </span><span class="spaces">    </span><span class="istickedoff">xs &lt;- validateList validateExpression ls</span>
<span class="lineno"> 1523 </span><span class="spaces">    </span><span class="istickedoff">(t,es) &lt;- typeSplit &lt;$&gt; sameType xs</span>
<span class="lineno"> 1524 </span><span class="spaces">    </span><span class="istickedoff">return . Typed (TypeSet t) $ mkAbstractLiteral $ AbsLitSet es</span></span>
<span class="lineno"> 1525 </span>
<span class="lineno"> 1526 </span>validateMSetLiteral :: ListNode ExpressionNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1527 </span><span class="decl"><span class="istickedoff">validateMSetLiteral ls = do</span>
<span class="lineno"> 1528 </span><span class="spaces">    </span><span class="istickedoff">xs &lt;- validateList validateExpression ls</span>
<span class="lineno"> 1529 </span><span class="spaces">    </span><span class="istickedoff">(t,es) &lt;-typeSplit&lt;$&gt; sameType xs</span>
<span class="lineno"> 1530 </span><span class="spaces">    </span><span class="istickedoff">let eType = TypeMSet t</span>
<span class="lineno"> 1531 </span><span class="spaces">    </span><span class="istickedoff">let result = mkAbstractLiteral $ AbsLitMSet es</span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff">return  $ Typed eType result</span></span>
<span class="lineno"> 1533 </span>
<span class="lineno"> 1534 </span>
<span class="lineno"> 1535 </span>validateMatrixLiteral :: MatrixLiteralNode -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1536 </span>--Matrix proper
<span class="lineno"> 1537 </span><span class="decl"><span class="istickedoff">validateMatrixLiteral (MatrixLiteralNode l1 se m_dom Nothing l2) = do</span>
<span class="lineno"> 1538 </span><span class="spaces">    </span><span class="istickedoff">[l1,l2] `are` <span class="nottickedoff">TtOther &quot;SquareBrackets&quot;</span></span>
<span class="lineno"> 1539 </span><span class="spaces">    </span><span class="istickedoff">matElems &lt;-  validateSequence validateExpression se</span>
<span class="lineno"> 1540 </span><span class="spaces">    </span><span class="istickedoff">(t,es) &lt;- typeSplit &lt;$&gt; sameType matElems</span>
<span class="lineno"> 1541 </span><span class="spaces">    </span><span class="istickedoff">let defaultDomain :: TypedDomain = Typed <span class="nottickedoff">tInt</span> (mkDomainIntB 1 (fromInt $ genericLength matElems))</span>
<span class="lineno"> 1542 </span><span class="spaces">    </span><span class="istickedoff">dom &lt;- fromMaybe defaultDomain &lt;$&gt; validateOverDomain m_dom</span>
<span class="lineno"> 1543 </span><span class="spaces">    </span><span class="istickedoff">let lit = AbsLitMatrix (untype $ dom) es</span>
<span class="lineno"> 1544 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed (TypeMatrix tInt t) $ mkAbstractLiteral lit</span>
<span class="lineno"> 1545 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1546 </span><span class="spaces">        </span><span class="istickedoff">validateOverDomain :: Maybe OverDomainNode -&gt; Validator TypedDomain</span>
<span class="lineno"> 1547 </span><span class="spaces">        </span><span class="istickedoff">validateOverDomain Nothing = return Nothing</span>
<span class="lineno"> 1548 </span><span class="spaces">        </span><span class="istickedoff">validateOverDomain (Just (OverDomainNode l3 dom)) = do l3 `isA'` <span class="nottickedoff">TtOther &quot;Semicolon in matrix&quot;</span>; pure &lt;$&gt; validateDomain dom</span>
<span class="lineno"> 1549 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1550 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1551 </span><span class="spaces"></span><span class="istickedoff">-- Matrix as comprehension</span>
<span class="lineno"> 1552 </span><span class="spaces"></span><span class="istickedoff">validateMatrixLiteral m@(MatrixLiteralNode l1 se m_dom (Just comp) l2) = do</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">[l1,l2] `are` <span class="nottickedoff">TtOther &quot;SquareBrackets&quot;</span></span>
<span class="lineno"> 1554 </span><span class="spaces">    </span><span class="istickedoff">case m_dom of</span>
<span class="lineno"> 1555 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1556 </span><span class="spaces">        </span><span class="istickedoff">Just p@(OverDomainNode l3 dom) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1557 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">l3 `isA'` TtOther &quot;Semicolon in matrix&quot;</span></span>
<span class="lineno"> 1558 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">void $ validateDomain dom</span></span>
<span class="lineno"> 1559 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion p &lt;!&gt; SemanticError &quot;Index domains are not supported in comprehensions&quot;</span></span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="istickedoff">scoped $</span>
<span class="lineno"> 1561 </span><span class="spaces">        </span><span class="istickedoff">do</span>
<span class="lineno"> 1562 </span><span class="spaces">            </span><span class="istickedoff">--check gens and put locals into scope</span>
<span class="lineno"> 1563 </span><span class="spaces">            </span><span class="istickedoff">(gens,dGens) &lt;- holdDeclarations $ validateComprehension comp</span>
<span class="lineno"> 1564 </span><span class="spaces">            </span><span class="istickedoff">--now validate expression(s)</span>
<span class="lineno"> 1565 </span><span class="spaces">            </span><span class="istickedoff">(es,dBody) &lt;- holdDeclarations</span>
<span class="lineno"> 1566 </span><span class="spaces">                          </span><span class="istickedoff">$ wrapRegion <span class="nottickedoff">se</span> <span class="nottickedoff">se</span> <span class="nottickedoff">SBody</span></span>
<span class="lineno"> 1567 </span><span class="spaces">                          </span><span class="istickedoff">$ validateSequence validateExpression se</span>
<span class="lineno"> 1568 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- case es of</span>
<span class="lineno"> 1569 </span><span class="spaces">                    </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">return $ fallback &quot;missing&quot; &lt;$ raiseError $ symbolRegion se &lt;!&gt; SemanticError &quot;MissingExpression&quot;</span></span>
<span class="lineno"> 1570 </span><span class="spaces">                    </span><span class="istickedoff">((_,x):xs) -&gt; flagExtraExpressions xs &gt;&gt; (return  $ x)</span>
<span class="lineno"> 1571 </span><span class="spaces">            </span><span class="istickedoff">let bodyType = typeOf_ r</span>
<span class="lineno"> 1572 </span><span class="spaces">            </span><span class="istickedoff">wrapRegion <span class="nottickedoff">m</span> <span class="nottickedoff">se</span> <span class="nottickedoff">(SComprehension (simple $ TypeList bodyType))</span> (mapM_ addRegion (dGens++dBody))</span>
<span class="lineno"> 1573 </span><span class="spaces">            </span><span class="istickedoff">return . Typed (TypeList bodyType) $ Comprehension (untype r) gens</span>
<span class="lineno"> 1574 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1575 </span><span class="spaces">        </span><span class="istickedoff">flagExtraExpressions :: [RegionTagged a] -&gt; ValidatorS ()</span>
<span class="lineno"> 1576 </span><span class="spaces">        </span><span class="istickedoff">flagExtraExpressions []  = pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1577 </span><span class="spaces">        </span><span class="istickedoff">flagExtraExpressions xs  = <span class="nottickedoff">raiseError $ catRegions xs &lt;!&gt; SemanticError &quot;Comprehensension may have only one expression before |&quot;</span></span></span>
<span class="lineno"> 1578 </span>
<span class="lineno"> 1579 </span>
<span class="lineno"> 1580 </span>validateComprehension :: ComprehensionNode -&gt; ValidatorS [GeneratorOrCondition]
<span class="lineno"> 1581 </span><span class="decl"><span class="istickedoff">validateComprehension (ComprehensionNode l1 body) = do</span>
<span class="lineno"> 1582 </span><span class="spaces">        </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1583 </span><span class="spaces">        </span><span class="istickedoff">concat &lt;$&gt; validateSequence_ validateComprehensionBody body</span></span>
<span class="lineno"> 1584 </span>
<span class="lineno"> 1585 </span>validateComprehensionBody :: ComprehensionBodyNode -&gt; ValidatorS [GeneratorOrCondition]
<span class="lineno"> 1586 </span>--guard
<span class="lineno"> 1587 </span><span class="decl"><span class="istickedoff">validateComprehensionBody (CompBodyCondition en) = wrapRegion <span class="nottickedoff">en</span> <span class="nottickedoff">en</span> <span class="nottickedoff">SGuard</span> $ do</span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">e &lt;- validateExpression en ?=&gt; exactly TypeBool</span>
<span class="lineno"> 1589 </span><span class="spaces">    </span><span class="istickedoff">return [Condition  e]</span>
<span class="lineno"> 1590 </span><span class="spaces"></span><span class="istickedoff">--x in dom</span>
<span class="lineno"> 1591 </span><span class="spaces"></span><span class="istickedoff">validateComprehensionBody c@(CompBodyDomain apn l1 dom) = wrapRegion <span class="nottickedoff">c</span> <span class="nottickedoff">apn</span> <span class="nottickedoff">SGen</span> $ do</span>
<span class="lineno"> 1592 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1593 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;expr_in_domain_projection&quot;</span> <span class="nottickedoff">l1</span></span>
<span class="lineno"> 1594 </span><span class="spaces">    </span><span class="istickedoff">(td,domain) &lt;- typeSplit &lt;$&gt; validateDomain dom</span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="istickedoff">td' &lt;- projectionTypeDomain <span class="nottickedoff">(symbolRegion dom)</span> td</span>
<span class="lineno"> 1596 </span><span class="spaces">    </span><span class="istickedoff">pats &lt;- validateSequence_ (flip unifyPattern td' . Just) apn</span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="istickedoff">return  $ [Generator  (GenDomainNoRepr pat domain) | pat &lt;- pats]</span>
<span class="lineno"> 1598 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1599 </span><span class="spaces"></span><span class="istickedoff">-- x &lt;- expr</span>
<span class="lineno"> 1600 </span><span class="spaces"></span><span class="istickedoff">validateComprehensionBody c@(CompBodyGenExpr apn lt en) = wrapRegion <span class="nottickedoff">c</span> <span class="nottickedoff">apn</span> <span class="nottickedoff">SGen</span> $ do</span>
<span class="lineno"> 1601 </span><span class="spaces">    </span><span class="istickedoff">lt `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1602 </span><span class="spaces">    </span><span class="istickedoff">putKeywordDocs <span class="nottickedoff">&quot;expr_projection&quot;</span> <span class="nottickedoff">lt</span></span>
<span class="lineno"> 1603 </span><span class="spaces">    </span><span class="istickedoff">e &lt;- validateExpression en</span>
<span class="lineno"> 1604 </span><span class="spaces">    </span><span class="istickedoff">let (t,exp) = typeSplit e</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff">t' &lt;- projectionType <span class="nottickedoff">(symbolRegion en)</span> t</span>
<span class="lineno"> 1606 </span><span class="spaces">    </span><span class="istickedoff">pats &lt;- validateSequence_ (flip unifyPattern t' . Just) apn</span>
<span class="lineno"> 1607 </span><span class="spaces">    </span><span class="istickedoff">return  $ [Generator (GenInExpr pat exp)| pat &lt;- pats]</span>
<span class="lineno"> 1608 </span><span class="spaces"></span><span class="istickedoff">--letting x be</span>
<span class="lineno"> 1609 </span><span class="spaces"></span><span class="istickedoff">validateComprehensionBody c@(CompBodyLettingNode l1 nn l2 en) = wrapRegion <span class="nottickedoff">c</span> <span class="nottickedoff">nn</span> <span class="nottickedoff">SLetting</span> $ do</span>
<span class="lineno"> 1610 </span><span class="spaces">    </span><span class="istickedoff">l1 `isA` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1611 </span><span class="spaces">    </span><span class="istickedoff">l2 `isA'` <span class="nottickedoff">TtKeyword</span></span>
<span class="lineno"> 1612 </span><span class="spaces">    </span><span class="istickedoff">(t,expr) &lt;- typeSplit &lt;$&gt; validateExpression en</span>
<span class="lineno"> 1613 </span><span class="spaces">    </span><span class="istickedoff">pat &lt;- unifyPattern (Just nn) t</span>
<span class="lineno"> 1614 </span><span class="spaces">    </span><span class="istickedoff">return  [ComprehensionLetting pat expr]</span></span>
<span class="lineno"> 1615 </span>
<span class="lineno"> 1616 </span>
<span class="lineno"> 1617 </span>projectionType :: DiagnosticRegion -&gt; Type -&gt; ValidatorS Type
<span class="lineno"> 1618 </span><span class="decl"><span class="istickedoff">projectionType r t = case t of</span>
<span class="lineno"> 1619 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; return  TypeAny</span>
<span class="lineno"> 1620 </span><span class="spaces">          </span><span class="istickedoff">TypeTuple _ -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 1621 </span><span class="spaces">          </span><span class="istickedoff">TypeMatrix _ ty -&gt; return ty</span>
<span class="lineno"> 1622 </span><span class="spaces">          </span><span class="istickedoff">TypeList ty -&gt; return ty</span>
<span class="lineno"> 1623 </span><span class="spaces">          </span><span class="istickedoff">TypeSet ty -&gt; return ty</span>
<span class="lineno"> 1624 </span><span class="spaces">          </span><span class="istickedoff">TypeMSet ty -&gt; return ty</span>
<span class="lineno"> 1625 </span><span class="spaces">          </span><span class="istickedoff">TypeSequence ty -&gt; return $ TypeTuple [tInt,ty]</span>
<span class="lineno"> 1626 </span><span class="spaces">          </span><span class="istickedoff">TypeRelation ts -&gt; return $ TypeTuple ts</span>
<span class="lineno"> 1627 </span><span class="spaces">          </span><span class="istickedoff">TypePartition ty -&gt; <span class="nottickedoff">return $ TypeSet ty</span></span>
<span class="lineno"> 1628 </span><span class="spaces">          </span><span class="istickedoff">TypeFunction fr to -&gt; return $ TypeTuple [fr,to]</span>
<span class="lineno"> 1629 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(raiseTypeError $ r &lt;!&gt; SemanticError  (pack $ &quot;Expression of type &quot; ++ (show $ pretty t) ++ &quot; cannot be projected in a comprehension&quot;)) &gt;&gt; return TypeAny</span></span></span>
<span class="lineno"> 1630 </span>projectionTypeDomain :: DiagnosticRegion -&gt; Type -&gt; ValidatorS Type
<span class="lineno"> 1631 </span><span class="decl"><span class="istickedoff">projectionTypeDomain _ t = case t of --TODO check and do properly</span>
<span class="lineno"> 1632 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return  TypeAny</span></span>
<span class="lineno"> 1633 </span><span class="spaces">          </span><span class="istickedoff">TypeEnum (Name n) -&gt; return $ TypeInt $ TagEnum n</span>
<span class="lineno"> 1634 </span><span class="spaces">          </span><span class="istickedoff">TypeUnnamed (Name n) -&gt; return $ TypeInt $ TagUnnamed n</span>
<span class="lineno"> 1635 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; return t</span></span>
<span class="lineno"> 1636 </span>
<span class="lineno"> 1637 </span>        --   _ -&gt; (raiseTypeError $ r &lt;!&gt; SemanticError  (pack $ &quot;Domain of type &quot; ++ (show $pretty t) ++ &quot; cannot be projected in a comprehension&quot;)) &gt;&gt; return TypeAny
<span class="lineno"> 1638 </span>mkAbstractLiteral :: AbstractLiteral Expression -&gt; Expression
<span class="lineno"> 1639 </span><span class="decl"><span class="istickedoff">mkAbstractLiteral x = case e2c (AbstractLiteral x) of</span>
<span class="lineno"> 1640 </span><span class="spaces">                        </span><span class="istickedoff">Nothing -&gt; AbstractLiteral x</span>
<span class="lineno"> 1641 </span><span class="spaces">                        </span><span class="istickedoff">Just c -&gt; Constant c</span></span>
<span class="lineno"> 1642 </span>
<span class="lineno"> 1643 </span>
<span class="lineno"> 1644 </span>enforceConstraint :: Maybe Bool -&gt; String -&gt; ValidatorS ()
<span class="lineno"> 1645 </span><span class="decl"><span class="nottickedoff">enforceConstraint p msg = do</span>
<span class="lineno"> 1646 </span><span class="spaces">    </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 1647 </span><span class="spaces">        </span><span class="nottickedoff">Just True-&gt; return ()</span>
<span class="lineno"> 1648 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; void (contextError (CustomError $ pack msg))</span></span>
<span class="lineno"> 1649 </span>
<span class="lineno"> 1650 </span>
<span class="lineno"> 1651 </span>
<span class="lineno"> 1652 </span>checkSymbols :: [LToken] -&gt; ValidatorS ()
<span class="lineno"> 1653 </span><span class="decl"><span class="istickedoff">checkSymbols = mapM_ (\t -&gt; validateSymbol t)</span></span>
<span class="lineno"> 1654 </span>
<span class="lineno"> 1655 </span>--Raise a non structural error (i.e type error)
<span class="lineno"> 1656 </span>raiseError :: ValidatorDiagnostic -&gt; ValidatorS ()
<span class="lineno"> 1657 </span><span class="decl"><span class="istickedoff">raiseError e = tell [e]</span></span>
<span class="lineno"> 1658 </span>
<span class="lineno"> 1659 </span>raiseTypeError :: ValidatorDiagnostic -&gt; ValidatorS ()
<span class="lineno"> 1660 </span><span class="decl"><span class="istickedoff">raiseTypeError e = do</span>
<span class="lineno"> 1661 </span><span class="spaces">    </span><span class="istickedoff">tc &lt;- gets typeChecking</span>
<span class="lineno"> 1662 </span><span class="spaces">    </span><span class="istickedoff">when tc $ raiseError e</span></span>
<span class="lineno"> 1663 </span>makeTupleLiteral :: [Typed Expression] -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 1664 </span><span class="decl"><span class="istickedoff">makeTupleLiteral members = do</span>
<span class="lineno"> 1665 </span><span class="spaces">    </span><span class="istickedoff">let memberTypes = unzip $ map typeSplit members</span>
<span class="lineno"> 1666 </span><span class="spaces">    </span><span class="istickedoff">let eType = TypeTuple (fst memberTypes)</span>
<span class="lineno"> 1667 </span><span class="spaces">    </span><span class="istickedoff">return . Typed eType . mkAbstractLiteral . AbsLitTuple $ snd memberTypes</span></span>
<span class="lineno"> 1668 </span>
<span class="lineno"> 1669 </span>
<span class="lineno"> 1670 </span>validateIntLiteral :: SToken -&gt; ValidatorS Constant
<span class="lineno"> 1671 </span><span class="decl"><span class="istickedoff">validateIntLiteral t = do</span>
<span class="lineno"> 1672 </span><span class="spaces">    </span><span class="istickedoff">flagSToken t <span class="nottickedoff">TtNumber</span></span>
<span class="lineno"> 1673 </span><span class="spaces">    </span><span class="istickedoff">l &lt;- validateSToken t</span>
<span class="lineno"> 1674 </span><span class="spaces">    </span><span class="istickedoff">case l of</span>
<span class="lineno"> 1675 </span><span class="spaces">        </span><span class="istickedoff">(LIntLiteral x) -&gt; return $ ConstantInt TagInt x</span>
<span class="lineno"> 1676 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error &quot;Bad int literal&quot;</span></span></span>
<span class="lineno"> 1677 </span>
<span class="lineno"> 1678 </span>validateBoolLiteral :: SToken -&gt; ValidatorS Constant
<span class="lineno"> 1679 </span><span class="decl"><span class="istickedoff">validateBoolLiteral t = do</span>
<span class="lineno"> 1680 </span><span class="spaces">    </span><span class="istickedoff">flagSToken t <span class="nottickedoff">TtBool</span></span>
<span class="lineno"> 1681 </span><span class="spaces">    </span><span class="istickedoff">l &lt;- validateSToken t</span>
<span class="lineno"> 1682 </span><span class="spaces">    </span><span class="istickedoff">case l of</span>
<span class="lineno"> 1683 </span><span class="spaces">        </span><span class="istickedoff">L_true -&gt; return $ ConstantBool True</span>
<span class="lineno"> 1684 </span><span class="spaces">        </span><span class="istickedoff">L_false -&gt; return $ ConstantBool False</span>
<span class="lineno"> 1685 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error &quot;Bad bool literal&quot;</span></span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>validateNameList :: Sequence NameNode -&gt; ValidatorS [RegionTagged Name]
<span class="lineno"> 1688 </span><span class="decl"><span class="nottickedoff">validateNameList = validateSequence validateName</span></span>
<span class="lineno"> 1689 </span>
<span class="lineno"> 1690 </span>validateNameList_ :: Sequence NameNode -&gt; ValidatorS [Name]
<span class="lineno"> 1691 </span><span class="decl"><span class="nottickedoff">validateNameList_ = validateSequence_ validateName</span></span>
<span class="lineno"> 1692 </span>
<span class="lineno"> 1693 </span>validateIdentifierS :: NameNodeS -&gt; ValidatorS Text
<span class="lineno"> 1694 </span><span class="decl"><span class="istickedoff">validateIdentifierS (NameNodeS iden) = do</span>
<span class="lineno"> 1695 </span><span class="spaces">    </span><span class="istickedoff">q &lt;-  validateSToken iden</span>
<span class="lineno"> 1696 </span><span class="spaces">    </span><span class="istickedoff">case q of</span>
<span class="lineno"> 1697 </span><span class="spaces">        </span><span class="istickedoff">(LIdentifier x) -&gt; checkName x &gt;&gt; return x</span>
<span class="lineno"> 1698 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug  $ &quot;Name wasn't a name:&quot; &lt;+&gt; (pretty $ show  q)</span></span>
<span class="lineno"> 1699 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1700 </span><span class="spaces">        </span><span class="istickedoff">checkName :: Text -&gt; Validator Text</span>
<span class="lineno"> 1701 </span><span class="spaces">        </span><span class="istickedoff">checkName &quot;&quot; = <span class="nottickedoff">invalid $ iden &lt;!&gt; SemanticError &quot;Empty names not allowed&quot;</span></span>
<span class="lineno"> 1702 </span><span class="spaces">        </span><span class="istickedoff">checkName &quot;\&quot;\&quot;&quot; = <span class="nottickedoff">invalid $ iden &lt;!&gt; SemanticError  &quot;Empty names not allowed&quot;</span></span>
<span class="lineno"> 1703 </span><span class="spaces">        </span><span class="istickedoff">checkName x = return . <span class="nottickedoff">pure</span> $ <span class="nottickedoff">x</span></span></span>
<span class="lineno"> 1704 </span>
<span class="lineno"> 1705 </span>validateIdentifier :: NameNode -&gt; ValidatorS Text
<span class="lineno"> 1706 </span><span class="decl"><span class="istickedoff">validateIdentifier (NameNode nns) = validateIdentifierS nns</span>
<span class="lineno"> 1707 </span><span class="spaces"></span><span class="istickedoff">validateIdentifier (MissingNameNode iden) = do</span>
<span class="lineno"> 1708 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;-  validateSymbol iden</span>
<span class="lineno"> 1709 </span><span class="spaces">    </span><span class="istickedoff">return &quot; &lt;Missing name&gt;&quot;</span></span>
<span class="lineno"> 1710 </span>    
<span class="lineno"> 1711 </span>validateName :: NameNode -&gt; ValidatorS Name
<span class="lineno"> 1712 </span><span class="decl"><span class="istickedoff">validateName name = do</span>
<span class="lineno"> 1713 </span><span class="spaces">        </span><span class="istickedoff">n &lt;- validateIdentifier name</span>
<span class="lineno"> 1714 </span><span class="spaces">        </span><span class="istickedoff">return (Name n)</span></span>
<span class="lineno"> 1715 </span>
<span class="lineno"> 1716 </span>validateNameAs :: TagType -&gt; NameNode -&gt; ValidatorS Name
<span class="lineno"> 1717 </span><span class="decl"><span class="istickedoff">validateNameAs f (NameNode n) = tagNameAs <span class="nottickedoff">f</span> n</span>
<span class="lineno"> 1718 </span><span class="spaces"></span><span class="istickedoff">validateNameAs _ name = validateName name</span></span>
<span class="lineno"> 1719 </span>tagNameAs :: TagType -&gt; NameNodeS -&gt; ValidatorS Name
<span class="lineno"> 1720 </span><span class="decl"><span class="istickedoff">tagNameAs f nn@(NameNodeS n) = flagSToken n <span class="nottickedoff">f</span> &gt;&gt; Name &lt;$&gt; validateIdentifier (NameNode nn)</span></span>
<span class="lineno"> 1721 </span>
<span class="lineno"> 1722 </span>listToSeq :: ListNode a -&gt; ValidatorS (Sequence a)
<span class="lineno"> 1723 </span><span class="decl"><span class="istickedoff">listToSeq (ListNode l1 s l2) = checkSymbols [l1,l2] &gt;&gt; return s</span></span>
<span class="lineno"> 1724 </span>
<span class="lineno"> 1725 </span>--visit a sequence, return a list of elements, nothing if missing
<span class="lineno"> 1726 </span>sequenceElems :: (Flattenable a) =&gt; Sequence a -&gt; ValidatorS [Maybe a]
<span class="lineno"> 1727 </span><span class="decl"><span class="istickedoff">sequenceElems (Seq els) = mapM (validateSequenceElem_ validateIdentity) els</span></span>
<span class="lineno"> 1728 </span>
<span class="lineno"> 1729 </span>listElems :: Flattenable a =&gt; ListNode a -&gt; ValidatorS [Maybe a]
<span class="lineno"> 1730 </span><span class="decl"><span class="istickedoff">listElems = sequenceElems &lt;=&lt; listToSeq</span></span>
<span class="lineno"> 1731 </span>
<span class="lineno"> 1732 </span>
<span class="lineno"> 1733 </span>validateIdentity :: a -&gt; Validator a
<span class="lineno"> 1734 </span><span class="decl"><span class="istickedoff">validateIdentity = return . pure</span></span>
<span class="lineno"> 1735 </span>
<span class="lineno"> 1736 </span>validateArray :: (a -&gt; ValidatorS b) -&gt; [a] -&gt; ValidatorS [b]
<span class="lineno"> 1737 </span><span class="decl"><span class="istickedoff">validateArray f l = mapM f l</span></span>
<span class="lineno"> 1738 </span>
<span class="lineno"> 1739 </span>validateList :: (Flattenable a,Fallback b) =&gt;(a -&gt; ValidatorS b) -&gt; ListNode a -&gt; ValidatorS [RegionTagged b]
<span class="lineno"> 1740 </span><span class="decl"><span class="istickedoff">validateList validator (ListNode st seq end) = do</span>
<span class="lineno"> 1741 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- validateSymbol st</span>
<span class="lineno"> 1742 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- validateSymbol end</span>
<span class="lineno"> 1743 </span><span class="spaces">    </span><span class="istickedoff">validateSequence validator seq</span></span>
<span class="lineno"> 1744 </span>
<span class="lineno"> 1745 </span>validateList_ :: (Flattenable a,Fallback b) =&gt;(a -&gt; ValidatorS b) -&gt; ListNode a -&gt; ValidatorS [b]
<span class="lineno"> 1746 </span><span class="decl"><span class="istickedoff">validateList_ validator (ListNode st seq end) = do</span>
<span class="lineno"> 1747 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- validateSymbol st</span>
<span class="lineno"> 1748 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- validateSymbol end</span>
<span class="lineno"> 1749 </span><span class="spaces">    </span><span class="istickedoff">validateSequence_ validator seq</span></span>
<span class="lineno"> 1750 </span>
<span class="lineno"> 1751 </span>-- mapPrefixToOp :: Lexeme -&gt; Text
<span class="lineno"> 1752 </span>-- mapPrefixToOp x = case x of
<span class="lineno"> 1753 </span>--     L_Minus -&gt; &quot;negate&quot;
<span class="lineno"> 1754 </span>--     L_ExclamationMark -&gt; &quot;not&quot;
<span class="lineno"> 1755 </span>--     _ -&gt; pack $ lexemeFace x
<span class="lineno"> 1756 </span>
<span class="lineno"> 1757 </span>validateSequence :: (Flattenable a,Fallback b) =&gt;(a -&gt; ValidatorS b) -&gt; Sequence a -&gt; ValidatorS [RegionTagged b]
<span class="lineno"> 1758 </span><span class="decl"><span class="istickedoff">validateSequence f (Seq vals) = validateArray (validateSequenceElem f) vals</span></span>
<span class="lineno"> 1759 </span>validateSequence_ :: (Flattenable a,Fallback b) =&gt;(a -&gt; ValidatorS b) -&gt; Sequence a -&gt; ValidatorS [b]
<span class="lineno"> 1760 </span><span class="decl"><span class="istickedoff">validateSequence_ f s = do</span>
<span class="lineno"> 1761 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- validateSequence f s</span>
<span class="lineno"> 1762 </span><span class="spaces">    </span><span class="istickedoff">return . map snd $ q</span></span>
<span class="lineno"> 1763 </span>
<span class="lineno"> 1764 </span>validateSequenceElem :: (Flattenable a,Fallback b) =&gt; (a -&gt; ValidatorS b) -&gt; SeqElem a -&gt; ValidatorS (RegionTagged b)
<span class="lineno"> 1765 </span><span class="decl"><span class="istickedoff">validateSequenceElem f (SeqElem i s) = do</span>
<span class="lineno"> 1766 </span><span class="spaces">                            </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1767 </span><span class="spaces">                              </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1768 </span><span class="spaces">                              </span><span class="istickedoff">Just lt -&gt; void $ validateSymbol lt</span>
<span class="lineno"> 1769 </span><span class="spaces">                            </span><span class="istickedoff">v &lt;- f i</span>
<span class="lineno"> 1770 </span><span class="spaces">                            </span><span class="istickedoff">return (symbolRegion i,v)</span>
<span class="lineno"> 1771 </span><span class="spaces"></span><span class="istickedoff">validateSequenceElem _ (MissingSeqElem plc sepr) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">checkSymbols [sepr]</span></span>
<span class="lineno"> 1773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion plc &lt;!&gt; TokenError plc</span></span>
<span class="lineno"> 1774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return $ (symbolRegion plc , fallback &quot;Missing elem&quot;)</span></span></span>
<span class="lineno"> 1775 </span>
<span class="lineno"> 1776 </span>
<span class="lineno"> 1777 </span>validateSequenceElem_ :: (Flattenable a,Fallback b) =&gt; (a -&gt; ValidatorS b) -&gt; SeqElem a -&gt; ValidatorS (b)
<span class="lineno"> 1778 </span><span class="decl"><span class="istickedoff">validateSequenceElem_ f (SeqElem i s) = do</span>
<span class="lineno"> 1779 </span><span class="spaces">                            </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1780 </span><span class="spaces">                              </span><span class="istickedoff">Nothing -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1781 </span><span class="spaces">                              </span><span class="istickedoff">Just lt -&gt; void $ validateSymbol lt</span>
<span class="lineno"> 1782 </span><span class="spaces">                            </span><span class="istickedoff">f i</span>
<span class="lineno"> 1783 </span><span class="spaces"></span><span class="istickedoff">validateSequenceElem_ _ (MissingSeqElem plc sepr) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">checkSymbols [sepr]</span></span>
<span class="lineno"> 1785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseError $ symbolRegion plc &lt;!&gt; TokenError plc</span></span>
<span class="lineno"> 1786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return $ fallback &quot;Missing Elem&quot;</span></span></span>
<span class="lineno"> 1787 </span>
<span class="lineno"> 1788 </span>validateExprList :: ListNode ExpressionNode -&gt; ValidatorS [RegionTagged (Typed Expression)]
<span class="lineno"> 1789 </span><span class="decl"><span class="istickedoff">validateExprList = validateList validateExpression</span></span>
<span class="lineno"> 1790 </span>validateExprList_ :: ListNode ExpressionNode -&gt; ValidatorS [Typed Expression]
<span class="lineno"> 1791 </span><span class="decl"><span class="istickedoff">validateExprList_ = validateList_ validateExpression</span></span>
<span class="lineno"> 1792 </span>
<span class="lineno"> 1793 </span>
<span class="lineno"> 1794 </span>offsetPositionBy :: Int -&gt; SourcePos -&gt; SourcePos
<span class="lineno"> 1795 </span><span class="decl"><span class="istickedoff">offsetPositionBy amt sp@(SourcePos _ _ (unPos-&gt;r)) = sp {sourceColumn=mkPos (amt+r) }</span></span>
<span class="lineno"> 1796 </span>
<span class="lineno"> 1797 </span>data DiagnosticRegion = DiagnosticRegion {
<span class="lineno"> 1798 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">drSourcePos</span></span></span>::SourcePos,
<span class="lineno"> 1799 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">drEndPos</span></span></span> :: SourcePos,
<span class="lineno"> 1800 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">drOffset</span></span></span> :: Int,
<span class="lineno"> 1801 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">drLength</span></span></span> :: Int
<span class="lineno"> 1802 </span>}
<span class="lineno"> 1803 </span>    deriving (<span class="decl"><span class="nottickedoff">Show</span></span>,<span class="decl"><span class="istickedoff">Eq</span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno"> 1804 </span>global :: DiagnosticRegion
<span class="lineno"> 1805 </span><span class="decl"><span class="istickedoff">global =DiagnosticRegion sourcePos0 <span class="nottickedoff">sourcePos0</span> <span class="nottickedoff">0</span> <span class="nottickedoff">0</span></span></span>
<span class="lineno"> 1806 </span>-- getTokenRegion :: LToken -&gt; DiagnosticRegion
<span class="lineno"> 1807 </span>-- getTokenRegion a =  do
<span class="lineno"> 1808 </span>--         let h =case a of
<span class="lineno"> 1809 </span>--               RealToken et -&gt; et
<span class="lineno"> 1810 </span>--               MissingToken et -&gt; et
<span class="lineno"> 1811 </span>--               SkippedToken et -&gt; et
<span class="lineno"> 1812 </span>--         let start = tokenSourcePos h
<span class="lineno"> 1813 </span>--         let offset = tokenStart h
<span class="lineno"> 1814 </span>--         let tLength =case a of
<span class="lineno"> 1815 </span>--               RealToken _ -&gt; trueLength h
<span class="lineno"> 1816 </span>--               MissingToken _ -&gt; 1
<span class="lineno"> 1817 </span>--               SkippedToken _ -&gt; trueLength h
<span class="lineno"> 1818 </span>--         DiagnosticRegion start (offsetPositionBy tLength start) offset tLength
<span class="lineno"> 1819 </span>
<span class="lineno"> 1820 </span>symbolRegion :: Flattenable a =&gt; a -&gt; DiagnosticRegion
<span class="lineno"> 1821 </span><span class="decl"><span class="istickedoff">symbolRegion a = case range of</span>
<span class="lineno"> 1822 </span><span class="spaces">        </span><span class="istickedoff">(h :&lt;| rst) -&gt; do</span>
<span class="lineno"> 1823 </span><span class="spaces">                </span><span class="istickedoff">let end =case viewr rst of</span>
<span class="lineno"> 1824 </span><span class="spaces">                        </span><span class="istickedoff">EmptyR -&gt; h</span>
<span class="lineno"> 1825 </span><span class="spaces">                        </span><span class="istickedoff">_ :&gt; et -&gt; <span class="nottickedoff">et</span></span>
<span class="lineno"> 1826 </span><span class="spaces">                </span><span class="istickedoff">let start = tokenSourcePos h</span>
<span class="lineno"> 1827 </span><span class="spaces">                </span><span class="istickedoff">let offset = tokenStart h</span>
<span class="lineno"> 1828 </span><span class="spaces">                </span><span class="istickedoff">let tLength = sum (totalLength &lt;$&gt; rst) + trueLength h</span>
<span class="lineno"> 1829 </span><span class="spaces">                </span><span class="istickedoff">let en = tokenSourcePos end</span>
<span class="lineno"> 1830 </span><span class="spaces">                </span><span class="istickedoff">DiagnosticRegion start (offsetPositionBy (trueLength end) en) offset tLength</span>
<span class="lineno"> 1831 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">global</span></span>
<span class="lineno"> 1832 </span><span class="spaces">        </span><span class="istickedoff">where range :: Seq ETok = flatten a</span></span>
<span class="lineno"> 1833 </span>
<span class="lineno"> 1834 </span>
<span class="lineno"> 1835 </span>(&lt;!&gt;) :: WithRegion a =&gt; a -&gt; ErrorType -&gt; ValidatorDiagnostic
<span class="lineno"> 1836 </span><span class="decl"><span class="istickedoff">t &lt;!&gt; e = ValidatorDiagnostic (getRegion t) $ Error e</span></span>
<span class="lineno"> 1837 </span>
<span class="lineno"> 1838 </span>(/!\) :: WithRegion a  =&gt; a -&gt; WarningType -&gt; ValidatorDiagnostic
<span class="lineno"> 1839 </span><span class="decl"><span class="istickedoff">t /!\ e = ValidatorDiagnostic (getRegion t) $ Warning e</span></span>
<span class="lineno"> 1840 </span>
<span class="lineno"> 1841 </span>(&lt;?&gt;) :: WithRegion a  =&gt; a -&gt; InfoType -&gt; ValidatorDiagnostic
<span class="lineno"> 1842 </span><span class="decl"><span class="nottickedoff">t &lt;?&gt; e = ValidatorDiagnostic (getRegion t) $ Info e</span></span>
<span class="lineno"> 1843 </span>
<span class="lineno"> 1844 </span>-- (&lt;?!&gt;) :: WithRegion a  =&gt; Maybe a -&gt; ErrorType -&gt; ValidatorDiagnostic
<span class="lineno"> 1845 </span>-- Nothing &lt;?!&gt; e =  ValidatorDiagnostic global $ Error e
<span class="lineno"> 1846 </span>-- Just t &lt;?!&gt; e =  t &lt;!&gt; e
<span class="lineno"> 1847 </span>
<span class="lineno"> 1848 </span>contextError :: ErrorType -&gt; Validator a
<span class="lineno"> 1849 </span><span class="decl"><span class="nottickedoff">contextError e = do</span>
<span class="lineno"> 1850 </span><span class="spaces">    </span><span class="nottickedoff">q &lt;- getContext</span>
<span class="lineno"> 1851 </span><span class="spaces">    </span><span class="nottickedoff">invalid $ ValidatorDiagnostic q $ Error e</span></span>
<span class="lineno"> 1852 </span>
<span class="lineno"> 1853 </span>contextTypeError :: ErrorType -&gt; ValidatorS ()
<span class="lineno"> 1854 </span><span class="decl"><span class="istickedoff">contextTypeError e = do</span>
<span class="lineno"> 1855 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- getContext</span>
<span class="lineno"> 1856 </span><span class="spaces">    </span><span class="istickedoff">tc &lt;- gets typeChecking</span>
<span class="lineno"> 1857 </span><span class="spaces">    </span><span class="istickedoff">when tc $ raiseError $ ValidatorDiagnostic q $ Error e</span></span>
<span class="lineno"> 1858 </span>
<span class="lineno"> 1859 </span>contextInfo :: InfoType -&gt; ValidatorS ()
<span class="lineno"> 1860 </span><span class="decl"><span class="istickedoff">contextInfo e = do</span>
<span class="lineno"> 1861 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- getContext</span>
<span class="lineno"> 1862 </span><span class="spaces">    </span><span class="istickedoff">tell [ValidatorDiagnostic <span class="nottickedoff">q</span> $ Info <span class="nottickedoff">e</span>]</span>
<span class="lineno"> 1863 </span><span class="spaces">    </span><span class="istickedoff">return <span class="nottickedoff">()</span></span></span>
<span class="lineno"> 1864 </span>
<span class="lineno"> 1865 </span>-- getType :: (Pretty a ,TypeOf a) =&gt; a -&gt; ValidatorS Type
<span class="lineno"> 1866 </span>-- getType a = do
<span class="lineno"> 1867 </span>--         tc &lt;- gets typeChecking
<span class="lineno"> 1868 </span>--         (if tc then (do
<span class="lineno"> 1869 </span>--            let t = let ?typeCheckerMode = StronglyTyped  in typeOf a
<span class="lineno"> 1870 </span>--            case t of
<span class="lineno"> 1871 </span>--                Left err -&gt; do
<span class="lineno"> 1872 </span>--                    void $ contextError (CustomError . pack $ &quot;type err in :&quot; ++ show (pretty a) ++ &quot;err:&quot; ++ show err)
<span class="lineno"> 1873 </span>--                    return  TypeAny
<span class="lineno"> 1874 </span>--                Right ty -&gt; return ty) else return TypeAny)
<span class="lineno"> 1875 </span>
<span class="lineno"> 1876 </span>
<span class="lineno"> 1877 </span>-- assertType :: (Pretty a,TypeOf a) =&gt; Typed a -&gt; Type -&gt; Text -&gt; ValidatorS ()
<span class="lineno"> 1878 </span>-- assertType v ref msg = do
<span class="lineno"> 1879 </span>--     let Typed t _ = v
<span class="lineno"> 1880 </span>--     tc &lt;- gets typeChecking
<span class="lineno"> 1881 </span>--     unless (not tc || t == ref) $ void . contextError $ CustomError msg
<span class="lineno"> 1882 </span>
<span class="lineno"> 1883 </span>resolveReference :: RegionTagged Name -&gt; ValidatorS Kind
<span class="lineno"> 1884 </span><span class="decl"><span class="istickedoff">resolveReference (r,Name n) | <span class="tickonlytrue">n /= &quot;&quot;</span> = do</span>
<span class="lineno"> 1885 </span><span class="spaces">    </span><span class="istickedoff">c &lt;- getSymbol n</span>
<span class="lineno"> 1886 </span><span class="spaces">    </span><span class="istickedoff">case c of</span>
<span class="lineno"> 1887 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; raiseTypeError (r &lt;!&gt; (CustomError  (T.concat [&quot;Symbol not found \&quot;&quot; , n , &quot;\&quot;&quot;]))) &gt;&gt; return (simple TypeAny)</span>
<span class="lineno"> 1888 </span><span class="spaces">      </span><span class="istickedoff">Just (reg,_,t) -&gt; do</span>
<span class="lineno"> 1889 </span><span class="spaces">        </span><span class="istickedoff">putReference <span class="nottickedoff">r</span> <span class="nottickedoff">n</span> <span class="nottickedoff">t</span> <span class="nottickedoff">reg</span></span>
<span class="lineno"> 1890 </span><span class="spaces">        </span><span class="istickedoff">-- addRegion (RegionInfo {rRegion=r,rText=n, rType=Just t, rDeclaration=Ref reg})</span>
<span class="lineno"> 1891 </span><span class="spaces">        </span><span class="istickedoff">return t</span>
<span class="lineno"> 1892 </span><span class="spaces"></span><span class="istickedoff">resolveReference _ = <span class="nottickedoff">return $ simple TypeAny</span></span></span>
<span class="lineno"> 1893 </span>
<span class="lineno"> 1894 </span>sameType :: [RegionTagged (Typed a)] -&gt; ValidatorS (Typed [a])
<span class="lineno"> 1895 </span><span class="decl"><span class="istickedoff">sameType [] = return $ Typed TypeAny []</span>
<span class="lineno"> 1896 </span><span class="spaces"></span><span class="istickedoff">sameType xs@(x:_) = do</span>
<span class="lineno"> 1897 </span><span class="spaces">    </span><span class="istickedoff">let ?typeCheckerMode = <span class="nottickedoff">StronglyTyped</span></span>
<span class="lineno"> 1898 </span><span class="spaces">    </span><span class="istickedoff">let t = mostDefined $ map (typeOf_.snd) xs</span>
<span class="lineno"> 1899 </span><span class="spaces">    </span><span class="istickedoff">let t' = mostDefined [t , typeOf_ $ snd x] --Do this again to set type to first elem if possible </span>
<span class="lineno"> 1900 </span><span class="spaces">    </span><span class="istickedoff">xs' &lt;- mapM (unifyTypes t') xs</span>
<span class="lineno"> 1901 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed t' xs'</span></span>
<span class="lineno"> 1902 </span>
<span class="lineno"> 1903 </span>typesUnifyS :: [Type] -&gt; Bool
<span class="lineno"> 1904 </span><span class="decl"><span class="nottickedoff">typesUnifyS = let ?typeCheckerMode=StronglyTyped in typesUnify</span></span>
<span class="lineno"> 1905 </span>
<span class="lineno"> 1906 </span>mostDefinedS :: [Type] -&gt; Type
<span class="lineno"> 1907 </span><span class="decl"><span class="istickedoff">mostDefinedS [] = <span class="nottickedoff">TypeAny</span></span>
<span class="lineno"> 1908 </span><span class="spaces"></span><span class="istickedoff">mostDefinedS [x] =  <span class="nottickedoff">x</span></span>
<span class="lineno"> 1909 </span><span class="spaces"></span><span class="istickedoff">mostDefinedS (x:xs) = let ?typeCheckerMode=StronglyTyped in case mostDefined (xs++[x]) of</span>
<span class="lineno"> 1910 </span><span class="spaces">                                                                </span><span class="istickedoff">TypeAny -&gt; x</span>
<span class="lineno"> 1911 </span><span class="spaces">                                                                </span><span class="istickedoff">t -&gt; t</span></span>
<span class="lineno"> 1912 </span>
<span class="lineno"> 1913 </span>unifyTypes :: Type -&gt; RegionTagged (Typed a) -&gt; ValidatorS a
<span class="lineno"> 1914 </span><span class="decl"><span class="istickedoff">unifyTypes _ (r,Typed TypeAny a) = do raiseError (<span class="nottickedoff">r</span> /!\ AmbiguousTypeWarning) &gt;&gt; return a</span>
<span class="lineno"> 1915 </span><span class="spaces"></span><span class="istickedoff">unifyTypes t (r,Typed t' a) = do</span>
<span class="lineno"> 1916 </span><span class="spaces">    </span><span class="istickedoff">let ?typeCheckerMode = StronglyTyped</span>
<span class="lineno"> 1917 </span><span class="spaces">    </span><span class="istickedoff">if typesUnify [t', t] then pure <span class="nottickedoff">()</span> else raiseTypeError $ <span class="nottickedoff">r &lt;!&gt; TypeError t t'</span></span>
<span class="lineno"> 1918 </span><span class="spaces">    </span><span class="istickedoff">return a</span></span>
<span class="lineno"> 1919 </span>
<span class="lineno"> 1920 </span>unifyTypesFailing :: Type -&gt; RegionTagged (Typed a) -&gt; Validator a
<span class="lineno"> 1921 </span><span class="decl"><span class="istickedoff">unifyTypesFailing _ (r,Typed TypeAny a) = do raiseError (<span class="nottickedoff">r</span> /!\ AmbiguousTypeWarning) &gt;&gt; (return $ <span class="nottickedoff">Just a</span>)</span>
<span class="lineno"> 1922 </span><span class="spaces"></span><span class="istickedoff">unifyTypesFailing t (r,Typed t' a) = do</span>
<span class="lineno"> 1923 </span><span class="spaces">    </span><span class="istickedoff">tc &lt;- gets typeChecking</span>
<span class="lineno"> 1924 </span><span class="spaces">    </span><span class="istickedoff">let ?typeCheckerMode = StronglyTyped</span>
<span class="lineno"> 1925 </span><span class="spaces">    </span><span class="istickedoff">if not tc || typesUnify [t', t]  then return $ Just <span class="nottickedoff">a</span> else invalid (r &lt;!&gt; TypeError t t')</span></span>
<span class="lineno"> 1926 </span>
<span class="lineno"> 1927 </span>
<span class="lineno"> 1928 </span>scoped :: ValidatorS a -&gt; ValidatorS a
<span class="lineno"> 1929 </span><span class="decl"><span class="istickedoff">scoped m = do</span>
<span class="lineno"> 1930 </span><span class="spaces">    </span><span class="istickedoff">st &lt;- gets symbolTable</span>
<span class="lineno"> 1931 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- m</span>
<span class="lineno"> 1932 </span><span class="spaces">    </span><span class="istickedoff">modifySymbolTable $ const st</span>
<span class="lineno"> 1933 </span><span class="spaces">    </span><span class="istickedoff">return res</span></span>
<span class="lineno"> 1934 </span>
<span class="lineno"> 1935 </span>unifyPatterns :: Type -&gt; [Maybe AbstractPatternNode] -&gt; ValidatorS [AbstractPattern]
<span class="lineno"> 1936 </span><span class="decl"><span class="istickedoff">unifyPatterns t =  mapM (flip unifyPattern t)</span></span>
<span class="lineno"> 1937 </span>
<span class="lineno"> 1938 </span>unifyPattern :: Maybe AbstractPatternNode -&gt; Type -&gt; ValidatorS AbstractPattern
<span class="lineno"> 1939 </span><span class="decl"><span class="istickedoff">unifyPattern  (Just (AbstractIdentifier nn)) t = do</span>
<span class="lineno"> 1940 </span><span class="spaces">    </span><span class="istickedoff">(nm) &lt;- tagNameAs <span class="nottickedoff">TtLocal</span> nn</span>
<span class="lineno"> 1941 </span><span class="spaces">    </span><span class="istickedoff">let n =case nm of</span>
<span class="lineno"> 1942 </span><span class="spaces">          </span><span class="istickedoff">Name txt -&gt; txt</span>
<span class="lineno"> 1943 </span><span class="spaces">          </span><span class="istickedoff">NameMetaVar s -&gt; <span class="nottickedoff">T.pack s</span></span>
<span class="lineno"> 1944 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug &quot;Bad name &quot;</span></span>
<span class="lineno"> 1945 </span><span class="spaces">    </span><span class="istickedoff">void $ putSymbol (Name n,(<span class="nottickedoff">symbolRegion nn</span>,<span class="nottickedoff">False</span>,simple t))</span>
<span class="lineno"> 1946 </span><span class="spaces">    </span><span class="istickedoff">unless (n == &quot;_&quot;) $ addRegion $ <span class="nottickedoff">mkDeclaration (symbolRegion nn) n (simple t)</span></span>
<span class="lineno"> 1947 </span><span class="spaces">    </span><span class="istickedoff">-- addRegion (RegionInfo (symbolRegion nn) (Just $ simple t) n Definition)</span>
<span class="lineno"> 1948 </span><span class="spaces">    </span><span class="istickedoff">return  $ Single $  Name n</span>
<span class="lineno"> 1949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1950 </span><span class="spaces"></span><span class="istickedoff">unifyPattern (Just(AbstractMetaVar lt)) _ = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">s &lt;- validateMetaVar lt</span></span>
<span class="lineno"> 1952 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return $ AbstractPatternMetaVar s</span></span>
<span class="lineno"> 1953 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1954 </span><span class="spaces"></span><span class="istickedoff">unifyPattern (Just(AbstractPatternTuple m_lt ln)) t = do</span>
<span class="lineno"> 1955 </span><span class="spaces">    </span><span class="istickedoff">sps &lt;-listToSeq ln</span>
<span class="lineno"> 1956 </span><span class="spaces">    </span><span class="istickedoff">ps &lt;-sequenceElems sps</span>
<span class="lineno"> 1957 </span><span class="spaces">    </span><span class="istickedoff">case m_lt of</span>
<span class="lineno"> 1958 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; void $ return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1959 </span><span class="spaces">        </span><span class="istickedoff">Just lt -&gt; <span class="nottickedoff">lt `isA'` TtType</span></span>
<span class="lineno"> 1960 </span><span class="spaces">    </span><span class="istickedoff">memberTypes &lt;- case t of</span>
<span class="lineno"> 1961 </span><span class="spaces">        </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ replicate (length ps) TypeAny</span></span>
<span class="lineno"> 1962 </span><span class="spaces">        </span><span class="istickedoff">TypeTuple ts-&gt; do</span>
<span class="lineno"> 1963 </span><span class="spaces">            </span><span class="istickedoff">let dif = length ts - length ps </span>
<span class="lineno"> 1964 </span><span class="spaces">            </span><span class="istickedoff">unless (dif &lt;= 0) $ <span class="nottickedoff">raiseError $ symbolRegion ln &lt;!&gt; (CustomError . T.pack $ &quot;Missing &quot;++ show dif ++ &quot; fields from projection tuple, if you dont want the value, use '_'&quot;)</span></span>
<span class="lineno"> 1965 </span><span class="spaces">            </span><span class="istickedoff">return $ ts</span>
<span class="lineno"> 1966 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">replicate (length ps) TypeAny &lt;$ raiseTypeError (symbolRegion ln &lt;!&gt; (CustomError (T.concat [&quot;Could not project &quot; , (prettyT t) , &quot; onto tuple pattern&quot;])))</span></span>
<span class="lineno"> 1967 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 1968 </span><span class="spaces">    </span><span class="istickedoff">let (paired,unpaired) = (splitAt (length memberTypes) ps)</span>
<span class="lineno"> 1969 </span><span class="spaces">    </span><span class="istickedoff">let q = zip paired memberTypes</span>
<span class="lineno"> 1970 </span><span class="spaces">    </span><span class="istickedoff">aps &lt;- mapM (uncurry unifyPattern) q</span>
<span class="lineno"> 1971 </span><span class="spaces">    </span><span class="istickedoff">mapM_ <span class="nottickedoff">(\x -&gt;raiseError $ (symbolRegion x) &lt;!&gt; CustomError &quot;Extraneous tuple field from projection&quot; )</span> (catMaybes unpaired)</span>
<span class="lineno"> 1972 </span><span class="spaces">    </span><span class="istickedoff">return  $ AbsPatTuple aps</span>
<span class="lineno"> 1973 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1974 </span><span class="spaces"></span><span class="istickedoff">unifyPattern (Just(AbstractPatternMatrix ln)) t = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">sps &lt;-listToSeq ln</span></span>
<span class="lineno"> 1976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ps &lt;-sequenceElems sps</span></span>
<span class="lineno"> 1977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">memberTypes &lt;- case t of </span></span>
<span class="lineno"> 1978 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TypeAny -&gt; return $ repeat TypeAny</span></span>
<span class="lineno"> 1979 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TypeList ty -&gt; return $ repeat ty</span></span>
<span class="lineno"> 1980 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">TypeMatrix _ ty -&gt; return $ repeat ty</span></span>
<span class="lineno"> 1981 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; repeat TypeAny &lt;$ raiseTypeError (symbolRegion ln &lt;!&gt; (CustomError (T.concat [&quot;Could not project &quot; , (prettyT t) , &quot; onto list pattern&quot;])))</span></span>
<span class="lineno"> 1982 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1983 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">let q = zip (ps) memberTypes</span></span>
<span class="lineno"> 1984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">aps &lt;- mapM (uncurry unifyPattern) q</span></span>
<span class="lineno"> 1985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return  $ AbsPatMatrix aps</span></span>
<span class="lineno"> 1986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1987 </span><span class="spaces"></span><span class="istickedoff">unifyPattern (Just(AbstractPatternSet ln)) t = do</span>
<span class="lineno"> 1988 </span><span class="spaces">    </span><span class="istickedoff">sps &lt;-listToSeq ln</span>
<span class="lineno"> 1989 </span><span class="spaces">    </span><span class="istickedoff">ps &lt;-sequenceElems sps</span>
<span class="lineno"> 1990 </span><span class="spaces">    </span><span class="istickedoff">memberTypes &lt;- case t of </span>
<span class="lineno"> 1991 </span><span class="spaces">        </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ repeat TypeAny</span></span>
<span class="lineno"> 1992 </span><span class="spaces">        </span><span class="istickedoff">TypeSet ty -&gt; return $ repeat ty</span>
<span class="lineno"> 1993 </span><span class="spaces">        </span><span class="istickedoff">TypeMSet ty -&gt; <span class="nottickedoff">return $ repeat ty</span></span>
<span class="lineno"> 1994 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(repeat TypeAny) &lt;$ raiseTypeError (symbolRegion ln &lt;!&gt; (CustomError (T.concat [&quot;Could not project &quot; , (prettyT t) , &quot; onto set pattern&quot;])))</span></span>
<span class="lineno"> 1995 </span><span class="spaces">    </span><span class="istickedoff">let q = zip ps memberTypes</span>
<span class="lineno"> 1996 </span><span class="spaces">    </span><span class="istickedoff">aps &lt;-mapM (uncurry unifyPattern) q</span>
<span class="lineno"> 1997 </span><span class="spaces">    </span><span class="istickedoff">return $ AbsPatSet aps</span>
<span class="lineno"> 1998 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1999 </span><span class="spaces"></span><span class="istickedoff">unifyPattern Nothing _ = <span class="nottickedoff">return . Single $ fallback &quot;No Pattern&quot;</span></span></span>
<span class="lineno"> 2000 </span>
<span class="lineno"> 2001 </span>
<span class="lineno"> 2002 </span>catRegions :: [RegionTagged a] -&gt; DiagnosticRegion
<span class="lineno"> 2003 </span><span class="decl"><span class="nottickedoff">catRegions [] = global</span>
<span class="lineno"> 2004 </span><span class="spaces"></span><span class="nottickedoff">catRegions xs = DiagnosticRegion {</span>
<span class="lineno"> 2005 </span><span class="spaces">    </span><span class="nottickedoff">drSourcePos=drSourcePos .fst  $ head xs,</span>
<span class="lineno"> 2006 </span><span class="spaces">    </span><span class="nottickedoff">drEndPos=drEndPos .fst  $ last xs,</span>
<span class="lineno"> 2007 </span><span class="spaces">    </span><span class="nottickedoff">drOffset=drOffset.fst $ head xs,</span>
<span class="lineno"> 2008 </span><span class="spaces">    </span><span class="nottickedoff">drLength=sum $ map (drLength.fst) xs</span>
<span class="lineno"> 2009 </span><span class="spaces">    </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 2010 </span>
<span class="lineno"> 2011 </span>
<span class="lineno"> 2012 </span>getMemberTypes :: Type -&gt; ValidatorS [Type]
<span class="lineno"> 2013 </span><span class="decl"><span class="nottickedoff">getMemberTypes t = case t of</span>
<span class="lineno"> 2014 </span><span class="spaces">  </span><span class="nottickedoff">TypeAny -&gt; return $ repeat TypeAny</span>
<span class="lineno"> 2015 </span><span class="spaces"></span><span class="nottickedoff">--   TypeUnnamed na -&gt; </span>
<span class="lineno"> 2016 </span><span class="spaces">  </span><span class="nottickedoff">TypeTuple tys -&gt; return tys</span>
<span class="lineno"> 2017 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; return $ repeat TypeAny</span></span>
<span class="lineno"> 2018 </span>-- unifyAbstractPatternOverExpression :: AbstractPatternNode -&gt; Expression -&gt; Validator (Name,Type)
<span class="lineno"> 2019 </span>-- unifyAbstractPatternOverExpression pat exp = do
<span class="lineno"> 2020 </span>--     t &lt;- typeOf exp
<span class="lineno"> 2021 </span>
<span class="lineno"> 2022 </span>--     empty
<span class="lineno"> 2023 </span>
<span class="lineno"> 2024 </span>getDomainMembers :: Type -&gt; Type
<span class="lineno"> 2025 </span><span class="decl"><span class="istickedoff">getDomainMembers t = case t of</span>
<span class="lineno"> 2026 </span><span class="spaces">  </span><span class="istickedoff">TypeAny -&gt; t</span>
<span class="lineno"> 2027 </span><span class="spaces">  </span><span class="istickedoff">TypeBool -&gt; t</span>
<span class="lineno"> 2028 </span><span class="spaces">  </span><span class="istickedoff">TypeInt it -&gt; case it of</span>
<span class="lineno"> 2029 </span><span class="spaces">    </span><span class="istickedoff">TagInt -&gt; t</span>
<span class="lineno"> 2030 </span><span class="spaces">    </span><span class="istickedoff">TagEnum _ -&gt; <span class="nottickedoff">error &quot;Domain should use typeEnum instead&quot;</span></span>
<span class="lineno"> 2031 </span><span class="spaces">    </span><span class="istickedoff">TagUnnamed _ -&gt; <span class="nottickedoff">error &quot;Domain should use typeUnamed instead&quot;</span></span>
<span class="lineno"> 2032 </span><span class="spaces">  </span><span class="istickedoff">TypeEnum n -&gt; TypeInt . TagEnum $ case n of</span>
<span class="lineno"> 2033 </span><span class="spaces">    </span><span class="istickedoff">Name txt -&gt; txt</span>
<span class="lineno"> 2034 </span><span class="spaces">    </span><span class="istickedoff">MachineName {} -&gt; <span class="nottickedoff">error &quot;This should never be user specified&quot;</span></span>
<span class="lineno"> 2035 </span><span class="spaces">    </span><span class="istickedoff">NameMetaVar s -&gt; <span class="nottickedoff">pack s</span></span>
<span class="lineno"> 2036 </span><span class="spaces">  </span><span class="istickedoff">TypeUnnamed n -&gt; TypeInt . TagUnnamed $ case n of</span>
<span class="lineno"> 2037 </span><span class="spaces">    </span><span class="istickedoff">Name txt -&gt; txt</span>
<span class="lineno"> 2038 </span><span class="spaces">    </span><span class="istickedoff">MachineName {} -&gt; <span class="nottickedoff">error &quot;This should never be user specified&quot;</span></span>
<span class="lineno"> 2039 </span><span class="spaces">    </span><span class="istickedoff">NameMetaVar s -&gt; <span class="nottickedoff">pack s</span></span>
<span class="lineno"> 2040 </span><span class="spaces">  </span><span class="istickedoff">TypeTuple tys -&gt; TypeTuple $ map getDomainMembers tys</span>
<span class="lineno"> 2041 </span><span class="spaces">  </span><span class="istickedoff">TypeRecord tys -&gt; TypeRecord $ map (second getDomainMembers) tys</span>
<span class="lineno"> 2042 </span><span class="spaces">  </span><span class="istickedoff">TypeVariant tys -&gt; TypeVariant $ map (second getDomainMembers) tys</span>
<span class="lineno"> 2043 </span><span class="spaces">  </span><span class="istickedoff">TypeList ty -&gt; <span class="nottickedoff">TypeList $ getDomainMembers ty</span></span>
<span class="lineno"> 2044 </span><span class="spaces">  </span><span class="istickedoff">TypeMatrix ty ty' -&gt; TypeMatrix ty $ getDomainMembers ty'</span>
<span class="lineno"> 2045 </span><span class="spaces">  </span><span class="istickedoff">TypeSet ty -&gt; TypeSet $ getDomainMembers ty</span>
<span class="lineno"> 2046 </span><span class="spaces">  </span><span class="istickedoff">TypeMSet ty -&gt; TypeMSet $ getDomainMembers ty</span>
<span class="lineno"> 2047 </span><span class="spaces">  </span><span class="istickedoff">TypeFunction ty ty' -&gt; TypeFunction  (getDomainMembers ty) (getDomainMembers ty')</span>
<span class="lineno"> 2048 </span><span class="spaces">  </span><span class="istickedoff">TypeSequence ty -&gt; TypeSequence $ getDomainMembers ty</span>
<span class="lineno"> 2049 </span><span class="spaces">  </span><span class="istickedoff">TypeRelation tys -&gt; TypeRelation $ map getDomainMembers tys</span>
<span class="lineno"> 2050 </span><span class="spaces">  </span><span class="istickedoff">TypePartition ty -&gt; TypePartition $ getDomainMembers ty</span>
<span class="lineno"> 2051 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug $ &quot;Unknown domain type&quot; &lt;+&gt; pretty t</span></span></span>
<span class="lineno"> 2052 </span>
<span class="lineno"> 2053 </span>getDomainFromValue :: Type -&gt; Type
<span class="lineno"> 2054 </span><span class="decl"><span class="nottickedoff">getDomainFromValue t = case t of</span>
<span class="lineno"> 2055 </span><span class="spaces">  </span><span class="nottickedoff">TypeAny -&gt; t</span>
<span class="lineno"> 2056 </span><span class="spaces">  </span><span class="nottickedoff">TypeBool -&gt; t</span>
<span class="lineno"> 2057 </span><span class="spaces">  </span><span class="nottickedoff">TypeInt it -&gt; case it of</span>
<span class="lineno"> 2058 </span><span class="spaces">    </span><span class="nottickedoff">TagInt -&gt; t</span>
<span class="lineno"> 2059 </span><span class="spaces">    </span><span class="nottickedoff">TagEnum n -&gt; TypeEnum (Name n)</span>
<span class="lineno"> 2060 </span><span class="spaces">    </span><span class="nottickedoff">TagUnnamed n -&gt; TypeUnnamed (Name n)</span>
<span class="lineno"> 2061 </span><span class="spaces">  </span><span class="nottickedoff">TypeEnum _ -&gt; t</span>
<span class="lineno"> 2062 </span><span class="spaces">  </span><span class="nottickedoff">TypeUnnamed _ -&gt; t</span>
<span class="lineno"> 2063 </span><span class="spaces">  </span><span class="nottickedoff">TypeTuple tys -&gt; TypeTuple $ map getDomainFromValue tys</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="nottickedoff">TypeRecord tys -&gt; TypeRecord $ map (second getDomainFromValue) tys</span>
<span class="lineno"> 2065 </span><span class="spaces">  </span><span class="nottickedoff">TypeVariant tys -&gt; TypeVariant $ map (second getDomainFromValue) tys</span>
<span class="lineno"> 2066 </span><span class="spaces">  </span><span class="nottickedoff">TypeList ty -&gt; TypeList $ getDomainFromValue ty</span>
<span class="lineno"> 2067 </span><span class="spaces">  </span><span class="nottickedoff">TypeMatrix ty ty' -&gt; TypeMatrix ty $ getDomainFromValue ty'</span>
<span class="lineno"> 2068 </span><span class="spaces">  </span><span class="nottickedoff">TypeSet ty -&gt; TypeSet $ getDomainFromValue ty</span>
<span class="lineno"> 2069 </span><span class="spaces">  </span><span class="nottickedoff">TypeMSet ty -&gt; TypeMSet $ getDomainFromValue ty</span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="nottickedoff">TypeFunction ty ty' -&gt; TypeFunction  (getDomainFromValue ty) (getDomainFromValue ty')</span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="nottickedoff">TypeSequence ty -&gt; TypeSequence $ getDomainFromValue ty</span>
<span class="lineno"> 2072 </span><span class="spaces">  </span><span class="nottickedoff">TypeRelation tys -&gt; TypeRelation $ map getDomainFromValue tys</span>
<span class="lineno"> 2073 </span><span class="spaces">  </span><span class="nottickedoff">TypePartition ty -&gt; TypePartition $ getDomainFromValue ty</span>
<span class="lineno"> 2074 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; bug $ &quot;Unknown member type&quot; &lt;+&gt; pretty t</span></span>
<span class="lineno"> 2075 </span>
<span class="lineno"> 2076 </span>
<span class="lineno"> 2077 </span>
<span class="lineno"> 2078 </span>data DomainTyped a = DomainTyped DomainType a
<span class="lineno"> 2079 </span>
<span class="lineno"> 2080 </span>data DomainSize = Unkown | Infinite | Sized Int
<span class="lineno"> 2081 </span>data DomainType
<span class="lineno"> 2082 </span>    = DomainTypeBool
<span class="lineno"> 2083 </span>    | DomainTypeInt DomainSize
<span class="lineno"> 2084 </span>    | DomainTypeTuple [DomainType]
<span class="lineno"> 2085 </span>
<span class="lineno"> 2086 </span>f2n :: (a -&gt; ValidatorS b) -&gt; a -&gt;Validator b
<span class="lineno"> 2087 </span><span class="decl"><span class="istickedoff">f2n f a = do</span>
<span class="lineno"> 2088 </span><span class="spaces">    </span><span class="istickedoff">q &lt;- f a</span>
<span class="lineno"> 2089 </span><span class="spaces">    </span><span class="istickedoff">return $ Just q</span></span>
<span class="lineno"> 2090 </span>
<span class="lineno"> 2091 </span>class Fallback a where
<span class="lineno"> 2092 </span>    fallback :: Text -&gt; a
<span class="lineno"> 2093 </span>
<span class="lineno"> 2094 </span>instance Fallback (Domain () Expression) where
<span class="lineno"> 2095 </span>    <span class="decl"><span class="nottickedoff">fallback reason = DomainAny reason TypeAny</span></span>
<span class="lineno"> 2096 </span>
<span class="lineno"> 2097 </span>instance Fallback Expression where
<span class="lineno"> 2098 </span>    <span class="decl"><span class="nottickedoff">fallback reason = Reference (Name reason) Nothing</span></span>
<span class="lineno"> 2099 </span>
<span class="lineno"> 2100 </span>instance (Fallback a) =&gt; Fallback (Typed a) where
<span class="lineno"> 2101 </span>    <span class="decl"><span class="istickedoff">fallback = Typed TypeAny . <span class="nottickedoff">fallback</span></span></span>
<span class="lineno"> 2102 </span>instance (Fallback a) =&gt; Fallback (Kind, a) where
<span class="lineno"> 2103 </span>    <span class="decl"><span class="nottickedoff">fallback  msg = (Kind ValueType TypeAny , fallback msg)</span></span>
<span class="lineno"> 2104 </span>instance Fallback (Maybe a) where
<span class="lineno"> 2105 </span>    <span class="decl"><span class="nottickedoff">fallback = const Nothing</span></span>
<span class="lineno"> 2106 </span>instance Fallback Name where
<span class="lineno"> 2107 </span>    <span class="decl"><span class="nottickedoff">fallback = Name</span></span>
<span class="lineno"> 2108 </span>
<span class="lineno"> 2109 </span>
<span class="lineno"> 2110 </span>instance Fallback [a] where
<span class="lineno"> 2111 </span>    fallback :: Text -&gt; [a]
<span class="lineno"> 2112 </span>    <span class="decl"><span class="nottickedoff">fallback = const []</span></span>
<span class="lineno"> 2113 </span>
<span class="lineno"> 2114 </span>instance Fallback AbstractPattern where
<span class="lineno"> 2115 </span>    <span class="decl"><span class="nottickedoff">fallback = Single . fallback</span></span>
<span class="lineno"> 2116 </span>
<span class="lineno"> 2117 </span>type FuncOpDec = (Int)
<span class="lineno"> 2118 </span>
<span class="lineno"> 2119 </span>
<span class="lineno"> 2120 </span>funcOpBuilder :: Lexeme -&gt; [Arg] -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2121 </span><span class="decl"><span class="istickedoff">funcOpBuilder l = (functionOps l) (mkOp $ FunctionOp l)</span></span>
<span class="lineno"> 2122 </span>-- functionOps l@L_fAnd = (validateArgList [isLogicalContainer],const TypeBool)
<span class="lineno"> 2123 </span>functionOps :: Lexeme -&gt; ([Expression] -&gt; Expression) -&gt; [Arg] -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2124 </span><span class="decl"><span class="istickedoff">functionOps l = case l of</span>
<span class="lineno"> 2125 </span><span class="spaces">    </span><span class="istickedoff">L_fAnd -&gt; unFuncV isLogicalContainer (pure . const TypeBool)</span>
<span class="lineno"> 2126 </span><span class="spaces">    </span><span class="istickedoff">L_fOr -&gt;   unFuncV isLogicalContainer (pure . const TypeBool)</span>
<span class="lineno"> 2127 </span><span class="spaces">    </span><span class="istickedoff">L_fXor -&gt;  <span class="nottickedoff">unFuncV isLogicalContainer (pure . const TypeBool)</span></span>
<span class="lineno"> 2128 </span><span class="spaces">    </span><span class="istickedoff">L_Sum -&gt;   unFuncV sumArgs (pure . const tInt)</span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="istickedoff">L_Product -&gt;   unFunc (valueOnly sumArgs) (pure . const tInt)</span>
<span class="lineno"> 2130 </span><span class="spaces">    </span><span class="istickedoff">L_true -&gt; unFuncV anyType (pure . const TypeBool)</span>
<span class="lineno"> 2131 </span><span class="spaces">    </span><span class="istickedoff">L_toInt -&gt; unFuncV (only TypeBool) (pure . const tInt)</span>
<span class="lineno"> 2132 </span><span class="spaces">    </span><span class="istickedoff">L_makeTable -&gt; <span class="nottickedoff">unFuncV (only TypeBool) (pure . const TypeBool)</span></span>
<span class="lineno"> 2133 </span><span class="spaces">    </span><span class="istickedoff">L_table -&gt; <span class="nottickedoff">biFuncV tableArgs (const2 TypeBool)</span></span>
<span class="lineno"> 2134 </span><span class="spaces">    </span><span class="istickedoff">L_gcc -&gt; <span class="nottickedoff">triFunc (each3 $ valueOnly listInt) (const3 TypeBool)</span></span>
<span class="lineno"> 2135 </span><span class="spaces">    </span><span class="istickedoff">L_atleast -&gt; triFunc (each3 $ valueOnly listInt) (const3 TypeBool)</span>
<span class="lineno"> 2136 </span><span class="spaces">    </span><span class="istickedoff">L_atmost -&gt; triFunc (each3 $ valueOnly listInt) (const3 TypeBool)</span>
<span class="lineno"> 2137 </span><span class="spaces">    </span><span class="istickedoff">L_defined -&gt; unFuncV funcSeq (fmap TypeSet . funcDomain)</span>
<span class="lineno"> 2138 </span><span class="spaces">    </span><span class="istickedoff">L_range -&gt; unFuncV funcSeq (fmap TypeSet . funcRange)</span>
<span class="lineno"> 2139 </span><span class="spaces">    </span><span class="istickedoff">L_restrict -&gt; <span class="nottickedoff">biFunc restrictArgs restrictTypes</span></span>
<span class="lineno"> 2140 </span><span class="spaces">    </span><span class="istickedoff">L_allDiff -&gt; unFuncV listOrMatrix (const $ pure TypeBool)</span>
<span class="lineno"> 2141 </span><span class="spaces">    </span><span class="istickedoff">L_alldifferent_except -&gt; biFuncV (indep listOrMatrix enumerable) (const2 TypeBool)</span>
<span class="lineno"> 2142 </span><span class="spaces">    </span><span class="istickedoff">L_catchUndef -&gt;  <span class="nottickedoff">biFuncV unifies (\a b -&gt; pure $ mostDefinedS $ catMaybes [a,b])</span></span>
<span class="lineno"> 2143 </span><span class="spaces">    </span><span class="istickedoff">L_dontCare -&gt; unFunc anyType (const $ pure TypeBool)</span>
<span class="lineno"> 2144 </span><span class="spaces">    </span><span class="istickedoff">L_toSet -&gt; unFuncV toSetArgs typeToSet</span>
<span class="lineno"> 2145 </span><span class="spaces">    </span><span class="istickedoff">L_toMSet -&gt; unFuncV toMSetArgs typeToMSet</span>
<span class="lineno"> 2146 </span><span class="spaces">    </span><span class="istickedoff">L_toRelation -&gt; unFuncV func typeToRelation</span>
<span class="lineno"> 2147 </span><span class="spaces">    </span><span class="istickedoff">L_max -&gt; unFunc minMaxArgs minMaxType</span>
<span class="lineno"> 2148 </span><span class="spaces">    </span><span class="istickedoff">L_min -&gt; unFunc minMaxArgs minMaxType</span>
<span class="lineno"> 2149 </span><span class="spaces">    </span><span class="istickedoff">L_image -&gt; biFuncV imageArgs (const . funcRange)</span>
<span class="lineno"> 2150 </span><span class="spaces">    </span><span class="istickedoff">L_transform -&gt; <span class="nottickedoff">biFuncV transformArgs (const id)</span></span>
<span class="lineno"> 2151 </span><span class="spaces">    </span><span class="istickedoff">L_imageSet -&gt; <span class="nottickedoff">biFuncV imSetArgs (\a -&gt; const $ TypeSet &lt;$&gt; funcRange a)</span></span>
<span class="lineno"> 2152 </span><span class="spaces">    </span><span class="istickedoff">L_preImage -&gt; biFuncV preImageArgs (\a -&gt; const $ TypeSet &lt;$&gt; funcDomain a)</span>
<span class="lineno"> 2153 </span><span class="spaces">    </span><span class="istickedoff">L_inverse -&gt; biFuncV inverseArgs (const2 TypeBool)</span>
<span class="lineno"> 2154 </span><span class="spaces">    </span><span class="istickedoff">L_freq -&gt; biFuncV freqArgs (const2 tInt)</span>
<span class="lineno"> 2155 </span><span class="spaces">    </span><span class="istickedoff">L_hist -&gt; unFuncV histArgs histType</span>
<span class="lineno"> 2156 </span><span class="spaces">    </span><span class="istickedoff">L_parts -&gt; unFuncV part partsType</span>
<span class="lineno"> 2157 </span><span class="spaces">    </span><span class="istickedoff">L_together -&gt; biFuncV setPartArgs (const2 TypeBool)</span>
<span class="lineno"> 2158 </span><span class="spaces">    </span><span class="istickedoff">L_apart -&gt; biFuncV setPartArgs (const2 TypeBool)</span>
<span class="lineno"> 2159 </span><span class="spaces">    </span><span class="istickedoff">L_party -&gt; biFuncV partyArgs partyType</span>
<span class="lineno"> 2160 </span><span class="spaces">    </span><span class="istickedoff">L_participants -&gt; unFuncV part partInner</span>
<span class="lineno"> 2161 </span><span class="spaces">    </span><span class="istickedoff">L_active -&gt; biFuncV activeArgs (const2 TypeBool)</span>
<span class="lineno"> 2162 </span><span class="spaces">    </span><span class="istickedoff">L_pred -&gt; <span class="nottickedoff">unFuncV enumerable enumerableType</span></span>
<span class="lineno"> 2163 </span><span class="spaces">    </span><span class="istickedoff">L_succ -&gt; <span class="nottickedoff">unFuncV enumerable enumerableType</span></span>
<span class="lineno"> 2164 </span><span class="spaces">    </span><span class="istickedoff">L_factorial -&gt; unFuncV (only tInt) (const $ pure tInt)</span>
<span class="lineno"> 2165 </span><span class="spaces">    </span><span class="istickedoff">L_powerSet -&gt; unFuncV set powerSetType</span>
<span class="lineno"> 2166 </span><span class="spaces">    </span><span class="istickedoff">L_concatenate -&gt; <span class="nottickedoff">unFuncV concatArgs concatType</span></span>
<span class="lineno"> 2167 </span><span class="spaces">    </span><span class="istickedoff">L_flatten -&gt; \ b a -&gt; case a of</span>
<span class="lineno"> 2168 </span><span class="spaces">                            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">unFuncV unaryFlattenArgs (flattenType Nothing) b a</span></span>
<span class="lineno"> 2169 </span><span class="spaces">                            </span><span class="istickedoff">[_] -&gt; unFuncV unaryFlattenArgs (flattenType Nothing) b a</span>
<span class="lineno"> 2170 </span><span class="spaces">                            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">biFunc (valueOnly2 binaryFlattenArgs) (\v t -&gt; flattenType (getNum v) (typeOnly t)) (b) a</span></span>
<span class="lineno"> 2171 </span><span class="spaces">    </span><span class="istickedoff">_  -&gt; <span class="nottickedoff">bug $ pretty $ &quot;Unkown functional operator &quot; ++ show l</span></span>
<span class="lineno"> 2172 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 2173 </span><span class="spaces">        </span><span class="istickedoff">valueOnly :: (SArg -&gt; Validator a) -&gt; Arg -&gt; Validator a</span>
<span class="lineno"> 2174 </span><span class="spaces">        </span><span class="istickedoff">valueOnly f (r,(k,e)) = do</span>
<span class="lineno"> 2175 </span><span class="spaces">            </span><span class="istickedoff">t &lt;- getValueType k</span>
<span class="lineno"> 2176 </span><span class="spaces">            </span><span class="istickedoff">f (<span class="nottickedoff">r</span>,Typed t <span class="nottickedoff">e</span>)</span>
<span class="lineno"> 2177 </span><span class="spaces">        </span><span class="istickedoff">valueOnly2 :: (SArg -&gt; SArg -&gt; Validator a) -&gt; Arg -&gt; Arg -&gt; Validator a</span>
<span class="lineno"> 2178 </span><span class="spaces">        </span><span class="istickedoff">valueOnly2 f (r1,(k1,e1)) (r2,(k2,e2)) = do</span>
<span class="lineno"> 2179 </span><span class="spaces">            </span><span class="istickedoff">t1 &lt;- getValueType k1</span>
<span class="lineno"> 2180 </span><span class="spaces">            </span><span class="istickedoff">t2 &lt;- getValueType k2</span>
<span class="lineno"> 2181 </span><span class="spaces">            </span><span class="istickedoff">f (r1,Typed t1 <span class="nottickedoff">e1</span>) (r2,Typed t2 <span class="nottickedoff">e2</span>)</span>
<span class="lineno"> 2182 </span><span class="spaces">        </span><span class="istickedoff">typeOnly :: Maybe (Kind,Expression) -&gt; Maybe Type</span>
<span class="lineno"> 2183 </span><span class="spaces">        </span><span class="istickedoff">typeOnly (Just (Kind ValueType t,_)) = Just t</span>
<span class="lineno"> 2184 </span><span class="spaces">        </span><span class="istickedoff">typeOnly _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2185 </span><span class="spaces">        </span><span class="istickedoff">unFuncV a t= unFunc (valueOnly a) (t . typeOnly)</span>
<span class="lineno"> 2186 </span><span class="spaces">        </span><span class="istickedoff">biFuncV :: (SArg -&gt; SArg -&gt; Validator ()) -&gt; (Maybe Type-&gt; Maybe Type -&gt; Maybe Type) -&gt; ([Expression] -&gt; Expression) -&gt; [Arg] -&gt; ValidatorS (Typed Expression)</span>
<span class="lineno"> 2187 </span><span class="spaces">        </span><span class="istickedoff">biFuncV a t = biFunc (valueOnly2 a) (\t1 t2-&gt; t (typeOnly t1) (typeOnly t2))</span>
<span class="lineno"> 2188 </span><span class="spaces">        </span><span class="istickedoff">valid = return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2189 </span><span class="spaces">        </span><span class="istickedoff">const2 = const.const . pure</span>
<span class="lineno"> 2190 </span><span class="spaces">        </span><span class="istickedoff">const3 = const.const.const . pure</span>
<span class="lineno"> 2191 </span><span class="spaces">        </span><span class="istickedoff">getNum :: Maybe (Kind,Expression) -&gt; Maybe Int</span>
<span class="lineno"> 2192 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">getNum (Just(_, x)) = case intOut &quot;&quot; x of</span></span>
<span class="lineno"> 2193 </span><span class="spaces">                                    </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 2194 </span><span class="spaces">                                    </span><span class="istickedoff"><span class="nottickedoff">Just n -&gt; pure $ fromInteger n</span></span>
<span class="lineno"> 2195 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">getNum _ = Nothing</span></span>
<span class="lineno"> 2196 </span><span class="spaces">        </span><span class="istickedoff">each3 f a b c= f a &gt;&gt; f b &gt;&gt; f c</span>
<span class="lineno"> 2197 </span><span class="spaces">        </span><span class="istickedoff">anyType = const . return $ Just  <span class="nottickedoff">()</span></span>
<span class="lineno"> 2198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2199 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2200 </span><span class="spaces">        </span><span class="istickedoff">indep :: (SArg -&gt; Validator ()) -&gt; (SArg -&gt; Validator ()) -&gt; (SArg -&gt; SArg -&gt; Validator ())</span>
<span class="lineno"> 2201 </span><span class="spaces">        </span><span class="istickedoff">indep f1 f2 a b = do</span>
<span class="lineno"> 2202 </span><span class="spaces">            </span><span class="istickedoff">v1 &lt;- f1 a</span>
<span class="lineno"> 2203 </span><span class="spaces">            </span><span class="istickedoff">v2 &lt;- f2 b</span>
<span class="lineno"> 2204 </span><span class="spaces">            </span><span class="istickedoff">if <span class="tickonlytrue">not . null $ catMaybes $ [v1,<span class="nottickedoff">v2</span>]</span> then return $ pure <span class="nottickedoff">()</span> else <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 2205 </span><span class="spaces">        </span><span class="istickedoff">binaryFlattenArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2206 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">binaryFlattenArgs (r1,d) b = do</span></span>
<span class="lineno"> 2207 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">off &lt;- case intOut &quot;&quot; (untype d) of</span></span>
<span class="lineno"> 2208 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Just (fromInteger-&gt;a :: Integer) | a &gt; 0 -&gt; return $ Just a</span></span>
<span class="lineno"> 2209 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; invalid $ r1 &lt;!&gt; CustomError &quot;1st arg must be a constant positive int&quot;</span></span>
<span class="lineno"> 2210 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let ref = map (const TypeList) [0..fromMaybe 1 off]</span></span>
<span class="lineno"> 2211 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let ref' = foldr id TypeAny ref</span></span>
<span class="lineno"> 2212 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">r &lt;- unifyTypesFailing ref' b</span></span>
<span class="lineno"> 2213 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ if null off || null r then  Nothing else Just ()</span></span>
<span class="lineno"> 2214 </span><span class="spaces">        </span><span class="istickedoff">unaryFlattenArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2215 </span><span class="spaces">        </span><span class="istickedoff">unaryFlattenArgs (_,typeOf_-&gt;(TypeMatrix _ _)) = valid</span>
<span class="lineno"> 2216 </span><span class="spaces">        </span><span class="istickedoff">unaryFlattenArgs (_,typeOf_-&gt;(TypeList _)) = valid</span>
<span class="lineno"> 2217 </span><span class="spaces">        </span><span class="istickedoff">unaryFlattenArgs (_,typeOf_-&gt;TypeAny) = valid</span>
<span class="lineno"> 2218 </span><span class="spaces">        </span><span class="istickedoff">unaryFlattenArgs (r,typeOf_-&gt;t) = <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;List or Matrix &quot; t</span></span>
<span class="lineno"> 2219 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2220 </span><span class="spaces">        </span><span class="istickedoff">concatType :: Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2221 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatType (Just(TypeMatrix _ (TypeList t))) = Just $ TypeList t</span></span>
<span class="lineno"> 2222 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatType (Just(TypeMatrix _ (TypeMatrix _ t))) = Just $ TypeList t</span></span>
<span class="lineno"> 2223 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatType (Just(TypeList (TypeList t))) = Just $ TypeList t</span></span>
<span class="lineno"> 2224 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatType (Just(TypeList (TypeMatrix _ t))) = Just $ TypeList t</span></span>
<span class="lineno"> 2225 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatType _ = Just $ TypeList TypeAny</span></span>
<span class="lineno"> 2226 </span><span class="spaces">        </span><span class="istickedoff">concatArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2227 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">concatArgs s@(r,_)= binaryFlattenArgs (r,Typed tInt $ Constant $ ConstantInt TagInt 1) s</span></span>
<span class="lineno"> 2228 </span><span class="spaces">        </span><span class="istickedoff">tableArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2229 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">tableArgs (r1,typeOf_-&gt;t1) (r2,typeOf_-&gt;t2) = do</span></span>
<span class="lineno"> 2230 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">a &lt;- case t1 of</span></span>
<span class="lineno"> 2231 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">t | isValidInner t -&gt; valid</span></span>
<span class="lineno"> 2232 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; invalid $ r1 &lt;!&gt; ComplexTypeError &quot;Matrix of Int/Enum&quot; t1</span></span>
<span class="lineno"> 2233 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">b &lt;-  case t2 of</span></span>
<span class="lineno"> 2234 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeAny -&gt; valid</span></span>
<span class="lineno"> 2235 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeList t | isValidInner t-&gt; valid</span></span>
<span class="lineno"> 2236 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">TypeMatrix _ t | isValidInner t-&gt; valid</span></span>
<span class="lineno"> 2237 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; invalid $ r2 &lt;!&gt; ComplexTypeError &quot;Matrix of Matrix of Int/Enum&quot; t2</span></span>
<span class="lineno"> 2238 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 2239 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ if null a || null b then Nothing else Just ()</span></span>
<span class="lineno"> 2240 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno"> 2241 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">isValidInner t = case t of</span></span>
<span class="lineno"> 2242 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeAny -&gt; True</span></span>
<span class="lineno"> 2243 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeList TypeInt{} -&gt; True</span></span>
<span class="lineno"> 2244 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeList  TypeAny-&gt; True</span></span>
<span class="lineno"> 2245 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeMatrix _ TypeInt{} -&gt; True</span></span>
<span class="lineno"> 2246 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">TypeMatrix _ TypeAny -&gt; True</span></span>
<span class="lineno"> 2247 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; False</span></span>
<span class="lineno"> 2248 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2249 </span><span class="spaces">        </span><span class="istickedoff">toMSetArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2250 </span><span class="spaces">        </span><span class="istickedoff">toMSetArgs (r,typeOf_-&gt; a) = case a of</span>
<span class="lineno"> 2251 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2252 </span><span class="spaces">          </span><span class="istickedoff">TypeList _ -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2253 </span><span class="spaces">          </span><span class="istickedoff">TypeMatrix {} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2254 </span><span class="spaces">          </span><span class="istickedoff">TypeMSet {} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2255 </span><span class="spaces">          </span><span class="istickedoff">TypeSet {} -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2256 </span><span class="spaces">          </span><span class="istickedoff">TypeFunction {} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2257 </span><span class="spaces">          </span><span class="istickedoff">TypeRelation {} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2258 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Matrix ,list,function,relation,mset,set &quot; a</span></span>
<span class="lineno"> 2259 </span><span class="spaces">        </span><span class="istickedoff">toSetArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2260 </span><span class="spaces">        </span><span class="istickedoff">toSetArgs (r,typeOf_-&gt; a) = case a of</span>
<span class="lineno"> 2261 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2262 </span><span class="spaces">          </span><span class="istickedoff">TypeList _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2263 </span><span class="spaces">          </span><span class="istickedoff">TypeMatrix {} -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2264 </span><span class="spaces">          </span><span class="istickedoff">TypeMSet {} -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2265 </span><span class="spaces">          </span><span class="istickedoff">TypeFunction {} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2266 </span><span class="spaces">          </span><span class="istickedoff">TypeRelation {} -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2267 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Matrix ,list,function,relation,mset &quot; a</span></span>
<span class="lineno"> 2268 </span><span class="spaces">        </span><span class="istickedoff">listOrMatrix :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2269 </span><span class="spaces">        </span><span class="istickedoff">listOrMatrix (r,typeOf_-&gt; a) = case a of</span>
<span class="lineno"> 2270 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2271 </span><span class="spaces">          </span><span class="istickedoff">TypeList _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2272 </span><span class="spaces">          </span><span class="istickedoff">TypeMatrix {} -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2273 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Matrix or list&quot; a</span></span>
<span class="lineno"> 2274 </span><span class="spaces">        </span><span class="istickedoff">freqArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2275 </span><span class="spaces">        </span><span class="istickedoff">freqArgs (r1,a) (r2,b) = do</span>
<span class="lineno"> 2276 </span><span class="spaces">            </span><span class="istickedoff">let tb = typeOf_ b</span>
<span class="lineno"> 2277 </span><span class="spaces">            </span><span class="istickedoff">let (rt,ti) = case typeOf_ a of</span>
<span class="lineno"> 2278 </span><span class="spaces">                    </span><span class="istickedoff">TypeMatrix idx ms -&gt; (TypeMatrix idx md,md) where md = mostDefinedS [tb,ms]</span>
<span class="lineno"> 2279 </span><span class="spaces">                    </span><span class="istickedoff">TypeMSet ms -&gt; (TypeMSet md,md) where md = mostDefinedS [tb,ms]</span>
<span class="lineno"> 2280 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(TypeMatrix tInt tb,tb)</span></span>
<span class="lineno"> 2281 </span><span class="spaces">            </span><span class="istickedoff">a' &lt;- unifyTypesFailing rt (<span class="nottickedoff">r1</span>,a)</span>
<span class="lineno"> 2282 </span><span class="spaces">            </span><span class="istickedoff">b' &lt;- unifyTypesFailing ti (<span class="nottickedoff">r2</span>,b)</span>
<span class="lineno"> 2283 </span><span class="spaces">            </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null a' || null b'</span> then  <span class="nottickedoff">Nothing</span> else Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 2284 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2285 </span><span class="spaces">        </span><span class="istickedoff">unifies :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2286 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">unifies a b = do</span></span>
<span class="lineno"> 2287 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let md = mostDefinedS $ map (typeOf_.unregion) [a,b]</span></span>
<span class="lineno"> 2288 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- unifyTypesFailing md a</span></span>
<span class="lineno"> 2289 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- unifyTypesFailing md b</span></span>
<span class="lineno"> 2290 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ if null a' || null b' then Nothing else Just ()</span></span>
<span class="lineno"> 2291 </span><span class="spaces">        </span><span class="istickedoff">func :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2292 </span><span class="spaces">        </span><span class="istickedoff">func (_,Typed (TypeFunction _ _) _) = valid</span>
<span class="lineno"> 2293 </span><span class="spaces">        </span><span class="istickedoff">func (_,Typed TypeAny _) = <span class="nottickedoff">valid</span></span>
<span class="lineno"> 2294 </span><span class="spaces">        </span><span class="istickedoff">func (r,Typed t _) = <span class="nottickedoff">invalid $ r &lt;!&gt; TypeError (TypeFunction TypeAny TypeAny) t</span></span>
<span class="lineno"> 2295 </span><span class="spaces">        </span><span class="istickedoff">set :: SArg -&gt; Validator Type</span>
<span class="lineno"> 2296 </span><span class="spaces">        </span><span class="istickedoff">set (_,Typed (TypeSet t) _) = return $ pure <span class="nottickedoff">t</span></span>
<span class="lineno"> 2297 </span><span class="spaces">        </span><span class="istickedoff">set (_,Typed TypeAny _) = <span class="nottickedoff">return $ pure TypeAny</span></span>
<span class="lineno"> 2298 </span><span class="spaces">        </span><span class="istickedoff">set (r,Typed t _) = <span class="nottickedoff">invalid $ r &lt;!&gt; TypeError (TypeSet TypeAny) t</span></span>
<span class="lineno"> 2299 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2300 </span><span class="spaces">        </span><span class="istickedoff">powerSetType (Just ((TypeSet i))) = Just $ TypeSet (TypeSet i)</span>
<span class="lineno"> 2301 </span><span class="spaces">        </span><span class="istickedoff">powerSetType _ = <span class="nottickedoff">Just $ TypeSet $ TypeSet TypeAny</span></span>
<span class="lineno"> 2302 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2303 </span><span class="spaces">        </span><span class="istickedoff">only t (r,typeOf_-&gt;t')= do setContext <span class="nottickedoff">r</span>; if <span class="tickonlytrue">t'==TypeAny || t == t'</span> then return $ Just <span class="nottickedoff">t</span> else <span class="nottickedoff">invalid $ r &lt;!&gt; TypeError t t'</span></span>
<span class="lineno"> 2304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2305 </span><span class="spaces">        </span><span class="istickedoff">listInt (r,typeOf_-&gt;t') = case t' of</span>
<span class="lineno"> 2306 </span><span class="spaces">          </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ Just t'</span></span>
<span class="lineno"> 2307 </span><span class="spaces">          </span><span class="istickedoff">TypeList TypeInt{} -&gt; <span class="nottickedoff">return $ Just t'</span></span>
<span class="lineno"> 2308 </span><span class="spaces">          </span><span class="istickedoff">TypeMatrix _ TypeInt{} -&gt; return $ Just <span class="nottickedoff">t'</span></span>
<span class="lineno"> 2309 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Matrix or list of int or enum&quot; t'</span></span>
<span class="lineno"> 2310 </span><span class="spaces">        </span><span class="istickedoff">partInner :: Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2311 </span><span class="spaces">        </span><span class="istickedoff">partInner (Just (TypePartition a)) = Just $ TypeSet a</span>
<span class="lineno"> 2312 </span><span class="spaces">        </span><span class="istickedoff">partInner _ = Just $ TypeSet TypeAny</span>
<span class="lineno"> 2313 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2314 </span><span class="spaces">        </span><span class="istickedoff">restrictArgs :: Arg -&gt; Arg -&gt; Validator ()</span>
<span class="lineno"> 2315 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">restrictArgs (r1,(k,_)) (r2,(kd,_)) = do</span></span>
<span class="lineno"> 2316 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">setContext r1</span></span>
<span class="lineno"> 2317 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">funcType &lt;- getValueType k</span></span>
<span class="lineno"> 2318 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">setContext r2</span></span>
<span class="lineno"> 2319 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">domType &lt;- getDomainType kd</span></span>
<span class="lineno"> 2320 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">unifyTypesFailing (TypeFunction domType TypeAny) (r1,Typed funcType ())</span></span>
<span class="lineno"> 2321 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2322 </span><span class="spaces">        </span><span class="istickedoff">restrictTypes :: Maybe (Kind,Expression) -&gt; Maybe (Kind,Expression) -&gt; Maybe Type</span>
<span class="lineno"> 2323 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">restrictTypes (fmap fst -&gt; kv) (fmap fst-&gt; kd) = Just $ TypeFunction from to</span></span>
<span class="lineno"> 2324 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno"> 2325 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">dType = case kd of</span></span>
<span class="lineno"> 2326 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">Just (Kind DomainType t) -&gt; getDomainMembers t</span></span>
<span class="lineno"> 2327 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; TypeAny</span></span>
<span class="lineno"> 2328 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">from = case kv of</span></span>
<span class="lineno"> 2329 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">Just (Kind ValueType (TypeFunction fr _)) | typesUnifyS [dType,fr]-&gt; mostDefinedS [dType,fr]</span></span>
<span class="lineno"> 2330 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">Just (Kind ValueType (TypeFunction fr _)) -&gt;  fr</span></span>
<span class="lineno"> 2331 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; mostDefinedS [TypeAny,dType]</span></span>
<span class="lineno"> 2332 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">to = case kv of</span></span>
<span class="lineno"> 2333 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Just (Kind ValueType (TypeFunction _ to')) -&gt; to'</span></span>
<span class="lineno"> 2334 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; TypeAny</span></span>
<span class="lineno"> 2335 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2336 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2337 </span><span class="spaces">        </span><span class="istickedoff">imSetArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2338 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">imSetArgs (r1,a) (r2,b) = do</span></span>
<span class="lineno"> 2339 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let t = case (typeOf_ a,typeOf_ b) of</span></span>
<span class="lineno"> 2340 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(TypeFunction i _,tb) -&gt; mostDefinedS [i,tb]</span></span>
<span class="lineno"> 2341 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(TypeSequence _,_) -&gt; tInt</span></span>
<span class="lineno"> 2342 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(_,tb ) -&gt; tb</span></span>
<span class="lineno"> 2343 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- unifyTypesFailing (TypeFunction t TypeAny) (r1,a)</span></span>
<span class="lineno"> 2344 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- unifyTypesFailing t (r2,b)</span></span>
<span class="lineno"> 2345 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ if null a' || null b' then  Nothing else Just ()</span></span>
<span class="lineno"> 2346 </span><span class="spaces">        </span><span class="istickedoff">preImageArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2347 </span><span class="spaces">        </span><span class="istickedoff">preImageArgs (r1,a) (r2,b) = do</span>
<span class="lineno"> 2348 </span><span class="spaces">            </span><span class="istickedoff">let t = case (typeOf_ a,typeOf_ b) of</span>
<span class="lineno"> 2349 </span><span class="spaces">                    </span><span class="istickedoff">(TypeFunction _ i,tb) -&gt; mostDefinedS [i,tb]</span>
<span class="lineno"> 2350 </span><span class="spaces">                    </span><span class="istickedoff">(TypeSequence i,_) -&gt; <span class="nottickedoff">i</span></span>
<span class="lineno"> 2351 </span><span class="spaces">                    </span><span class="istickedoff">(_,tb ) -&gt; <span class="nottickedoff">tb</span></span>
<span class="lineno"> 2352 </span><span class="spaces">            </span><span class="istickedoff">a' &lt;- unifyTypesFailing (TypeFunction TypeAny t) (<span class="nottickedoff">r1</span>,a)</span>
<span class="lineno"> 2353 </span><span class="spaces">            </span><span class="istickedoff">b' &lt;- unifyTypesFailing t (<span class="nottickedoff">r2</span>,b)</span>
<span class="lineno"> 2354 </span><span class="spaces">            </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null a' || null b'</span> then  <span class="nottickedoff">Nothing</span> else Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 2355 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2356 </span><span class="spaces">        </span><span class="istickedoff">partyArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2357 </span><span class="spaces">        </span><span class="istickedoff">partyArgs (r1,a) (r2,b) = do</span>
<span class="lineno"> 2358 </span><span class="spaces">            </span><span class="istickedoff">let t = case (typeOf_ a,typeOf_ b) of</span>
<span class="lineno"> 2359 </span><span class="spaces">                    </span><span class="istickedoff">(ta,TypePartition tb) -&gt; mostDefinedS [ta,tb]</span>
<span class="lineno"> 2360 </span><span class="spaces">                    </span><span class="istickedoff">(ta,_ ) -&gt; <span class="nottickedoff">ta</span></span>
<span class="lineno"> 2361 </span><span class="spaces">            </span><span class="istickedoff">a' &lt;- unifyTypesFailing (t) (<span class="nottickedoff">r1</span>,a)</span>
<span class="lineno"> 2362 </span><span class="spaces">            </span><span class="istickedoff">b' &lt;- unifyTypesFailing (TypePartition t) (<span class="nottickedoff">r2</span>,b)</span>
<span class="lineno"> 2363 </span><span class="spaces">            </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null a' || null b'</span> then  <span class="nottickedoff">Nothing</span> else Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 2364 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2365 </span><span class="spaces">        </span><span class="istickedoff">inverseArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2366 </span><span class="spaces">        </span><span class="istickedoff">inverseArgs (r1,a) (r2,b) = do</span>
<span class="lineno"> 2367 </span><span class="spaces">            </span><span class="istickedoff">let (fIn,fOut) = case (typeOf_ a,typeOf_ b) of</span>
<span class="lineno"> 2368 </span><span class="spaces">                    </span><span class="istickedoff">(TypeFunction fi fo,TypeFunction gi go) -&gt; (mostDefinedS [fi,go],mostDefinedS [fo,gi])</span>
<span class="lineno"> 2369 </span><span class="spaces">                    </span><span class="istickedoff">(TypeFunction fi fo,_ ) -&gt; <span class="nottickedoff">(fi,fo)</span></span>
<span class="lineno"> 2370 </span><span class="spaces">                    </span><span class="istickedoff">(_,TypeFunction gi go) -&gt; <span class="nottickedoff">(gi,go)</span></span>
<span class="lineno"> 2371 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">(TypeAny,TypeAny)</span></span>
<span class="lineno"> 2372 </span><span class="spaces">            </span><span class="istickedoff">a' &lt;- unifyTypesFailing (TypeFunction fIn fOut) (<span class="nottickedoff">r1</span>,a)</span>
<span class="lineno"> 2373 </span><span class="spaces">            </span><span class="istickedoff">b' &lt;- unifyTypesFailing (TypeFunction fOut fIn) (<span class="nottickedoff">r2</span>,b)</span>
<span class="lineno"> 2374 </span><span class="spaces">            </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null a' || null b'</span> then  <span class="nottickedoff">Nothing</span> else Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 2375 </span><span class="spaces">        </span><span class="istickedoff">setPartArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2376 </span><span class="spaces">        </span><span class="istickedoff">setPartArgs (r1,a) (r2,b) = do</span>
<span class="lineno"> 2377 </span><span class="spaces">            </span><span class="istickedoff">let t  = case (typeOf_ a,typeOf_ b) of</span>
<span class="lineno"> 2378 </span><span class="spaces">                    </span><span class="istickedoff">(TypeSet st,TypePartition pt) -&gt; mostDefinedS [st,pt]</span>
<span class="lineno"> 2379 </span><span class="spaces">                    </span><span class="istickedoff">(TypeSet st,_) -&gt; st</span>
<span class="lineno"> 2380 </span><span class="spaces">                    </span><span class="istickedoff">(_,TypePartition ts) -&gt; <span class="nottickedoff">ts</span></span>
<span class="lineno"> 2381 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; TypeAny</span>
<span class="lineno"> 2382 </span><span class="spaces">            </span><span class="istickedoff">a' &lt;- unifyTypesFailing (TypeSet t) (r1,a)</span>
<span class="lineno"> 2383 </span><span class="spaces">            </span><span class="istickedoff">b' &lt;- unifyTypesFailing (TypePartition t) (r2,b)</span>
<span class="lineno"> 2384 </span><span class="spaces">            </span><span class="istickedoff">return $ if <span class="tickonlyfalse">null a' || null b'</span> then  <span class="nottickedoff">Nothing</span> else Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 2385 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2386 </span><span class="spaces">        </span><span class="istickedoff">partyType ::  Maybe Type -&gt;Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2387 </span><span class="spaces">        </span><span class="istickedoff">partyType a b = do</span>
<span class="lineno"> 2388 </span><span class="spaces">            </span><span class="istickedoff">let at' = fromMaybe <span class="nottickedoff">TypeAny</span> a</span>
<span class="lineno"> 2389 </span><span class="spaces">            </span><span class="istickedoff">let bt = case b of</span>
<span class="lineno"> 2390 </span><span class="spaces">                        </span><span class="istickedoff">Just (TypePartition t) -&gt; t</span>
<span class="lineno"> 2391 </span><span class="spaces">                        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny</span></span>
<span class="lineno"> 2392 </span><span class="spaces">            </span><span class="istickedoff">return $ TypeSet $ mostDefinedS [at',bt]</span>
<span class="lineno"> 2393 </span><span class="spaces">        </span><span class="istickedoff">partsType ::  Maybe (Type) -&gt; Maybe Type</span>
<span class="lineno"> 2394 </span><span class="spaces">        </span><span class="istickedoff">partsType (Just (TypePartition a)) = Just $ TypeSet $ TypeSet a</span>
<span class="lineno"> 2395 </span><span class="spaces">        </span><span class="istickedoff">partsType (Just TypeAny) = <span class="nottickedoff">Just $ TypeSet $ TypeSet TypeAny</span></span>
<span class="lineno"> 2396 </span><span class="spaces">        </span><span class="istickedoff">partsType _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2397 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2398 </span><span class="spaces">        </span><span class="istickedoff">minMaxArgs :: Arg -&gt; Validator ()</span>
<span class="lineno"> 2399 </span><span class="spaces">        </span><span class="istickedoff">minMaxArgs (r,(Kind DomainType t ,_)) =</span>
<span class="lineno"> 2400 </span><span class="spaces">            </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2401 </span><span class="spaces">                </span><span class="istickedoff">TypeInt TagInt -&gt; valid</span>
<span class="lineno"> 2402 </span><span class="spaces">                </span><span class="istickedoff">TypeInt (TagEnum _) -&gt; <span class="nottickedoff">valid</span></span>
<span class="lineno"> 2403 </span><span class="spaces">                </span><span class="istickedoff">TypeEnum {} -&gt; valid</span>
<span class="lineno"> 2404 </span><span class="spaces">                </span><span class="istickedoff">TypeAny -&gt; valid</span>
<span class="lineno"> 2405 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Domain of int-like or matrix of int-like&quot; t</span></span>
<span class="lineno"> 2406 </span><span class="spaces">        </span><span class="istickedoff">minMaxArgs (r,(k ,_)) = do</span>
<span class="lineno"> 2407 </span><span class="spaces">            </span><span class="istickedoff">t &lt;- getValueType k</span>
<span class="lineno"> 2408 </span><span class="spaces">            </span><span class="istickedoff">inner &lt;- case t of</span>
<span class="lineno"> 2409 </span><span class="spaces">                </span><span class="istickedoff">TypeList tyInner -&gt; return tyInner</span>
<span class="lineno"> 2410 </span><span class="spaces">                </span><span class="istickedoff">TypeMatrix _ tyInner -&gt; return tyInner</span>
<span class="lineno"> 2411 </span><span class="spaces">                </span><span class="istickedoff">TypeSet tyInner -&gt; return tyInner</span>
<span class="lineno"> 2412 </span><span class="spaces">                </span><span class="istickedoff">TypeMSet tyInner -&gt; return tyInner</span>
<span class="lineno"> 2413 </span><span class="spaces">                </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return TypeAny</span></span>
<span class="lineno"> 2414 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny &lt;$ invalid (r &lt;!&gt; ComplexTypeError &quot;Domain of int-like or matrix of int-like&quot; t)</span></span>
<span class="lineno"> 2415 </span><span class="spaces">            </span><span class="istickedoff">case inner of</span>
<span class="lineno"> 2416 </span><span class="spaces">                </span><span class="istickedoff">TypeInt TagInt -&gt; valid</span>
<span class="lineno"> 2417 </span><span class="spaces">                </span><span class="istickedoff">TypeInt (TagEnum _) -&gt; <span class="nottickedoff">valid</span></span>
<span class="lineno"> 2418 </span><span class="spaces">                </span><span class="istickedoff">TypeEnum {} -&gt; <span class="nottickedoff">valid</span></span>
<span class="lineno"> 2419 </span><span class="spaces">                </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">valid</span></span>
<span class="lineno"> 2420 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Domain of int-like or matrix of int-like&quot; t</span></span>
<span class="lineno"> 2421 </span><span class="spaces">        </span><span class="istickedoff">minMaxType :: Maybe (Kind,a) -&gt; Maybe Type</span>
<span class="lineno"> 2422 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind DomainType t@(TypeInt{}),_)) = Just t</span>
<span class="lineno"> 2423 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind DomainType (TypeEnum (Name nm)),_)) = Just . TypeInt $ TagEnum nm</span>
<span class="lineno"> 2424 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind ValueType (TypeMatrix _ a),_)) = minMaxType (Just (Kind DomainType a,<span class="nottickedoff">()</span>))</span>
<span class="lineno"> 2425 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind ValueType (TypeList  a) ,_)) =  minMaxType (Just (Kind DomainType a,<span class="nottickedoff">()</span>))</span>
<span class="lineno"> 2426 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind ValueType (TypeSet  a) ,_) )=  minMaxType (Just (Kind DomainType a,<span class="nottickedoff">()</span>))</span>
<span class="lineno"> 2427 </span><span class="spaces">        </span><span class="istickedoff">minMaxType (Just (Kind ValueType (TypeMSet a) ,_) )=  minMaxType (Just (Kind DomainType a,<span class="nottickedoff">()</span>))</span>
<span class="lineno"> 2428 </span><span class="spaces">        </span><span class="istickedoff">minMaxType _ = Just TypeAny</span>
<span class="lineno"> 2429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2430 </span><span class="spaces">        </span><span class="istickedoff">transformArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2431 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">transformArgs _ _ = do</span></span>
<span class="lineno"> 2432 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2433 </span><span class="spaces">        </span><span class="istickedoff">activeArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2434 </span><span class="spaces">        </span><span class="istickedoff">activeArgs (_,(typeOf_-&gt;TypeAny)) _ =<span class="nottickedoff">valid</span></span>
<span class="lineno"> 2435 </span><span class="spaces">        </span><span class="istickedoff">activeArgs (r,(typeOf_-&gt;t@(TypeVariant _))) (r2,typeOf_-&gt;b) = do</span>
<span class="lineno"> 2436 </span><span class="spaces">            </span><span class="istickedoff">checkRVMember (<span class="nottickedoff">r</span>,t) (<span class="nottickedoff">r2</span>,b)</span>
<span class="lineno"> 2437 </span><span class="spaces">        </span><span class="istickedoff">activeArgs (r,(typeOf_-&gt;t)) _ = <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Variant &quot; t</span></span>
<span class="lineno"> 2438 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2439 </span><span class="spaces">        </span><span class="istickedoff">typeToSet :: Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2440 </span><span class="spaces">        </span><span class="istickedoff">typeToSet (Just t) = Just . TypeSet $ fromMaybe <span class="nottickedoff">TypeAny</span> (tMembers t)</span>
<span class="lineno"> 2441 </span><span class="spaces">        </span><span class="istickedoff">typeToSet _ = <span class="nottickedoff">Just $ TypeSet TypeAny</span></span>
<span class="lineno"> 2442 </span><span class="spaces">        </span><span class="istickedoff">typeToMSet :: Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2443 </span><span class="spaces">        </span><span class="istickedoff">typeToMSet (Just t) = Just . TypeMSet $ fromMaybe <span class="nottickedoff">TypeAny</span> (tMembers t)</span>
<span class="lineno"> 2444 </span><span class="spaces">        </span><span class="istickedoff">typeToMSet _ = <span class="nottickedoff">Just $ TypeMSet TypeAny</span></span>
<span class="lineno"> 2445 </span><span class="spaces">        </span><span class="istickedoff">typeToRelation :: Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2446 </span><span class="spaces">        </span><span class="istickedoff">typeToRelation (Just(TypeFunction i j)) = Just $ TypeRelation [i,j]</span>
<span class="lineno"> 2447 </span><span class="spaces">        </span><span class="istickedoff">typeToRelation (Just(TypeAny)) = <span class="nottickedoff">Just $ TypeRelation [TypeAny,TypeAny]</span></span>
<span class="lineno"> 2448 </span><span class="spaces">        </span><span class="istickedoff">typeToRelation _ = <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2449 </span><span class="spaces">        </span><span class="istickedoff">tMembers t = case t of</span>
<span class="lineno"> 2450 </span><span class="spaces">                        </span><span class="istickedoff">TypeAny -&gt;  <span class="nottickedoff">Just TypeAny</span></span>
<span class="lineno"> 2451 </span><span class="spaces">                        </span><span class="istickedoff">TypeList ty -&gt; Just ty</span>
<span class="lineno"> 2452 </span><span class="spaces">                        </span><span class="istickedoff">TypeMatrix _ i -&gt; <span class="nottickedoff">Just i</span></span>
<span class="lineno"> 2453 </span><span class="spaces">                        </span><span class="istickedoff">TypeSet ty -&gt; Just ty</span>
<span class="lineno"> 2454 </span><span class="spaces">                        </span><span class="istickedoff">TypeMSet ty -&gt; Just ty</span>
<span class="lineno"> 2455 </span><span class="spaces">                        </span><span class="istickedoff">TypeFunction i j -&gt; <span class="nottickedoff">Just $ TypeTuple [i,j]</span></span>
<span class="lineno"> 2456 </span><span class="spaces">                        </span><span class="istickedoff">TypeRelation tys -&gt; Just $ TypeTuple tys</span>
<span class="lineno"> 2457 </span><span class="spaces">                        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2458 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2459 </span><span class="spaces">        </span><span class="istickedoff">imageArgs :: SArg -&gt; SArg -&gt; Validator ()</span>
<span class="lineno"> 2460 </span><span class="spaces">        </span><span class="istickedoff">imageArgs (r1,typeOf_-&gt;t1) r2 = do</span>
<span class="lineno"> 2461 </span><span class="spaces">            </span><span class="istickedoff">from &lt;- case t1 of</span>
<span class="lineno"> 2462 </span><span class="spaces">                </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ Just TypeAny</span></span>
<span class="lineno"> 2463 </span><span class="spaces">                </span><span class="istickedoff">TypeFunction a _ -&gt; return $ Just a</span>
<span class="lineno"> 2464 </span><span class="spaces">                </span><span class="istickedoff">TypeSequence _ -&gt; return $ Just tInt</span>
<span class="lineno"> 2465 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing &lt;$ (raiseTypeError $ (r1 &lt;!&gt; ComplexTypeError &quot;Function or Sequence&quot; t1))</span></span>
<span class="lineno"> 2466 </span><span class="spaces">            </span><span class="istickedoff">case from of </span>
<span class="lineno"> 2467 </span><span class="spaces">                </span><span class="istickedoff">Just f -&gt; unifyTypes f r2 &gt;&gt; return (pure <span class="nottickedoff">()</span>)</span>
<span class="lineno"> 2468 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 2469 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2470 </span><span class="spaces">        </span><span class="istickedoff">sumArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2471 </span><span class="spaces">        </span><span class="istickedoff">sumArgs (r,typeOf_-&gt;t') = do</span>
<span class="lineno"> 2472 </span><span class="spaces">            </span><span class="istickedoff">t &lt;- case t' of</span>
<span class="lineno"> 2473 </span><span class="spaces">                </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return TypeAny</span></span>
<span class="lineno"> 2474 </span><span class="spaces">                </span><span class="istickedoff">TypeList t -&gt; return t</span>
<span class="lineno"> 2475 </span><span class="spaces">                </span><span class="istickedoff">TypeMatrix _ t -&gt; return t</span>
<span class="lineno"> 2476 </span><span class="spaces">                </span><span class="istickedoff">TypeSet t -&gt; return t</span>
<span class="lineno"> 2477 </span><span class="spaces">                </span><span class="istickedoff">TypeMSet t -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 2478 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt;  <span class="nottickedoff">TypeAny &lt;$ (raiseTypeError $ r &lt;!&gt; ComplexTypeError &quot;Matrix or Set&quot; t')</span></span>
<span class="lineno"> 2479 </span><span class="spaces">                </span><span class="istickedoff"></span>
<span class="lineno"> 2480 </span><span class="spaces">            </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2481 </span><span class="spaces">              </span><span class="istickedoff">TypeAny -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2482 </span><span class="spaces">              </span><span class="istickedoff">TypeInt TagInt -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2483 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; Nothing &lt;$ raiseTypeError <span class="nottickedoff">(r &lt;!&gt; ComplexTypeError &quot;Integer elements&quot; t)</span></span>
<span class="lineno"> 2484 </span><span class="spaces">        </span><span class="istickedoff">funcSeq :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2485 </span><span class="spaces">        </span><span class="istickedoff">funcSeq (r,typeOf_-&gt;t') = case t' of</span>
<span class="lineno"> 2486 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2487 </span><span class="spaces">            </span><span class="istickedoff">TypeSequence _ -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2488 </span><span class="spaces">            </span><span class="istickedoff">TypeFunction _ _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2489 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Function or Sequence&quot; t'</span></span>
<span class="lineno"> 2490 </span><span class="spaces">        </span><span class="istickedoff">funcDomain :: Maybe (Type) -&gt; Maybe Type</span>
<span class="lineno"> 2491 </span><span class="spaces">        </span><span class="istickedoff">funcDomain (Just (TypeFunction a _)) = Just a</span>
<span class="lineno"> 2492 </span><span class="spaces">        </span><span class="istickedoff">funcDomain (Just (TypeSequence _)) = <span class="nottickedoff">Just tInt</span></span>
<span class="lineno"> 2493 </span><span class="spaces">        </span><span class="istickedoff">funcDomain _ = <span class="nottickedoff">Just TypeAny</span></span>
<span class="lineno"> 2494 </span><span class="spaces">        </span><span class="istickedoff">funcRange :: Maybe (Type) -&gt; Maybe Type</span>
<span class="lineno"> 2495 </span><span class="spaces">        </span><span class="istickedoff">funcRange (Just (TypeFunction _ b)) = Just b</span>
<span class="lineno"> 2496 </span><span class="spaces">        </span><span class="istickedoff">funcRange (Just ((TypeSequence b))) = Just b</span>
<span class="lineno"> 2497 </span><span class="spaces">        </span><span class="istickedoff">funcRange _ = <span class="nottickedoff">Just TypeAny</span></span>
<span class="lineno"> 2498 </span><span class="spaces">        </span><span class="istickedoff">part :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2499 </span><span class="spaces">        </span><span class="istickedoff">part (r,typeOf_-&gt;t) = case t of</span>
<span class="lineno"> 2500 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; valid</span>
<span class="lineno"> 2501 </span><span class="spaces">            </span><span class="istickedoff">TypePartition _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2502 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; TypeError (TypePartition TypeAny) t</span></span>
<span class="lineno"> 2503 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2504 </span><span class="spaces">        </span><span class="istickedoff">histArgs :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2505 </span><span class="spaces">        </span><span class="istickedoff">histArgs (r,typeOf_-&gt;a) = case a of</span>
<span class="lineno"> 2506 </span><span class="spaces">                            </span><span class="istickedoff">TypeMSet _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2507 </span><span class="spaces">                            </span><span class="istickedoff">TypeList _ -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2508 </span><span class="spaces">                            </span><span class="istickedoff">TypeMatrix _ _ -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2509 </span><span class="spaces">                            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2510 </span><span class="spaces">                            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Matrix, List or MSet&quot; a</span></span>
<span class="lineno"> 2511 </span><span class="spaces">        </span><span class="istickedoff">histType ::  Maybe Type -&gt; Maybe Type</span>
<span class="lineno"> 2512 </span><span class="spaces">        </span><span class="istickedoff">histType (Just ( (TypeMSet a) )) = Just $ TypeMatrix <span class="nottickedoff">tInt</span> $ <span class="nottickedoff">TypeTuple [a,tInt]</span></span>
<span class="lineno"> 2513 </span><span class="spaces">        </span><span class="istickedoff">histType (Just ( (TypeMatrix _ a)  )) = Just $ TypeMatrix <span class="nottickedoff">tInt</span> $ TypeTuple [a,tInt]</span>
<span class="lineno"> 2514 </span><span class="spaces">        </span><span class="istickedoff">histType (Just ( (TypeList a)  )) = <span class="nottickedoff">Just $ TypeMatrix tInt $ TypeTuple [a,tInt]</span></span>
<span class="lineno"> 2515 </span><span class="spaces">        </span><span class="istickedoff">histType _ = <span class="nottickedoff">Just $ TypeMatrix tInt $ TypeTuple [TypeAny,tInt]</span></span>
<span class="lineno"> 2516 </span><span class="spaces">        </span><span class="istickedoff">enumerable :: SArg -&gt; Validator ()</span>
<span class="lineno"> 2517 </span><span class="spaces">        </span><span class="istickedoff">enumerable (r,typeOf_-&gt;t) = case t of</span>
<span class="lineno"> 2518 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2519 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagUnnamed{} -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; CustomError &quot;Anonymous enums are not explictly enumerable&quot;</span></span>
<span class="lineno"> 2520 </span><span class="spaces">            </span><span class="istickedoff">TypeInt _ -&gt; return $ <span class="nottickedoff">pure ()</span></span>
<span class="lineno"> 2521 </span><span class="spaces">            </span><span class="istickedoff">TypeEnum{} -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2522 </span><span class="spaces">            </span><span class="istickedoff">TypeBool -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2523 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;int enum or bool&quot; t</span></span>
<span class="lineno"> 2524 </span><span class="spaces">        </span><span class="istickedoff">enumerableType :: Maybe (Type) -&gt; Maybe Type</span>
<span class="lineno"> 2525 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">enumerableType (Just t@(TypeInt TagInt)) = Just t</span></span>
<span class="lineno"> 2526 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">enumerableType (Just t@(TypeInt (TagEnum _))) = Just t</span></span>
<span class="lineno"> 2527 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">enumerableType (Just t@(TypeEnum{})) = Just t</span></span>
<span class="lineno"> 2528 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">enumerableType _ = Nothing</span></span></span>
<span class="lineno"> 2529 </span>
<span class="lineno"> 2530 </span>
<span class="lineno"> 2531 </span>flattenType :: Maybe Int -&gt; Maybe Type -&gt; Maybe Type
<span class="lineno"> 2532 </span><span class="decl"><span class="istickedoff">flattenType (Just n) (Just a  ) | <span class="nottickedoff">n &lt; 0</span> = <span class="nottickedoff">Just $ TypeList a</span></span>
<span class="lineno"> 2533 </span><span class="spaces"></span><span class="istickedoff">flattenType (Just n) (Just (TypeList m)  )= <span class="nottickedoff">flattenType (Just (n-1)) (Just (m))</span></span>
<span class="lineno"> 2534 </span><span class="spaces"></span><span class="istickedoff">flattenType (Just n) (Just (TypeMatrix _  m)  )= <span class="nottickedoff">flattenType (Just (n-1)) (Just (m))</span></span>
<span class="lineno"> 2535 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2536 </span><span class="spaces"></span><span class="istickedoff">flattenType Nothing (Just  (TypeMatrix _  m)) = flattenType Nothing (Just (m))</span>
<span class="lineno"> 2537 </span><span class="spaces"></span><span class="istickedoff">flattenType Nothing (Just  (TypeList  m)) = flattenType Nothing (Just (m))</span>
<span class="lineno"> 2538 </span><span class="spaces"></span><span class="istickedoff">flattenType Nothing (Just  (t)) = Just $ TypeList t</span>
<span class="lineno"> 2539 </span><span class="spaces"></span><span class="istickedoff">flattenType _ _ = <span class="nottickedoff">Just $ TypeList TypeAny</span></span></span>
<span class="lineno"> 2540 </span>
<span class="lineno"> 2541 </span>validateFuncOp :: Lexeme -&gt; [RegionTagged (Kind,Expression)] -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2542 </span><span class="decl"><span class="istickedoff">validateFuncOp l args = do</span>
<span class="lineno"> 2543 </span><span class="spaces">    </span><span class="istickedoff">let b = funcOpBuilder l</span>
<span class="lineno"> 2544 </span><span class="spaces">    </span><span class="istickedoff">b args</span></span>
<span class="lineno"> 2545 </span>    -- case argCheck of
<span class="lineno"> 2546 </span>    --   Nothing -&gt; return $ Typed  (r []) $ fallback &quot;arg fail&quot;
<span class="lineno"> 2547 </span>    --   Just tys -&gt; return $ Typed (r tys)(b $ map untype tys)
<span class="lineno"> 2548 </span>
<span class="lineno"> 2549 </span>isOfType :: Type -&gt; RegionTagged (Typed Expression) -&gt; ValidatorS Bool
<span class="lineno"> 2550 </span><span class="decl"><span class="nottickedoff">isOfType t (r,v) = setContext r &gt;&gt; return v ?=&gt; exactly t  &gt;&gt; (return $ typesUnifyS [t,typeOf_ v])</span></span>
<span class="lineno"> 2551 </span>
<span class="lineno"> 2552 </span>isLogicalContainer :: RegionTagged (Typed Expression) -&gt; Validator ()
<span class="lineno"> 2553 </span><span class="decl"><span class="istickedoff">isLogicalContainer (r,Typed t _) = do</span>
<span class="lineno"> 2554 </span><span class="spaces">    </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2555 </span><span class="spaces">      </span><span class="istickedoff">TypeAny -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2556 </span><span class="spaces">      </span><span class="istickedoff">TypeList TypeAny -&gt; return $ <span class="nottickedoff">pure ()</span></span>
<span class="lineno"> 2557 </span><span class="spaces">      </span><span class="istickedoff">TypeList TypeBool -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2558 </span><span class="spaces">      </span><span class="istickedoff">TypeMatrix _ TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2559 </span><span class="spaces">      </span><span class="istickedoff">TypeMatrix _ TypeBool -&gt; return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2560 </span><span class="spaces">      </span><span class="istickedoff">TypeSet TypeAny -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2561 </span><span class="spaces">      </span><span class="istickedoff">TypeMSet TypeBool -&gt; <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2562 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">invalid $ r &lt;!&gt; ComplexTypeError &quot;Collection of boolean&quot; t</span></span></span>
<span class="lineno"> 2563 </span>
<span class="lineno"> 2564 </span>
<span class="lineno"> 2565 </span>-- validateArgList :: [RegionTagged (Typed Expression) -&gt; ValidatorS Bool] -&gt; [RegionTagged (Typed Expression)] -&gt; Validator [Typed Expression]
<span class="lineno"> 2566 </span>-- validateArgList ps args | length args &lt; length ps = do invalid $ args &lt;!&gt; MissingArgsError (length ps)
<span class="lineno"> 2567 </span>-- validateArgList ps args = do
<span class="lineno"> 2568 </span>--     let ps' = ps ++ repeat argOverflow
<span class="lineno"> 2569 </span>--     xs &lt;- zipWithM id ps' args
<span class="lineno"> 2570 </span>--     return (if and xs then  Just $ map unregion  args else Nothing)
<span class="lineno"> 2571 </span>
<span class="lineno"> 2572 </span>-- argOverflow :: RegionTagged a -&gt; ValidatorS Bool
<span class="lineno"> 2573 </span>-- argOverflow (region,_) = do
<span class="lineno"> 2574 </span>--     setContext region
<span class="lineno"> 2575 </span>--     void . contextError $ CustomError &quot;Extra Args&quot;
<span class="lineno"> 2576 </span>--     return False
<span class="lineno"> 2577 </span>type SArg = RegionTagged (Typed Expression)
<span class="lineno"> 2578 </span>type Arg = RegionTagged (Kind,Expression)
<span class="lineno"> 2579 </span>unFunc ::  (Arg -&gt; Validator a) --Arg validator
<span class="lineno"> 2580 </span>        -&gt; (Maybe (Kind,Expression) -&gt; Maybe Type) --typeEvaluator
<span class="lineno"> 2581 </span>        -&gt; ([Expression]-&gt;Expression)  --mkOp or similar
<span class="lineno"> 2582 </span>        -&gt; [Arg] -&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2583 </span><span class="decl"><span class="istickedoff">unFunc argVal t f args = do</span>
<span class="lineno"> 2584 </span><span class="spaces">    </span><span class="istickedoff">(v,ts) &lt;- case args of</span>
<span class="lineno"> 2585 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do tooFewArgs 1 0 &gt;&gt; return (Nothing,Nothing)</span></span>
<span class="lineno"> 2586 </span><span class="spaces">        </span><span class="istickedoff">[x] -&gt; do</span>
<span class="lineno"> 2587 </span><span class="spaces">            </span><span class="istickedoff">r&lt;- argVal x</span>
<span class="lineno"> 2588 </span><span class="spaces">            </span><span class="istickedoff">tc &lt;- gets typeChecking</span>
<span class="lineno"> 2589 </span><span class="spaces">            </span><span class="istickedoff">let result = case r of</span>
<span class="lineno"> 2590 </span><span class="spaces">                    </span><span class="istickedoff">Nothing | <span class="tickonlyfalse">tc</span> -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2591 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; Just $ map (snd . unregion) [x]</span>
<span class="lineno"> 2592 </span><span class="spaces">            </span><span class="istickedoff">return (result,(Just  $ unregion x))</span>
<span class="lineno"> 2593 </span><span class="spaces">        </span><span class="istickedoff">(x:rs) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 2594 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">tooManyArgs rs</span></span>
<span class="lineno"> 2595 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">r &lt;- argVal x</span></span>
<span class="lineno"> 2596 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let result =case r of</span></span>
<span class="lineno"> 2597 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 2598 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; Just $ map (snd . unregion) [x]</span></span>
<span class="lineno"> 2599 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return (result,Just $ unregion x)</span></span>
<span class="lineno"> 2600 </span><span class="spaces">    </span><span class="istickedoff">let res = maybe <span class="nottickedoff">(fallback &quot;Arg Fail Unfunc&quot;)</span>  f v</span>
<span class="lineno"> 2601 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed (fromMaybe <span class="nottickedoff">TypeAny</span> $ t ts) res</span></span>
<span class="lineno"> 2602 </span>biFunc :: (Arg -&gt; Arg -&gt; Validator a) -&gt; (Maybe (Kind,Expression) -&gt;Maybe (Kind,Expression) -&gt;Maybe Type) -&gt; ([Expression]-&gt;Expression)  -&gt; [Arg]-&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2603 </span><span class="decl"><span class="istickedoff">biFunc argVal t f args = do</span>
<span class="lineno"> 2604 </span><span class="spaces">    </span><span class="istickedoff">(v,ts) &lt;- case args of</span>
<span class="lineno"> 2605 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do tooFewArgs 2 0 &gt;&gt; return (Nothing,(Nothing,Nothing))</span></span>
<span class="lineno"> 2606 </span><span class="spaces">        </span><span class="istickedoff">[x] -&gt; <span class="nottickedoff">do tooFewArgs 2 1 &gt;&gt; return (Nothing,(Just $ unregion x,Nothing))</span></span>
<span class="lineno"> 2607 </span><span class="spaces">        </span><span class="istickedoff">[x,y] -&gt; do</span>
<span class="lineno"> 2608 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- argVal x y</span>
<span class="lineno"> 2609 </span><span class="spaces">            </span><span class="istickedoff">tc &lt;- gets <span class="nottickedoff">typeChecking</span></span>
<span class="lineno"> 2610 </span><span class="spaces">            </span><span class="istickedoff">let result = case r of</span>
<span class="lineno"> 2611 </span><span class="spaces">                    </span><span class="istickedoff">Nothing | <span class="nottickedoff">tc</span> -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2612 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; Just $ map (snd . unregion) [x,y]</span>
<span class="lineno"> 2613 </span><span class="spaces">            </span><span class="istickedoff">return (result,(Just ( unregion x) , Just ( unregion y)))</span>
<span class="lineno"> 2614 </span><span class="spaces">        </span><span class="istickedoff">(x:y:rs) -&gt; do</span>
<span class="lineno"> 2615 </span><span class="spaces">            </span><span class="istickedoff">tooManyArgs rs</span>
<span class="lineno"> 2616 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- argVal x y</span>
<span class="lineno"> 2617 </span><span class="spaces">            </span><span class="istickedoff">let <span class="nottickedoff">result =case r of</span></span>
<span class="lineno"> 2618 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 2619 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; Just $ map (snd . unregion) [x,y]</span></span>
<span class="lineno"> 2620 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">result</span>,<span class="nottickedoff">(Just ( unregion x) , Just ( unregion y))</span>)</span>
<span class="lineno"> 2621 </span><span class="spaces">    </span><span class="istickedoff">let res = maybe <span class="nottickedoff">(fallback &quot;Arg Fail BiFunct&quot;)</span>  f v</span>
<span class="lineno"> 2622 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed (fromMaybe <span class="nottickedoff">TypeAny</span> $ uncurry t ts) res</span></span>
<span class="lineno"> 2623 </span>
<span class="lineno"> 2624 </span>triFunc :: (Arg  -&gt; Arg -&gt; Arg -&gt; Validator a) -&gt; (Maybe (Kind,Expression) -&gt;Maybe (Kind,Expression) -&gt;Maybe (Kind,Expression) -&gt;Maybe Type) -&gt; ([Expression]-&gt;Expression)  -&gt; [Arg]-&gt; ValidatorS (Typed Expression)
<span class="lineno"> 2625 </span><span class="decl"><span class="istickedoff">triFunc argVal t f args = do</span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="istickedoff">(v,ts) &lt;- case args of</span>
<span class="lineno"> 2627 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">do tooFewArgs 3 0 &gt;&gt; return (Nothing,(Nothing,Nothing,Nothing))</span></span>
<span class="lineno"> 2628 </span><span class="spaces">        </span><span class="istickedoff">[x] -&gt; <span class="nottickedoff">do tooFewArgs 3 1 &gt;&gt; return (Nothing,(Just  $ unregion x,Nothing,Nothing))</span></span>
<span class="lineno"> 2629 </span><span class="spaces">        </span><span class="istickedoff">[x,y] -&gt; <span class="nottickedoff">do tooFewArgs 3 2 &gt;&gt; return (Nothing,(Just  $ unregion x,Just  $ unregion y,Nothing))</span></span>
<span class="lineno"> 2630 </span><span class="spaces">        </span><span class="istickedoff">[x,y,z] -&gt; do</span>
<span class="lineno"> 2631 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- argVal x y z</span>
<span class="lineno"> 2632 </span><span class="spaces">            </span><span class="istickedoff">tc &lt;- gets <span class="nottickedoff">typeChecking</span></span>
<span class="lineno"> 2633 </span><span class="spaces">            </span><span class="istickedoff">let result = case r of</span>
<span class="lineno"> 2634 </span><span class="spaces">                    </span><span class="istickedoff">Nothing | <span class="nottickedoff">tc</span> -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2635 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; Just $ map (snd . unregion) [x,y,z]</span>
<span class="lineno"> 2636 </span><span class="spaces">            </span><span class="istickedoff">return (result,(<span class="nottickedoff">Just ( unregion x)</span> , <span class="nottickedoff">Just ( unregion y)</span>, <span class="nottickedoff">Just ( unregion z)</span>))</span>
<span class="lineno"> 2637 </span><span class="spaces">        </span><span class="istickedoff">(x:y:z:rs) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 2638 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">tooManyArgs rs</span></span>
<span class="lineno"> 2639 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">r &lt;- argVal x y z</span></span>
<span class="lineno"> 2640 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">let result =case r of</span></span>
<span class="lineno"> 2641 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 2642 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; Just $ map (snd . unregion) [x,y,z]</span></span>
<span class="lineno"> 2643 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">return (result,(Just (unregion x) , Just ( unregion y), Just ( unregion z)))</span></span>
<span class="lineno"> 2644 </span><span class="spaces">    </span><span class="istickedoff">let res = maybe <span class="nottickedoff">(fallback &quot;Arg Fail Tri&quot;)</span> f v</span>
<span class="lineno"> 2645 </span><span class="spaces">    </span><span class="istickedoff">return $ Typed (fromMaybe <span class="nottickedoff">TypeAny</span> $ uncurry3 t ts) res</span>
<span class="lineno"> 2646 </span><span class="spaces">    </span><span class="istickedoff">where uncurry3 fn (a,b,c) = fn <span class="nottickedoff">a</span> <span class="nottickedoff">b</span> <span class="nottickedoff">c</span></span></span> --todo export from prelude
<span class="lineno"> 2647 </span>tooFewArgs :: Int -&gt; Int -&gt; ValidatorS ()
<span class="lineno"> 2648 </span><span class="decl"><span class="nottickedoff">tooFewArgs n i = do</span>
<span class="lineno"> 2649 </span><span class="spaces">    </span><span class="nottickedoff">void . contextError $ MissingArgsError n i</span></span>
<span class="lineno"> 2650 </span>
<span class="lineno"> 2651 </span>tooManyArgs :: [RegionTagged a] -&gt; ValidatorS ()
<span class="lineno"> 2652 </span><span class="decl"><span class="istickedoff">tooManyArgs = mapM_ (\x -&gt;do raiseError $ x &lt;!&gt; UnexpectedArg)</span></span>
<span class="lineno"> 2653 </span>
<span class="lineno"> 2654 </span>checkRVMember  :: RegionTagged Type -&gt; RegionTagged Type -&gt; Validator ()
<span class="lineno"> 2655 </span><span class="decl"><span class="istickedoff">checkRVMember (_,TypeRecord ts) (_,TypeRecordMember nm _) | <span class="nottickedoff">not . null $ lookup nm ts</span>  = <span class="nottickedoff">return $ pure ()</span></span>
<span class="lineno"> 2656 </span><span class="spaces"></span><span class="istickedoff">checkRVMember (_,TypeRecord ts) (r2,r) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 2657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseTypeError $ r2 &lt;!&gt; TypeError (TypeRecordMember (Name &quot;&quot;) ts) r</span></span>
<span class="lineno"> 2658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 2659 </span><span class="spaces"></span><span class="istickedoff">checkRVMember (_,TypeVariant ts) (_,TypeVariantMember nm _) | <span class="tickonlytrue">not . null $ lookup nm ts</span> = return $ pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2660 </span><span class="spaces"></span><span class="istickedoff">checkRVMember (_,TypeVariant ts) (r2,r) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 2661 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseTypeError $ r2 &lt;!&gt; TypeError (TypeVariantMember (Name &quot;&quot;) ts) r</span></span>
<span class="lineno"> 2662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 2663 </span><span class="spaces"></span><span class="istickedoff">checkRVMember (r1,t) _ = <span class="nottickedoff">do</span></span>
<span class="lineno"> 2664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">raiseTypeError $ r1 &lt;!&gt; TypeError (TypeVariant []) t</span></span>
<span class="lineno"> 2665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return Nothing</span></span></span>
<span class="lineno"> 2666 </span>
<span class="lineno"> 2667 </span>
<span class="lineno"> 2668 </span>
<span class="lineno"> 2669 </span>type OpValidator = RegionTagged Kind -&gt; RegionTagged Kind -&gt; ValidatorS Type
<span class="lineno"> 2670 </span>type OpTyper = Kind -&gt; Kind -&gt; Type
<span class="lineno"> 2671 </span>
<span class="lineno"> 2672 </span>sameToSameV :: (Type -&gt; ValidatorS Type) -&gt; (Type -&gt; Type -&gt; Type) -&gt; OpValidator
<span class="lineno"> 2673 </span><span class="decl"><span class="istickedoff">sameToSameV tc t (rl,kl) (rr,kr) = do</span>
<span class="lineno"> 2674 </span><span class="spaces">    </span><span class="istickedoff">setContext rl</span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="istickedoff">lt &lt;- getValueType kl</span>
<span class="lineno"> 2676 </span><span class="spaces">    </span><span class="istickedoff">lt' &lt;- tc lt</span>
<span class="lineno"> 2677 </span><span class="spaces">    </span><span class="istickedoff">setContext rr</span>
<span class="lineno"> 2678 </span><span class="spaces">    </span><span class="istickedoff">rt &lt;- getValueType kr</span>
<span class="lineno"> 2679 </span><span class="spaces">    </span><span class="istickedoff">rt' &lt;- tc rt</span>
<span class="lineno"> 2680 </span><span class="spaces">    </span><span class="istickedoff">let md = mostDefinedS [lt,rt]</span>
<span class="lineno"> 2681 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- unifyTypesFailing md (<span class="nottickedoff">rl</span>,Typed lt' <span class="nottickedoff">()</span>) </span>
<span class="lineno"> 2682 </span><span class="spaces">    </span><span class="istickedoff">_ &lt;- unifyTypesFailing md (rr,Typed rt' <span class="nottickedoff">()</span>) </span>
<span class="lineno"> 2683 </span><span class="spaces">    </span><span class="istickedoff">return $ t lt' rt'</span></span>
<span class="lineno"> 2684 </span>
<span class="lineno"> 2685 </span>binOpType :: Lexeme -&gt; OpValidator
<span class="lineno"> 2686 </span><span class="decl"><span class="istickedoff">binOpType l = case l of</span>
<span class="lineno"> 2687 </span><span class="spaces">    </span><span class="istickedoff">L_Plus -&gt; sameToSameV number same</span>
<span class="lineno"> 2688 </span><span class="spaces">    </span><span class="istickedoff">L_Minus -&gt; sameToSameV minusArgs same</span>
<span class="lineno"> 2689 </span><span class="spaces">    </span><span class="istickedoff">L_Times -&gt; sameToSameV number same</span>
<span class="lineno"> 2690 </span><span class="spaces">    </span><span class="istickedoff">L_Div -&gt; sameToSameV number same</span>
<span class="lineno"> 2691 </span><span class="spaces">    </span><span class="istickedoff">L_Mod -&gt; sameToSameV number same</span>
<span class="lineno"> 2692 </span><span class="spaces">    </span><span class="istickedoff">L_Pow -&gt; sameToSameV number same</span>
<span class="lineno"> 2693 </span><span class="spaces">    </span><span class="istickedoff">L_Eq -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2694 </span><span class="spaces">    </span><span class="istickedoff">L_Neq -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2695 </span><span class="spaces">    </span><span class="istickedoff">L_Lt -&gt; sameToSameV orderable cBool</span>
<span class="lineno"> 2696 </span><span class="spaces">    </span><span class="istickedoff">L_Leq -&gt; sameToSameV orderable cBool</span>
<span class="lineno"> 2697 </span><span class="spaces">    </span><span class="istickedoff">L_Gt -&gt; sameToSameV orderable cBool</span>
<span class="lineno"> 2698 </span><span class="spaces">    </span><span class="istickedoff">L_Geq -&gt; sameToSameV orderable cBool</span>
<span class="lineno"> 2699 </span><span class="spaces">    </span><span class="istickedoff">L_in -&gt; checkIn</span>
<span class="lineno"> 2700 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 2701 </span><span class="spaces">    </span><span class="istickedoff">L_And -&gt; sameToSameV bools (cBool)</span>
<span class="lineno"> 2702 </span><span class="spaces">    </span><span class="istickedoff">L_Or -&gt; sameToSameV bools (cBool)</span>
<span class="lineno"> 2703 </span><span class="spaces">    </span><span class="istickedoff">L_Imply -&gt; sameToSameV bools (cBool)</span>
<span class="lineno"> 2704 </span><span class="spaces">    </span><span class="istickedoff">L_Iff -&gt; sameToSameV bools (cBool) -- b b b</span>
<span class="lineno"> 2705 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 2706 </span><span class="spaces">    </span><span class="istickedoff">L_subset -&gt; sameToSameV setLike (cBool) -- set mset func rel</span>
<span class="lineno"> 2707 </span><span class="spaces">    </span><span class="istickedoff">L_subsetEq -&gt; sameToSameV setLike (cBool) -- ^^^</span>
<span class="lineno"> 2708 </span><span class="spaces">    </span><span class="istickedoff">L_supset -&gt; sameToSameV setLike (cBool) -- ^^^^</span>
<span class="lineno"> 2709 </span><span class="spaces">    </span><span class="istickedoff">L_supsetEq -&gt; sameToSameV setLike (cBool) -- ^^</span>
<span class="lineno"> 2710 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 2711 </span><span class="spaces">    </span><span class="istickedoff">L_subsequence -&gt; sameToSameV justSequence (cBool) -- seq - seq -bool</span>
<span class="lineno"> 2712 </span><span class="spaces">    </span><span class="istickedoff">L_substring -&gt; sameToSameV justSequence (cBool) -- seq - seq -bool</span>
<span class="lineno"> 2713 </span><span class="spaces">    </span><span class="istickedoff"></span>
<span class="lineno"> 2714 </span><span class="spaces">    </span><span class="istickedoff">L_intersect -&gt; sameToSameV setLike (same)</span>
<span class="lineno"> 2715 </span><span class="spaces">    </span><span class="istickedoff">L_union -&gt; sameToSameV setLike (same)</span>
<span class="lineno"> 2716 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2717 </span><span class="spaces">    </span><span class="istickedoff">L_LexLt -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2718 </span><span class="spaces">    </span><span class="istickedoff">L_LexLeq -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2719 </span><span class="spaces">    </span><span class="istickedoff">L_LexGt -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2720 </span><span class="spaces">    </span><span class="istickedoff">L_LexGeq -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2721 </span><span class="spaces">    </span><span class="istickedoff">L_DotLt -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2722 </span><span class="spaces">    </span><span class="istickedoff">L_DotLeq -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2723 </span><span class="spaces">    </span><span class="istickedoff">L_DotGt -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2724 </span><span class="spaces">    </span><span class="istickedoff">L_DotGeq -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2725 </span><span class="spaces">    </span><span class="istickedoff">L_TildeLt -&gt; sameToSameV pure cBool</span>
<span class="lineno"> 2726 </span><span class="spaces">    </span><span class="istickedoff">L_TildeLeq -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2727 </span><span class="spaces">    </span><span class="istickedoff">L_TildeGt -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2728 </span><span class="spaces">    </span><span class="istickedoff">L_TildeGeq -&gt; <span class="nottickedoff">sameToSameV pure cBool</span></span>
<span class="lineno"> 2729 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">bug $ &quot;Unkown operator&quot; &lt;+&gt; pretty (show l)</span></span>
<span class="lineno"> 2730 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 2731 </span><span class="spaces">    </span><span class="istickedoff">cBool = const. const TypeBool</span>
<span class="lineno"> 2732 </span><span class="spaces">    </span><span class="istickedoff">same a b = mostDefinedS [a,b]</span>
<span class="lineno"> 2733 </span><span class="spaces">    </span><span class="istickedoff">checkIn :: OpValidator</span>
<span class="lineno"> 2734 </span><span class="spaces">    </span><span class="istickedoff">checkIn (r1,kl) (r2,kr) = do</span>
<span class="lineno"> 2735 </span><span class="spaces">        </span><span class="istickedoff">setContext <span class="nottickedoff">r1</span></span>
<span class="lineno"> 2736 </span><span class="spaces">        </span><span class="istickedoff">lt &lt;- getValueType kl</span>
<span class="lineno"> 2737 </span><span class="spaces">        </span><span class="istickedoff">setContext <span class="nottickedoff">r2</span></span>
<span class="lineno"> 2738 </span><span class="spaces">        </span><span class="istickedoff">rt &lt;- getValueType kr</span>
<span class="lineno"> 2739 </span><span class="spaces">        </span><span class="istickedoff">case innerTypeOf rt of</span>
<span class="lineno"> 2740 </span><span class="spaces">                    </span><span class="istickedoff">Just t -&gt; unifyTypes t (<span class="nottickedoff">r1</span>,Typed lt <span class="nottickedoff">()</span>)</span>
<span class="lineno"> 2741 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 2742 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">unless (rt==TypeAny) $ raiseTypeError (r2 &lt;!&gt; ComplexTypeError  (T.pack . show $ &quot;Container of &quot; &lt;+&gt; pretty lt) rt)</span></span>
<span class="lineno"> 2743 </span><span class="spaces">        </span><span class="istickedoff">return TypeBool</span>
<span class="lineno"> 2744 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2745 </span><span class="spaces">    </span><span class="istickedoff">number :: Type -&gt; ValidatorS Type</span>
<span class="lineno"> 2746 </span><span class="spaces">    </span><span class="istickedoff">number t = do</span>
<span class="lineno"> 2747 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2748 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagInt -&gt; return t</span>
<span class="lineno"> 2749 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagEnum{} -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 2750 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 2751 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; TypeAny &lt;$ contextTypeError (ComplexTypeError &quot;Number or Enum&quot; t)</span>
<span class="lineno"> 2752 </span><span class="spaces">    </span><span class="istickedoff">minusArgs t = do</span>
<span class="lineno"> 2753 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2754 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagInt -&gt; return t</span>
<span class="lineno"> 2755 </span><span class="spaces">            </span><span class="istickedoff">TypeSet _ -&gt; return t</span>
<span class="lineno"> 2756 </span><span class="spaces">            </span><span class="istickedoff">TypeMSet _ -&gt; return t</span>
<span class="lineno"> 2757 </span><span class="spaces">            </span><span class="istickedoff">TypeRelation _ -&gt; return t</span>
<span class="lineno"> 2758 </span><span class="spaces">            </span><span class="istickedoff">TypeFunction _ _ -&gt; return t</span>
<span class="lineno"> 2759 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; TypeAny &lt;$ contextTypeError (ComplexTypeError &quot;Number / set/ mset / relation / function&quot; t)</span>
<span class="lineno"> 2760 </span><span class="spaces">    </span><span class="istickedoff">orderable t = do</span>
<span class="lineno"> 2761 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2762 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagInt -&gt; return t</span>
<span class="lineno"> 2763 </span><span class="spaces">            </span><span class="istickedoff">TypeInt TagEnum{} -&gt; return t</span>
<span class="lineno"> 2764 </span><span class="spaces">            </span><span class="istickedoff">TypeBool -&gt; return t</span>
<span class="lineno"> 2765 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; return t</span>
<span class="lineno"> 2766 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny &lt;$ contextTypeError (ComplexTypeError &quot;Number, Enum or Bool&quot; t)</span></span>
<span class="lineno"> 2767 </span><span class="spaces">    </span><span class="istickedoff">justSequence t = do</span>
<span class="lineno"> 2768 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2769 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 2770 </span><span class="spaces">            </span><span class="istickedoff">TypeSequence _ -&gt; return t</span>
<span class="lineno"> 2771 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny &lt;$ contextTypeError (TypeError (TypeSequence TypeAny) t)</span></span>
<span class="lineno"> 2772 </span><span class="spaces">    </span><span class="istickedoff">bools t = do</span>
<span class="lineno"> 2773 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2774 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; return t</span>
<span class="lineno"> 2775 </span><span class="spaces">            </span><span class="istickedoff">TypeBool -&gt; return t</span>
<span class="lineno"> 2776 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny &lt;$ contextTypeError (TypeError TypeBool t)</span></span>
<span class="lineno"> 2777 </span><span class="spaces">    </span><span class="istickedoff">setLike t = do</span>
<span class="lineno"> 2778 </span><span class="spaces">        </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2779 </span><span class="spaces">            </span><span class="istickedoff">TypeAny -&gt; <span class="nottickedoff">return t</span></span>
<span class="lineno"> 2780 </span><span class="spaces">            </span><span class="istickedoff">TypeMSet _ -&gt; return t</span>
<span class="lineno"> 2781 </span><span class="spaces">            </span><span class="istickedoff">TypeSet _ -&gt; return t</span>
<span class="lineno"> 2782 </span><span class="spaces">            </span><span class="istickedoff">TypeFunction _ _ -&gt; return t</span>
<span class="lineno"> 2783 </span><span class="spaces">            </span><span class="istickedoff">TypeRelation _ -&gt; return t</span>
<span class="lineno"> 2784 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TypeAny &lt;$ contextTypeError (ComplexTypeError &quot;Set MSet funcition or relation&quot; t)</span></span></span>

</pre>
</body>
</html>
